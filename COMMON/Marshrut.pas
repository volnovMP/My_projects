unit Marshrut;
{$INCLUDE d:\Sapr2012\CfgProject}
//------------------------------------------------------------------------------
//             œÓˆÂ‰Û˚ Ë ÒÚÛÍÚÛ˚ ÛÒÚ‡ÌÓ‚ÍË Ï‡¯ÛÚÓ‚ –Ã-ƒ—œ
//------------------------------------------------------------------------------

interface

uses
  Windows,
  SysUtils,
  TypeAll;
var

  MarhRdy      : Boolean; //----------------- ÔËÁÌ‡Í „ÓÚÓ‚ÌÓÒÚË Ï‡¯ÛÚ‡ Í ‚˚‰‡˜Â ‚ Í‡Ì‡Î
  LastMsgToDSP : string;
  LastJmp : TOZNeighbour;

function ResetTrace : Boolean;
function ResetMarhrutSrv(fr : word) : Boolean;
function BeginTracertMarshrut(index, command : SmallInt) : Boolean;
function EndTracertMarshrut : Boolean;
function OtkrytRazdel(Svetofor : SmallInt; Marh : Byte; Group : Byte) : Boolean;
function PovtorSvetofora(Svetofor : SmallInt; Marh : Byte; Group : Byte) : Boolean;
function PovtorOtkrytSvetofora(Svetofor : SmallInt; Marh : Byte; Group : Byte) : Boolean;
function PovtorMarsh(Svetofor : SmallInt; Marh : Byte; Group : Byte) : Boolean;
function GetSoglOtmeny(Uslovie : SmallInt) : string;

{$IFDEF RMDSP}
function OtmenaMarshruta(Svetofor : SmallInt; Marh : Byte) : Boolean;
{$ENDIF}

function GetIzvestitel(Svetofor : SmallInt; Marh : Byte) : Byte;
function FindIzvStrelki(Svetofor : SmallInt; Marh : Byte) : Boolean;
function SetProgramZamykanie(Group : Byte; Auto : Boolean) : Boolean;
function SendMarshrutCommand(Group : Byte) : Boolean;
function SendTraceCommand(Group : Byte) : Boolean;
function RestorePrevTrace : Boolean;
{$IFNDEF RMARC}
function AddToTracertMarshrut(index : SmallInt) : Boolean;
function NextToTracertMarshrut(index : SmallInt) : Boolean;
{$ENDIF}
function StepTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte) : TTracertResult;

//------------------------------------------------------ ‘”Õ ÷»» “–¿——»–Œ¬ » ◊≈–≈« —“–≈À ”
function StepTraceStrelka(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;

function StepStrelFindTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelContTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelZavTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelCheckTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelZamykTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelSignalCirc(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelOtmenaMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelRazdelSign(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelAutoTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelPovtorRazdel(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelFindIzvest(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelFindIzvStrel(var Con :TOZNeighbour; const Lvl :TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepStrelPovtorMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;

//---------------------------------------------------- ‘”Õ ÷»» “–¿——»–Œ¬ » ◊≈–≈« ”œ »À» —œ
function StepTraceSP(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;

function StepSPforFindTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPforContTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPforZavTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPforCheckTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPforZamykTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPSignalCirc(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPOtmenaMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPRazdelSign(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPPovtorRazdel(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPAutoTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPFindIzvest(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPFindIzvStrel(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSPPovtorMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;


//--------------------------------------------------------- ‘”Õ ÷»» “–¿——»–Œ¬ » ◊≈–≈« œ”“‹
function StepTracePut(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;

function StepPutFindTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutContTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutZavTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutCheckTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutZamykTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutSignalCirc(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutOtmenaMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutRazdelSign(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutAutoTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutFindIzvest(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutFindIzvStrel(var Con :TOZNeighbour; const Lvl :TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepPutPovtorMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;


//---------------------------------------------------- ‘”Õ ÷»» “–¿——»–Œ¬ » ◊≈–≈« —¬≈“Œ‘Œ–€
function StepTraceSvetofor(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;

function StepSvetoforFindTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod:Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSvetoforContTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSvetoforZavTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSvetoforCheckTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSvetoforZamykTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSignalCirc(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSigOtmenaMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSigAutoPovtorRazdel(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSigFindIzvest(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSigPovtorMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepSigFindIzvStrel(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;


function StepTraceAB(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTracePriglas(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceUKSPS(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceVSN(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceUvazManRn(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceZaprosPoezdOtpr(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTracePAB(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceDZOhr(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceIzvPer(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceDZSP(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTracePoezdSogl(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceUvazGor(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceMarNadvig(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceMarshOtpr(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTracePerezamStrInPut(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceOPI(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceZonaOpov(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function StepTraceProchee(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
function SoglasieOG(Index : SmallInt) : Boolean;
function CheckOgrad(ptr : SmallInt; Group : Byte) : Boolean;
function CheckOtpravlVP(ptr : SmallInt; Group : Byte) : Boolean;
function NegStrelki(ptr : SmallInt; pk : Boolean; Group : Byte) : Boolean;
function SignCircOgrad(ptr : SmallInt; Group : Byte) : Boolean;
function SignCircOtpravlVP(ptr : SmallInt; Group : Byte) : Boolean;
function SigCircNegStrelki(ptr : SmallInt; pk : Boolean; Group : Byte) : Boolean;
function VytajkaRM(ptr : SmallInt) : Boolean;
function VytajkaZM(ptr : SmallInt) : Boolean;
function VytajkaOZM(ptr : SmallInt) : Boolean;
function VytajkaCOT(ptr : SmallInt) : string;
function GetStateSP(mode : Byte; Obj : SmallInt) : SmallInt;
procedure SetNadvigParam(Ptr : SmallInt);
function AutoMarsh(Ptr : SmallInt; mode : Boolean) : Boolean;
function CheckAutoMarsh(Ptr : SmallInt; Group : Byte) : Boolean;
function AutoMarshReset(Ptr : SmallInt) : Boolean;
function AutoMarshON(Ptr : SmallInt; Napr : Boolean) : Boolean;
function AutoMarshOFF(Ptr : SmallInt; Napr : Boolean  ) : Boolean;

const
  MarshM = 3;   //----------------------------------------------------- Ã‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
  MarshP = 12;  //------------------------------------------------------- œÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ
  MarshL = 19;  //--------------------------------------------------- ÀÓ„Ë˜ÂÒÍÓÂ Á‡Ï˚Í‡ÌËÂ


  TryMarhLimit = 6962;//----------------------- Ò˜ÂÚ˜ËÍ Ó·˙ÂÍÚÓ‚ ÔË Ú‡ÒÒËÓ‚ÍÂ Ï‡¯ÛÚ‡.
                      //----------------  ÍÓÎ-‚Ó ÔÓÈ‰ÂÌ˚ı Ó·˙ÂÍÚÓ‚ ÔÂ‚˚ÒËÚ ˝ÚÓ ÁÌ‡˜ÂÌËÂ,
                      //-------- ÚÓ ÒÓÓ·˘ÂÌËÂ 231 ("ÔÂ‚˚¯ÂÌ Ò˜ÂÚ˜ËÍ ÔÓÔ˚ÚÓÍ Ú‡ÒÒËÓ‚ÍË")

implementation

uses
  Commands,
  CMenu,
  MainLoop,

{$IFDEF RMDSP}
  TabloForm,
{$ENDIF}

{$IFDEF RMARC}
  TabloFormARC,
{$ENDIF}

{$IFDEF RMSHN}
  TabloSHN,
{$ENDIF}

{$IFDEF TABLO}
  TabloForm1,
{$ENDIF}
  Commons;

var
  tm : string;

//========================================================================================
function ResetTrace : Boolean;
//----------------------------------------------------- —·ÓÒËÚ¸ ÒÚÛÍÚÛ˚ Ì‡·Ó‡ Ï‡¯ÛÚ‡
var
  i,k,o : integer;
begin
try
  WorkMode.GoTracert        :=false; //-------------- Ò·ÓÒËÚ¸ ÔËÁÌ‡Í "Ë‰ÂÚ Ú‡ÒÒËÓ‚Í‡"
  MarhTracert[1].SvetBrdr   :=0;//Ò·ÓÒ ËÌ‰ÂÍÒ‡ Ò‚ÂÚÓÙÓ‡,Ó„‡Ê‰‡˛˘. ˝ÎÂÏÂÌÚ‡Ì˚È Û˜‡ÒÚÓÍ
  MarhTracert[1].AutoMarh   :=false;//Ò·ÓÒ ÔËÁÌ‡Í‡ Ú‡ÒÒË.Ï‡¯ÛÚ‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ ÒË„Ì‡Î‡
  MarhTracert[1].Povtor     :=false;//Ò·ÓÒ ÔËÁÌ‡Í‡ ÔÓ‚ÚÓÌÓÈ ÔÓ‚ÂÍË Ú‡ÒÒ˚ Ï‡¯ÛÚ‡
                                    //  (‰Îˇ ÒÌˇÚËˇ ÍÓÌÚÓÎˇ ÔÂ‰‚‡ËÚ. Á‡Ï˚Í‡ÌËˇ Ì‡ ¿–ÃÂ)
  MarhTracert[1].GonkaStrel :=false;//--- Ò·ÓÒ ÔËÁÌ‡Í‡ ‰ÓÔÛÒÚËÏÓÒÚË ‚˚‰‡˜Ë ÍÓÏ‡Ì‰˚ „ÓÌÍË
                                    //  ÒÚÂÎÓÍ (‰Îˇ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡ ·ÂÁ Á‡Ï˚Í‡ÌËˇ Ú‡ÒÒ˚)
  MarhTracert[1].GonkaList  :=0; //------------Ò·ÓÒ ÍÓÎË˜ÂÒÚ‚‡ ÒÚÂÎÓÍ ‰Îˇ ‚˚‰‡˜Ë ÍÓÏ‡Ì‰˚
                                 // „ÓÌÍË ÒÚÂÎÓÍ ‰Îˇ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡ ·ÂÁ Á‡Ï˚Í‡ÌËˇ Ú‡ÒÒ˚
  Marhtracert[1].LockPovtor :=false;//Ò·ÓÒ ÔËÁÌ‡Í‡ ·ÎÓÍËÓ‚ÍË ‚˚‰‡˜Ë ÔÓ‚ÚÓÌÓÈ ÛÒÚ‡ÌÓ‚ÍË
                                    //            Ï‡¯ÛÚ‡ ÔÓÒÎÂ Ó·Ì‡ÛÊÂÌËˇ ‚‡Ê‰Â·ÌÓÒÚÂÈ
  MarhTracert[1].Finish     :=false; //---- Ò·ÓÒËÚ¸ ‡ÁÂ¯ÂÌËÂ Ì‡Ê‡Ú¸ ÍÌÓÔÍÛ ÍÓÌˆ‡ Ì‡·Ó‡
  MarhTracert[1].TailMsg    := '';  //--------------- Ò·ÓÒËÚ¸ ÒÓÓ·˘ÂÌËÂ ‚ ı‚ÓÒÚÂ Ï‡¯ÛÚ‡
  MarhTracert[1].FindTail   := false;//---------- Ò·ÓÒËÚ¸ ÔËÁÌ‡Í Ì‡·Ó‡ ÒÚÓÍË ÒÓÓ·˘ÂÌËˇ
                                     //                            Ó ÍÓÌˆÂ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡
  MarhTracert[1].WarCount   := 0; //Ò·ÓÒËÚ¸ Ò˜ÂÚ˜ËÍ ÔÂ‰ÛÔÂÊ‰ÂÌËÈ ÔË ÛÒÚ‡ÌÓ‚ÍÂ Ï‡¯ÛÚ‡
  MarhTracert[1].MsgCount   := 0; //--------------- Ò·ÓÒËÚ¸ Ò˜ÂÚ˜ËÍ ÒÓÓ·˘ÂÌËÈ Ú‡ÒÒËÓ‚ÍË
  k := 0;
  MarhTracert[1].VP         := 0; //--- Ò·ÓÒËÚ¸ Ó·˙ÂÍÚ ¬œ ‰Îˇ Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡ ÔËÂÏ‡
  MarhTracert[1].TraceRazdel := false;//Ò·ÓÒ ÔËÁÌ‡Í‡ Ú‡ÒÒËÓ‚ÍË ‚ ‡Á‰ÂÎ¸ÌÓÏ ÛÔ‡‚ÎÂÌËË
  if MarhTracert[1].ObjStart > 0 then //----------------- ÂÒÎË ÂÒÚ¸ Ó·˙ÂÍÚ Ì‡˜‡Î‡ Ï‡¯ÛÚ‡
  begin //------------------------------------------------ Ò·ÓÒ ÔËÁÌ‡Í‡ œœ– Ì‡ Ò‚ÂÚÓÙÓÂ
    k := MarhTracert[1].ObjStart;
    if not ObjZav[k].bParam[14] then
    begin
      ObjZav[k].bParam[7] := false; //----------------------- Ò·ÓÒ Ï‡ÌÂ‚Ó‚ÓÈ Ú‡ÒÒËÓ‚ÍË
      ObjZav[k].bParam[9] := false; //------------------------- Ò·ÓÒ ÔÓÂÁ‰ÌÓÈ Ú‡ÒÒËÓ‚ÍË
    end;
  end;
  MarhTracert[1].ObjStart := 0;
  for i := 1 to WorkMode.LimitObjZav do
  begin // —·ÓÓÒ ÔËÁÌ‡ÍÓ‚ Ú‡ÒÒËÓ‚ÍË Ì‡ ‚ÒÂı Ó·˙ÂÍÚ‡ı ÒÚ‡ÌˆËË
    case ObjZav[i].TypeObj of

      1 : begin // ı‚ÓÒÚ ÒÚÂÎÍË
        ObjZav[i].bParam[27] := false;
        ObjZav[i].iParam[3] := 0;
      end;

      2 : begin // ÒÚÂÎÍ‡
        ObjZav[i].bParam[10] := false;
        ObjZav[i].bParam[11] := false;
        ObjZav[i].bParam[12] := false;
        ObjZav[i].bParam[13] := false;
      end;

      3 : begin // ÒÂÍˆËˇ
        if not ObjZav[i].bParam[14] then
        begin
          ObjZav[i].bParam[8] := true;
        end;
      end;

      4 : begin // ÔÛÚ¸
        if not ObjZav[i].bParam[14] then
        begin
          ObjZav[i].bParam[8] := true;
        end;
      end;

      5 : begin // Ò‚ÂÚÓÙÓ
        if not ObjZav[i].bParam[14] and // ÌÂÚ ÔÂ‰‚‡ËÚÂÎ¸ÌÓ„Ó Á‡Ï˚Í‡ÌËˇ
           ObjZav[i].bParam[11] then    // ÌÂÚ ËÒÔÓÎÌËÚÂÎ¸ÌÓ„Ó Á‡Ï˚Í‡ÌËˇ
        begin
          ObjZav[i].bParam[7] := false;
          ObjZav[i].bParam[9] := false;
        end;
      end;

      8 : begin // ”“—
        ObjZav[i].bParam[27] := false;
      end;

      15 : begin // ¿¡
        if not ObjZav[i].bParam[14] and // ÌÂÚ ÔÂ‰‚‡ËÚÂÎ¸ÌÓ„Ó Á‡Ï˚Í‡ÌËˇ
           ObjZav[ObjZav[i].BaseObject].bParam[2] then // ÌÂÚ ËÒÔÓÎÌËÚÂÎ¸ÌÓ„Ó Á‡Ï˚Í‡ÌËˇ
        begin
          ObjZav[i].bParam[15] := false;
        end;
      end;

      25 : begin //  ÓÎÓÌÍ‡
        if not ObjZav[i].bParam[14] then // ÌÂÚ ÔÂ‰‚‡ËÚÂÎ¸ÌÓ„Ó Á‡Ï˚Í‡ÌËˇ
        begin
          ObjZav[i].bParam[8] := false;
        end;
      end;

      41 : begin //  ÓÌÚÓÎ¸ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ
        o := ObjZav[i].UpdateObject;
        if not ObjZav[o].bParam[14] and ObjZav[o].bParam[2] and // ÌÂÚ ÔÂ‰‚‡ËÚÂÎ¸ÌÓ„Ó ËÎË ËÒÔÓÎÌËÚÂÎ¸ÌÓ„Ó Á‡Ï˚Í‡ÌËˇ
           not ObjZav[ObjZav[i].BaseObject].bParam[3] and not ObjZav[ObjZav[i].BaseObject].bParam[4] then // ‚˚ıÓ‰ÌÓÈ ÒË„Ì‡Î ÌÂ ÓÚÍ˚Ú ÔÓÂÁ‰Ì˚Ï
        begin
          ObjZav[i].bParam[20] := false;
          ObjZav[i].bParam[21] := false;
        end;
      end;

      42 :
      begin //-------------------------------------- ÔÂÂÁ‡Ï˚Í‡ÌËÂ ÔÓÂÁ‰ÌÓ„Ó Ì‡ Ï‡ÌÂ‚Ó‚˚È
        o := ObjZav[i].UpdateObject;      //------------------------ ÍÓÌÚÓÎËÛÂÏ‡ˇ ÒÂÍˆËˇ
        if not ObjZav[o].bParam[14] and //------- ÂÒÎË ÌÂÚ ÔÓ„‡ÏÏÌÓ„Ó Á‡Ï˚Í‡ÌËˇ ÒÂÍˆËË Ë
        ObjZav[o].bParam[2] then //------------------------------- ÌÂÚ ÂÎÂÈÌÓ„Ó Á‡Ï˚Í‡ÌËˇ
        begin
          ObjZav[i].bParam[1] := false;  //------  ÔËÁÌ‡Í ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡ ÔËÂÏ‡ ÒÌˇÚ¸
          ObjZav[i].bParam[2] := false; //--------- ÔËÁÌ‡Í ‡ÁÂ¯ÂÌËˇ ÔÂÂÁ‡Ï˚Í‡ÌËˇ ÒÌˇÚ¸
        end;
      end;
    end;
  end;

  //--------------------------------------------------------------- Ó˜ËÒÚËÚ¸ ‚ÒÂ ÒÓÓ·˘ÂÌËˇ
  for i := 1 to High(MarhTracert[1].Msg) do
  begin
    MarhTracert[1].Msg[i] := '';
    MarhTracert[1].MsgIndex[i] := 0;
    MarhTracert[1].MsgObject[i] := 0;
  end;
  MarhTracert[1].MsgCount := 0;
  //---------------------------------------------------------- Ó˜ËÒÚËÚ¸ ‚ÒÂ ÔÂ‰ÛÔÂÊ‰ÂÌËˇ
  for i := 1 to High(MarhTracert[1].Warning) do
  begin
    MarhTracert[1].Warning[i]  := '';
    MarhTracert[1].WarIndex[i] := 0;
    MarhTracert[1].WarObject[i] := 0;
  end;
  MarhTracert[1].WarCount := 0;

  //------------------------------------------------------------ Ó˜ËÒÚËÚ¸ ‚ÒÂ ÚÓ˜ÍË Ú‡ÒÒ˚
  for i := 1 to High(MarhTracert[1].ObjTrace) do MarhTracert[1].ObjTrace[i] := 0;
  MarhTracert[1].Counter := 0;

  //---------------------------------------------------------- Ó˜ËÒÚËÚ¸ ‚ÒÂ ÒÚÂÎÍË Ú‡ÒÒ˚
  for i := 1 to High(MarhTracert[1].StrTrace) do
  begin
    MarhTracert[1].StrTrace[i] := 0;
    MarhTracert[1].PolTrace[i,1] := false;
    MarhTracert[1].PolTrace[i,2] := false;
  end;
  MarhTracert[1].StrCount := 0;

  MarhTracert[1].ObjEnd := 0;
  MarhTracert[1].ObjLast := 0;
  MarhTracert[1].ObjStart := 0;

  MarhTracert[1].PinLast := 0;
  MarhTracert[1].Rod := 0;

  WorkMode.GoTracert := false;

  if (k > 0) and not ObjZav[k].bParam[14] then
  begin
    InsArcNewMsg(k,2,1);
    ShowShortMsg(2,LastX,LastY,'ÓÚ '+ ObjZav[k].Liter);
  end;
  ResetTrace := true;
  ZeroMemory(@MarhTracert[1],sizeof(MarhTracert[1]));
except
  reportf('Œ¯Ë·Í‡ [Marshrut.ResetTrace]'); ResetTrace := false;
end;
end;
//========================================================================================
function ResetMarhrutSrv(fr : word) : Boolean;
//---------------------------------------------------- –Â‡ÍˆËˇ Ì‡ Ò·ÓÒ Ï‡¯ÛÚ‡ ‚ ÒÂ‚ÂÂ
var
  i,im : integer;
begin
try
  im := 0;
  // ÔÓËÒÍ ËÌ‰ÂÍÒ‡ Ï‡¯ÛÚ‡ ÔÓ ÌÓÏÂÛ FR3
  for i := 1 to WorkMode.LimitObjZav do
    if ObjZav[i].TypeObj = 5 then
    begin
      if ObjZav[i].ObjConstI[3] > 0 then
        if fr = (ObjZav[i].ObjConstI[3] div 8) then begin im := i; break; end;
      if ObjZav[i].ObjConstI[5] > 0 then
        if fr = (ObjZav[i].ObjConstI[5] div 8) then begin im := i; break; end;
    end;
  if im > 0 then
  begin // ÛÒÚ‡ÌÓ‚ËÚ¸ ÔËÁÌ‡Í Ò·ÓÒ‡ Ï‡¯ÛÚ‡ Ì‡ ÒÂ‚ÂÂ ‰Îˇ ‚ÒÂı Ò‚ÂÚÓÙÓÓ‚ ‰‡ÌÌÓ„Ó Ï‡¯ÛÚ‡
    for i := 1 to WorkMode.LimitObjZav do
      if ObjZav[i].TypeObj = 5 then
        if ObjZav[i].iParam[1] = im then ObjZav[i].bParam[34] := true; // ÛÒÚ‡ÌÓ‚ËÚ¸ Ì‡ Ò‚ÂÚÓÙÓ˚ ‚ ÒÓÒÚ‡‚ÌÓÏ Ï‡¯ÛÚÂ
    if ObjZav[im].RU = config.ru then
    begin // ‚˚‚ÂÒÚË ÒÓÓ·˘ÂÌËÂ Ó ÌÂËÒÔÓÎÌÂÌËË Ï‡¯ÛÚ‡
      MsgStateRM := GetShortMsg(2,7,ObjZav[im].Liter,1);
      MsgStateClr := 1;
    end;
    InsArcNewMsg(im,7+$400,1);
    ResetMarhrutSrv := true;
  end else
  begin // ËÌ‰ÂÍÒ Ï‡¯ÛÚ‡ ÌÂ ÓÔÂ‰ÂÎÂÌ
    ResetMarhrutSrv := false;
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.ResetMarhrutSrv]'); ResetMarhrutSrv := false;
end;
end;
//========================================================================================
procedure InsWar(Group,Obj,Index : SmallInt);
//---------------------------------------------------------- ‰Ó·‡‚ËÚ¸ ÌÓ‚ÓÂ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
begin
  MarhTracert[Group].WarObject[MarhTracert[Group].WarCount] := Obj;
  MarhTracert[Group].WarIndex[MarhTracert[Group].WarCount] := Index;
end;
//========================================================================================
procedure InsMsg(Group,Obj,Index : SmallInt);
//----------------------------------------------------- ‰Ó·‡‚ËÚ¸ Ó·Ì‡ÛÊÂÌÌÛ˛ ‚‡Ê‰Â·ÌÓÒÚ¸
begin
  MarhTracert[Group].MsgObject[MarhTracert[Group].MsgCount] := Obj;
  MarhTracert[Group].MsgIndex[MarhTracert[Group].MsgCount] := Index;
end;
//========================================================================================
function OtkrytRazdel(Svetofor : SmallInt; Marh : Byte; Group : Byte) : Boolean;
//------------------------------------------ ÓÚÍ˚Ú¸ ÒË„Ì‡Î ‚ ‡Á‰ÂÎ¸ÌÓÏ ÂÊËÏÂ ÛÔ‡‚ÎÂÌËˇ
var
  i : Integer;
  jmp : TOZNeighbour;
begin
try
  ResetTrace;
  if Marh = MarshM then
  begin
    ObjZav[Svetofor].bParam[7] := true;
    ObjZav[Svetofor].bParam[9] := false;
  end else
  begin
    ObjZav[Svetofor].bParam[7] := false;
    ObjZav[Svetofor].bParam[9] := true;
  end;

  MarhTracert[Group].SvetBrdr := Svetofor;
  MarhTracert[Group].Rod := Marh;
  MarhTracert[Group].Finish := false;
  MarhTracert[Group].WarCount := 0;
  MarhTracert[Group].MsgCount := 0;
  MarhTracert[Group].ObjStart := Svetofor;

  // œÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË ÔÓ ‚ÒÂÈ Ú‡ÒÒÂ
  i := 1000;
  jmp := ObjZav[Svetofor].Neighbour[2];

  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  MarhTracert[Group].Level := tlRazdelSign; //---------- ÂÊËÏ ÓÚÍ˚Ú¸ ÒË„Ì‡Î ‚ ‡Á‰ÂÎ¸ÌÓÏ
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  MarhTracert[Group].FindTail := true;
  while i > 0 do
  begin
    case StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group) of

      trStop, trEnd : break;

      trEndTrace : break;
    end;
    dec(i);
  end;

  if i < 1 then
  begin // Ú‡ÒÒ‡ Ï‡¯ÛÚ‡ ‡ÁÛ¯ÂÌ‡
    result := false;
    InsArcNewMsg(Svetofor,228,1);
    ShowShortMsg(228, LastX, LastY, ObjZav[Svetofor].Liter);
    Marhtracert[Group].LockPovtor := true; MarhTracert[Group].ObjStart := 0;
    exit;
  end;

  if MarhTracert[Group].MsgCount > 0 then
  begin  //--------------------------------------------------------- ÓÚÍ‡Á ÔÓ ‚‡Ê‰Â·ÌÓÒÚË
    MarhTracert[1].TraceRazdel := true;//---- «‡ÍÓÌ˜ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË ÂÒÚ¸ ‚‡Ê‰Â·ÌÓÒÚË
    InsArcNewMsg(MarhTracert[Group].MsgObject[1],MarhTracert[Group].MsgIndex[1],1);
    PutShortMsg(1,LastX,LastY,MarhTracert[Group].Msg[1]);
    result := false;
    Marhtracert[Group].LockPovtor := true;
    MarhTracert[Group].ObjStart := 0;
    exit;
  end;

  // œÓ‚ÂËÚ¸ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ Ì‡ ÓÚÒÛÚÒÚ‚ËÂ ÔÓÂÁ‰‡ Ì‡ ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı
  if FindIzvStrelki (Svetofor, MarhTracert[Group].Rod) then
  begin
    inc(MarhTracert[Group].WarCount);
    MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
    GetShortMsg(1, 333, ObjZav[MarhTracert[Group].ObjStart].Liter,1); //
    InsWar(Group,MarhTracert[Group].ObjStart,333);
  end;
{$IFNDEF RMARC}
  if MarhTracert[Group].WarCount > 0 then
  begin //---------------------------------------------------------------- ‚˚‚Ó‰ ÒÓÓ·˘ÂÌËÈ

    CreateDspMenu(CmdMarsh_Razdel,LastX,LastY);
    result := false;
    exit;
  end;
{$ENDIF}
  result := true;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.OtkrytRazdel]'); result := false;
end;
end;

//========================================================================================
function CheckAutoMarsh(Ptr : SmallInt; Group : Byte) : Boolean;
//-------------------- œÓ‚ÂÍ‡ ‚ÓÁÏÓÊÌÓÒÚË ‚˚‰‡˜Ë ÍÓÏ‡Ì‰˚ ÛÒÚ‡ÌÓ‚ÍË Ï‡¯ÛÚ‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
//-------------------------------- Ptr - Ó·˙ÂÍÚ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ ‰Îˇ Ò‚ÂÚÓÙÓ‡ Ò ‡‚ÚÓ‰ÂÈÒÚ‚ËÂÏ
//--------------------------------------------------------------------- Group - „ÛÔÔ‡  –”
var
  i : Integer;
  jmp : TOZNeighbour;
  tr : boolean;
begin
  try
    result := false;
    //------------------------- ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ ÔÓÚË‚ÓÔÓ‚ÚÓÌÓÒÚË Ï‡¯ÛÚ‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
    if ObjZav[Ptr].bParam[2] then   //---------------------- ÂÒÎË ÔÓÚË‚ÓÔÓ‚ÚÓÍ‡ ‚Á‚Â‰ÂÌ‡
    begin
      //----------------------------------------- ÓÊË‰‡Ú¸ „ÓÚÓ‚ÌÓÒÚ¸ Ï‡¯ÛÚ‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
      MarhTracert[Group].Rod := MarshP;
      MarhTracert[Group].Finish := false;
      MarhTracert[Group].WarCount := 0;
      MarhTracert[Group].MsgCount := 0;
      MarhTracert[Group].ObjStart := ObjZav[Ptr].BaseObject; //-- Ò‚ÂÚÓÙÓ Ò ‡‚ÚÓ‰ÂÈÒÚ‚ËÂÏ
      MarhTracert[Group].Counter := 0;

      //- ¬˚‰‡Ú¸ ÍÓÏ‡Ì‰Û ÓÚÍ˚ÚËˇ ÒË„Ì‡Î‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ ‚ ‚Ë‰Â ‡Á‰ÂÎ¸ÌÓ„Ó ÓÚÍ˚ÚËˇ ÒË„Ì‡Î‡
      i := 1000;
      jmp := ObjZav[ObjZav[Ptr].BaseObject].Neighbour[2]; //- ÒÓÒÂ‰ Ò‚ÂÚÓÙÓ‡ ÒÓ ÒÚÓÓÌ˚ 2
      MarhTracert[Group].FindTail := true;
      //--------------------------------- ÔÓ‚ÂËÚ¸ Á‡Ï˚Í‡ÌËÂ ÔÂÂÍ˚‚ÌÓÈ ÒÂÍˆËË Ò‚ÂÚÓÙÓ‡
      if ObjZav[ObjZav[ObjZav[Ptr].BaseObject].BaseObject].bParam[2] then //ÂÒÎË ÒÌˇÚÓ "«"
      begin
        //------- ÒÌˇÚ¸ ÔËÁÌ‡Í Á‡ÌˇÚËˇ ÔÂÂÍ˚‚ÌÓÈ ÒÂÍˆËË ÔË ÓÚÒÛÚÒÚ‚ËË Á‡Ï˚Í‡ÌËˇ ÒÂÍˆËË
        ObjZav[Ptr].bParam[3] := false; //- Ò·ÓÒ ÔËÁÌ‡Í‡ ÙËÍÒ.Á‡ÌˇÚËˇ —œ Ï‡¯ÛÚ‡ ‡‚ÚÓ‰.
        ObjZav[Ptr].bParam[4] := false;// Ò·ÓÒ ÔËÁÌ‡Í‡ ÙËÍÒ.Á‡ÌˇÚËˇ ÔË ÓÚÍ˚ÚÓÏ ÒË„Ì‡ÎÂ
        ObjZav[Ptr].bParam[5] := false;  //- Ò·ÓÒ ÔËÁÌ‡Í‡ ÙËÍÒ.‚˚‰‡˜Ë ÒÓÓ·˘.Ó ÌÂÓÚÍ˚ÚËË
        tr := true;
      end else
      begin
        //----- ÔÓ‚ÂËÚ¸ Á‡ÌˇÚËÂ ÔÂÂÍ˚‚ÌÓÈ ÒÂÍˆËË ÔÓÒÎÂ Á‡Ï˚Í‡ÌËˇ Ï‡¯ÛÚ‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
        tr := false;
        if ObjZav[Ptr].bParam[3] then
        begin //------------ Á‡ÙËÍÒËÓ‚‡ÌÓ Á‡ÌˇÚËÂ ÔÂÂÍ˚‚ÌÓÈ ÒÂÍˆËË ‚ Á‡ÏÍÌÛÚÓÏ Ï‡¯ÛÚÂ
          if not ObjZav[Ptr].bParam[4] then
          begin
            if not ObjZav[Ptr].bParam[5] then
            begin
              InsArcNewMsg(ObjZav[Ptr].BaseObject,475,1);//—Ë„Ì‡Î  ÌÂ ÓÚÍ˚Ú ÍÓÏ‡Ì‰ÓÈ ¿‚ƒÚ
              AddFixMessage(GetShortMsg(1,475,ObjZav[ObjZav[Ptr].BaseObject].Liter,1),4,5);
              ObjZav[Ptr].bParam[5] := true;
            end;
          end;
          MarhTracert[Group].ObjStart := 0;
          exit;
        end else
        if ObjZav[ObjZav[ObjZav[Ptr].BaseObject].BaseObject].bParam[1] then
        begin //---------------------------------------------------------- ÒÂÍˆËˇ Ò‚Ó·Ó‰Ì‡

          //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          MarhTracert[Group].Level := tlSignalCirc;  //----------- ÂÊËÏ ÒË„Ì‡Î¸Ì‡ˇ ÒÚÛÌ‡
          //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        end else
        begin
          ObjZav[Ptr].bParam[3] := true; //--------- ÙËÍÒËÓ‚‡Ú¸ Á‡ÌˇÚËÂ ÒÂÍˆËË ‚ Ï‡¯ÛÚÂ
          if ObjZav[ObjZav[Ptr].BaseObject].bParam[4] then
          //-------- ÙËÍÒ‡ˆËˇ ÓÚÍ˚ÚÓ„Ó ÒÓÒÚÓˇÌËˇ ÒË„Ì‡Î‡ Ì‡ ÏÓÏÂÌÚ Á‡ÌˇÚËˇ ÔÂÂÍ˚‚ÌÓÈ —œ
          ObjZav[Ptr].bParam[4] := true;
          MarhTracert[Group].ObjStart := 0;
          exit;
        end;
      end;

      if tr then
      begin // ‚˚·‡Ú¸ ÛÒÎÓ‚Ëˇ ÔÓ‚ÂÍË ‰Îˇ ÌÂÁ‡ÏÍÌÛÚÓ„Ó ÓÚ ÂÎÂ "«" Ï‡¯ÛÚ‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ

        if ObjZav[ObjZav[Ptr].BaseObject].bParam[9] or  //ÔËÁÌ‡Í ÔÓÂÁ‰ÌÓÈ Ú‡ÒÒËÓ‚ÍË ËÎË
        ObjZav[ObjZav[Ptr].BaseObject].bParam[14] then //-- ÔËÁÌ‡Í ÔÓ„‡ÏÏÌÓ„Ó Á‡Ï˚Í‡ÌËˇ

        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        MarhTracert[Group].Level := tlPovtorRazdel //- ÂÊËÏ ÔÓ‚ÚÓ ÓÚÍ˚ÚËˇ ÔÓ Á‡ÏÍÌÛÚÓÏÛ
        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        else

        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        MarhTracert[Group].Level := tlRazdelSign;//----- ÂÊËÏ ÓÚÍ˚Ú¸ ÒË„Ì‡Î ‚ ‡Á‰ÂÎ¸ÌÓÏ
        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      end;

      MarhTracert[Group].AutoMarh := true;
      MarhTracert[Group].SvetBrdr := ObjZav[Ptr].BaseObject;
      ObjZav[ObjZav[Ptr].BaseObject].bParam[9] := true;
      while i > 0 do
      begin
        case StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group) of
          trStop, trEnd, trEndTrace :  break;
        end;
        dec(i);
      end;

      if i < 1 then exit; //------------------------------------ Ú‡ÒÒ‡ Ï‡¯ÛÚ‡ ‡ÁÛ¯ÂÌ‡

      if MarhTracert[Group].MsgCount > 0 then
      begin
        MarhTracert[Group].ObjStart := 0;
        exit; //---------------------------------------------------- ÓÚÍ‡Á ÔÓ ‚‡Ê‰Â·ÌÓÒÚË
      end;
      result := true;
    end else
    begin //------------------ ÔÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË ÔÓ ‚ÒÂÈ Ú‡ÒÒÂ Ï‡¯ÛÚ‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
      ObjZav[ObjZav[Ptr].BaseObject].bParam[7] := false; //-- Ò·ÓÒ Ï‡ÌÂ‚Ó‚ÓÈ Ú‡ÒÒËÓ‚ÍË
      ObjZav[ObjZav[Ptr].BaseObject].bParam[9] := false; //---- Ò·ÓÒ ÔÓÂÁ‰ÌÓÈ Ú‡ÒÒËÓ‚ÍË
      MarhTracert[Group].Rod := MarshP;
      MarhTracert[Group].Finish := false;
      MarhTracert[Group].WarCount := 0;
      MarhTracert[Group].MsgCount := 0;
      MarhTracert[Group].ObjStart := ObjZav[Ptr].BaseObject;
      MarhTracert[Group].Counter := 0;
      i := 1000;
      jmp := ObjZav[ObjZav[Ptr].BaseObject].Neighbour[2];

      //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      MarhTracert[Group].Level := tlAutoTrace; //--- ÂÊËÏ  ÓÚÍ˚Ú¸ ÒË„Ì‡Î ‚ Ï‡¯. ‡‚ÚÓ‰.
      //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      MarhTracert[Group].FindTail := true;
      while i > 0 do
      begin
        case StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group) of
          trStop, trEnd, trEndTrace : break;
        end;
        dec(i);
      end;

      if i < 1 then exit; //------------------------------------ Ú‡ÒÒ‡ Ï‡¯ÛÚ‡ ‡ÁÛ¯ÂÌ‡
      if MarhTracert[Group].MsgCount > 0 then
      begin
{
        if not ObjZav[Ptr].bParam[4] then
        begin
          AddFixMessage(GetShortMsg(1,475,ObjZav[ObjZav[Ptr].BaseObject].Liter),4,5);
        end;
}
        MarhTracert[Group].ObjStart := 0;
        MarhTracert[Group].MsgCount := 0;
        exit; //---------------------------------------------------- ÓÚÍ‡Á ÔÓ ‚‡Ê‰Â·ÌÓÒÚË
      end;
      //--------------------------------------------------------- Á‡˘ËÚÌ˚È Û˜‡ÒÚÓÍ Á‡ÌˇÚ ?
      case ObjZav[ObjZav[Ptr].UpdateObject].TypeObj of
        4 :
        begin //--------------------------------------------------------------------- ÔÛÚ¸
          if not ObjZav[ObjZav[Ptr].UpdateObject].bParam[1] or
          not ObjZav[ObjZav[Ptr].UpdateObject].bParam[16] then
          begin
            MarhTracert[Group].ObjStart := 0;
            exit;
          end;
        end;

        15 :
        begin //----------------------------------------------------------------------- ¿¡
          if not ObjZav[ObjZav[Ptr].UpdateObject].bParam[2] then
          begin
            MarhTracert[Group].ObjStart := 0;
            exit;
          end;
        end;

        else //--------------------------------------------------------------------- —œ,”œ
          if not ObjZav[ObjZav[Ptr].UpdateObject].bParam[1] then
          begin
            MarhTracert[Group].ObjStart := 0;
            exit;
          end;
      end;

      ObjZav[Ptr].bParam[2] := true;
    end;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.CheckAutoMarsh]'); result := false;
  end;
end;
//========================================================================================
function PovtorSvetofora(Svetofor : SmallInt; Marh : Byte; Group : Byte) : Boolean;
//----------------------------------------- —‰ÂÎ‡Ú¸ ÔÓ‚ÂÍË ÔÓ‚ÚÓÌÓ„Ó ÓÚÍ˚ÚËˇ Ò‚ÂÚÓÙÓ‡
var
  i : Integer;
  jmp : TOZNeighbour;
begin
  try
    ResetTrace;
    MarhTracert[Group].SvetBrdr := Svetofor;
    MarhTracert[Group].Finish := false;
    MarhTracert[Group].Rod := Marh;
    MarhTracert[Group].TailMsg := '';
    MarhTracert[Group].WarCount := 0;
    MarhTracert[Group].MsgCount := 0;
    MarhTracert[Group].ObjStart := Svetofor;
    //---------------------------------------------- œÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË ÔÓ ‚ÒÂÈ Ú‡ÒÒÂ
    i := 1000;
    jmp := ObjZav[Svetofor].Neighbour[2];
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    MarhTracert[Group].Level := tlSignalCirc;  //----------------- ÂÊËÏ ÒË„Ì‡Î¸Ì‡ˇ ÒÚÛÌ‡
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    MarhTracert[Group].FindTail := true;
    while i > 0 do
    begin
      case StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group) of
        trStop, trEnd :  break;
        trEndTrace :  break;
      end;
      dec(i);
    end;

    if i < 1 then
    begin //---------------------------------------------------- Ú‡ÒÒ‡ Ï‡¯ÛÚ‡ ‡ÁÛ¯ÂÌ‡
      InsArcNewMsg(Svetofor,228,1); //---------------------- “‡ÒÒ‡ Ï‡¯ÛÚ‡ ÓÚ $ Ì‡Û¯ÂÌ‡
      result := false;
      ShowShortMsg(228, LastX, LastY, ObjZav[Svetofor].Liter);
      Marhtracert[Group].LockPovtor := true;
      MarhTracert[Group].ObjStart := 0;
      exit;
    end;

    if MarhTracert[Group].MsgCount > 0 then
    begin  //------------------------------------------------------- ÓÚÍ‡Á ÔÓ ‚‡Ê‰Â·ÌÓÒÚË
    // «‡ÍÓÌ˜ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ Ë Ò·ÓÒËÚ¸ Ú‡ÒÒÛ ÂÒÎË ÂÒÚ¸ ‚‡Ê‰Â·ÌÓÒÚË
    InsArcNewMsg(MarhTracert[Group].MsgObject[1],MarhTracert[Group].MsgIndex[1],1);
    PutShortMsg(1,LastX,LastY,MarhTracert[Group].Msg[1]);
    result := false;
    Marhtracert[Group].LockPovtor := true;
    MarhTracert[Group].ObjStart := 0;
    exit;
  end;
  //-------- œÓ‚ÂËÚ¸ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ Ì‡ ÓÚÒÛÚÒÚ‚ËÂ ÔÓÂÁ‰‡ Ì‡ ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı
  if FindIzvStrelki(Svetofor, MarhTracert[Group].Rod) then
  begin
    inc(MarhTracert[Group].WarCount);
    MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
    GetShortMsg(1, 333, ObjZav[MarhTracert[Group].ObjStart].Liter,1);
    InsWar(Group,MarhTracert[Group].ObjStart,333);
  end;
{$IFNDEF RMARC}
  if MarhTracert[Group].WarCount > 0 then
  begin //---------------------------------------------------------------- ‚˚‚Ó‰ ÒÓÓ·˘ÂÌËÈ
    CreateDspMenu(CmdMarsh_Povtor,LastX,LastY);
    DspMenu.WC := true;
    result := false;
    MarhTracert[Group].ObjStart := 0;
    exit;
  end;
{$ENDIF}  
  result := true;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.PovtorSvetofora]'); result := false;
end;
end;
//========================================================================================
function PovtorOtkrytSvetofora(Svetofor : SmallInt; Marh : Byte; Group : Byte) : Boolean;
//ÔÓ‚ÂÍË ÔÓ‚ÚÓÌÓ„Ó ÓÚÍ˚ÚËˇ ÒË„Ì‡Î‡ (‚ ‡Á‰ÂÎ¸ÌÓÏ) ÔÓ ÔÂ‰‚‡ËÚÂÎ¸ÌÓÏÛ Á‡Ï˚Í‡ÌË˛ Ú‡ÒÒ˚
var
  i : Integer;
  jmp : TOZNeighbour;
begin
try
  ResetTrace;
  MarhTracert[Group].SvetBrdr := Svetofor;
  MarhTracert[Group].Finish := false;
  MarhTracert[Group].Rod := Marh;
  MarhTracert[Group].TailMsg := '';
  MarhTracert[Group].WarCount := 0;
  MarhTracert[Group].MsgCount := 0;
  MarhTracert[Group].ObjStart := Svetofor;
  //------------------------------------------------ œÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË ÔÓ ‚ÒÂÈ Ú‡ÒÒÂ
  i := 1000;
  jmp := ObjZav[Svetofor].Neighbour[2];

  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  MarhTracert[Group].Level := tlPovtorRazdel;  //----- ÂÊËÏ ÔÓ‚ÚÓ ÓÚÍ˚ÚËˇ ÔÓ Á‡ÏÍÌÛÚÓÏÛ
  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  MarhTracert[Group].FindTail := true;
  while i > 0 do
  begin
    case StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group) of

      trStop, trEnd :
        break;

      trEndTrace :
        break;
    end;
    dec(i);
  end;

  if i < 1 then
  begin // Ú‡ÒÒ‡ Ï‡¯ÛÚ‡ ‡ÁÛ¯ÂÌ‡
    InsArcNewMsg(Svetofor,228,1);
    result := false;
    ShowShortMsg(228, LastX, LastY, ObjZav[Svetofor].Liter);
    Marhtracert[Group].LockPovtor := true;
    MarhTracert[Group].ObjStart := 0;
    exit;
  end;

  if MarhTracert[Group].MsgCount > 0 then
  begin  //--------------------------------------------------------- ÓÚÍ‡Á ÔÓ ‚‡Ê‰Â·ÌÓÒÚË
    //--------------------- «‡ÍÓÌ˜ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ Ë Ò·ÓÒËÚ¸ Ú‡ÒÒÛ ÂÒÎË ÂÒÚ¸ ‚‡Ê‰Â·ÌÓÒÚË
    PutShortMsg(1,LastX,LastY,MarhTracert[Group].Msg[1]);
    result := false;
    Marhtracert[Group].LockPovtor := true;
    InsArcNewMsg(MarhTracert[Group].MsgObject[1],MarhTracert[Group].MsgIndex[1],1);
    MarhTracert[Group].ObjStart := 0;
    exit;
  end;

  //-------- œÓ‚ÂËÚ¸ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ Ì‡ ÓÚÒÛÚÒÚ‚ËÂ ÔÓÂÁ‰‡ Ì‡ ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı
  if FindIzvStrelki(Svetofor, MarhTracert[Group].Rod) then
  begin
    inc(MarhTracert[Group].WarCount);
    MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
    GetShortMsg(1, 333, ObjZav[MarhTracert[Group].ObjStart].Liter,1);
    InsWar(Group,MarhTracert[Group].ObjStart,333);
  end;
  
{$IFNDEF RMARC}
  if MarhTracert[Group].WarCount > 0 then
  begin //---------------------------------------------------------------- ‚˚‚Ó‰ ÒÓÓ·˘ÂÌËÈ
    CreateDspMenu(CmdMarsh_PovtorOtkryt,LastX,LastY);
    DspMenu.WC := true;
    result := false;
    MarhTracert[Group].ObjStart := 0;
    exit;
  end;
{$ENDIF}
  result := true;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.PovtorOtkrytSvetofora]');
  result := false;
end;
end;
//========================================================================================
function PovtorMarsh(Svetofor : SmallInt; Marh : Byte; Group : Byte) : Boolean;
//-------------------------------------------------- ¬˚ÔÓÎÌËÚ¸ ÔÓ‚ÚÓÌÛ˛ ÛÒÚ‡ÌÓÍÛ Ï‡¯ÛÚ‡
var
  i,j : Integer;
  jmp : TOZNeighbour;
begin
  try
    ResetTrace;
    MarhTracert[Group].SvetBrdr := Svetofor;
    MarhTracert[Group].Finish := false;
    MarhTracert[Group].Rod := Marh;
    MarhTracert[Group].TailMsg := '';
    MarhTracert[Group].WarCount := 0; MarhTracert[Group].MsgCount := 0;
    MarhTracert[Group].ObjStart := Svetofor;
    //---------------------------------------------- œÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË ÔÓ ‚ÒÂÈ Ú‡ÒÒÂ
    i := 1000;
    jmp := ObjZav[Svetofor].Neighbour[2];

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    MarhTracert[Group].Level := tlPovtorMarh; //------- ÂÊËÏ ÔÓ‚ÚÓÌ‡ˇ ÛÒÚ‡ÌÓ‚Í‡ Ï‡¯ÛÚ‡
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    MarhTracert[Group].FindTail := true;

    while i > 0 do
    begin
      case StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group) of
        trStop, trEnd : break;
        trEndTrace : break;
      end;
      dec(i);
    end;

    if i < 1 then
    begin //---------------------------------------------------- Ú‡ÒÒ‡ Ï‡¯ÛÚ‡ ‡ÁÛ¯ÂÌ‡
      InsArcNewMsg(Svetofor,228,1); //-------------------- "“‡ÒÒ‡ Ï‡¯ÛÚ‡ ÓÚ $ Ì‡Û¯ÂÌ‡"
      result := false;
      ShowShortMsg(228, LastX, LastY, ObjZav[Svetofor].Liter);
      Marhtracert[Group].LockPovtor := true;
      MarhTracert[Group].ObjStart := 0;
      exit;
    end;

    if MarhTracert[Group].MsgCount > 0 then
    begin  //------------------------------------------------------- ÓÚÍ‡Á ÔÓ ‚‡Ê‰Â·ÌÓÒÚË
      //------------------- «‡ÍÓÌ˜ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ Ë Ò·ÓÒËÚ¸ Ú‡ÒÒÛ ÂÒÎË ÂÒÚ¸ ‚‡Ê‰Â·ÌÓÒÚË
      InsArcNewMsg(MarhTracert[Group].MsgObject[1],MarhTracert[Group].MsgIndex[1],1);
      PutShortMsg(1,LastX,LastY,MarhTracert[Group].Msg[1]);
      result := false;
      Marhtracert[Group].LockPovtor := true;
      MarhTracert[Group].ObjStart := 0;
      exit;
    end;

    //---------------------------------------------- œÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË ÔÓ ‚ÒÂÈ Ú‡ÒÒÂ
    i := 1000;
    MarhTracert[Group].SvetBrdr := Svetofor;
    MarhTracert[Group].Povtor := true;
    MarhTracert[Group].MsgCount := 0;
    //----------- "ı‚ÓÒÚÓÏ" Ì‡‚ˇÁ˚‚‡ÂÚÒˇ Ó·˙ÂÍÚ, ‡ÒÔÓÎÓÊÂÌÌ˚È ÒÎÂ‰ÓÏ Á‡ ÒË„Ì‡ÎÓÏ Ï‡¯ÛÚ‡
    MarhTracert[Group].HTail := MarhTracert[Group].ObjTrace[1];
    jmp := ObjZav[MarhTracert[Group].ObjStart].Neighbour[2];

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    MarhTracert[Group].Level := tlCheckTrace;//---- ÂÊËÏ ÔÓ‚ÂÍ‡ ‚‡Ê‰Â·ÌÓÒÚÂÈ ÔÓ Ú‡ÒÒÂ 
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    if MarhTracert[Group].ObjEnd < 1 then
    begin
        j := MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter];
        MarhTracert[Group].ObjEnd := j;
    end
    else  j := MarhTracert[Group].ObjEnd;

    while MarhTracert[Group].ObjEnd < 1 do
    begin
      j := MarhTracert[Group].ObjTrace[j];
      MarhTracert[Group].ObjEnd := j;
      dec(j);
    end;


    MarhTracert[Group].CIndex := 1;
    while i > 0 do
    begin
      if jmp.Obj = j then
      begin // Œ·Ì‡ÛÊÂÌ Ó·˙ÂÍÚ ÍÓÌˆ‡ Ú‡ÒÒ˚
        // ¬‡Ê‰Â·ÌÓÒÚË ‚ ı‚ÓÒÚÂ
      StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group);
      break;
    end;

    case StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group) of
      trStop : begin
        break;
      end;
    end;
    dec(i);
    inc(MarhTracert[Group].CIndex);
  end;

  if i < 1 then
  begin // ÓÚÍ‡Á ÔÓ ÔÂ‚˚¯ÂÌË˛ Ò˜ÂÚ˜ËÍ‡
    InsArcNewMsg(Svetofor,231,1);
    RestorePrevTrace; result := false;
    ShowShortMsg(231, LastX, LastY, '');
    Marhtracert[Group].LockPovtor := true;
    MarhTracert[Group].ObjStart := 0;
    exit;
  end;

  if MarhTracert[Group].MsgCount > 0 then
  begin  //--------------------------------------------------------- ÓÚÍ‡Á ÔÓ ‚‡Ê‰Â·ÌÓÒÚË
    //--------------------- «‡ÍÓÌ˜ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ Ë Ò·ÓÒËÚ¸ Ú‡ÒÒÛ ÂÒÎË ÂÒÚ¸ ‚‡Ê‰Â·ÌÓÒÚË
    InsArcNewMsg(MarhTracert[Group].MsgObject[1],MarhTracert[Group].MsgIndex[1],1);
    PutShortMsg(1,LastX,LastY,MarhTracert[Group].Msg[Group]);
    result := false;
    Marhtracert[Group].LockPovtor := true;
    MarhTracert[Group].ObjStart := 0;
    exit;
  end;

  //-------- œÓ‚ÂËÚ¸ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ Ì‡ ÓÚÒÛÚÒÚ‚ËÂ ÔÓÂÁ‰‡ Ì‡ ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı
  if FindIzvStrelki(Svetofor, MarhTracert[Group].Rod) then
  begin
    inc(MarhTracert[Group].WarCount);
    MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
    GetShortMsg(1, 333, ObjZav[MarhTracert[Group].ObjStart].Liter,1);
    InsWar(Group,MarhTracert[Group].ObjStart,333);
  end;
{$IFNDEF RMARC}
  if MarhTracert[Group].WarCount > 0 then
  begin //---------------------------------------------------------------- ‚˚‚Ó‰ ÒÓÓ·˘ÂÌËÈ
    CreateDspMenu(CmdMarsh_PovtorMarh,LastX,LastY);
    DspMenu.WC := true;
    result := false;
    exit;
  end;
{$ENDIF}
  result := true;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.PovtorMarsh]'); result := false;
end;
end;
//========================================================================================
function FindIzvStrelki(Svetofor : SmallInt; Marh : Byte) : Boolean;
// œÓ‚ÂËÚ¸ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ Ì‡ ÓÚÒÛÚÒÚ‚ËÂ ÔÓÂÁ‰‡ Ì‡ ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı (‰Îˇ ƒ—œ)
//--------------------------------- Svetofor - ËÌ‰ÂÍÒ ÔÓ‚ÂˇÂÏÓ„Ó ÒË„Ì‡Î‡ Ì‡˜‡Î‡ Ï‡¯ÛÚ‡
//------------------------------------------ Marh - ÚËÔ Ï‡¯ÛÚ‡ (ÔÓÂÁ‰ÌÓÈ ËÎË Ï‡ÌÂ‚Ó‚˚È)
//---------------------- ‚ÓÁ‚‡˘‡ÂÚ  ÔËÁÌ‡Í ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÓÍ &  ÔËÁÌ‡Í Á‡ÌˇÚ˚ı ÒÂÍˆËÈ
var
  i : integer;
  jmp : TOZNeighbour;
begin
  try
    result := false;
    if Svetofor < 1 then exit;
    i := 1000; //--------------------------------------- ÛÒÚ‡ÌÓ‚ËÚ¸ ÔÂ‰ÂÎ¸ÌÓÂ ˜ËÒÎÓ ¯‡„Ó‚
    MarhTracert[1].IzvStrNZ := false;//- Ò·ÓÒ Ì‡ÎË˜Ëˇ ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÓÍ ÔÂÂ‰ Ï‡¯ÛÚÓÏ
    MarhTracert[1].IzvStrFUZ := false; // Ò·ÓÒ ÔËÁÌ‡Í‡ Á‡ÌˇÚÓÒÚË Û˜‡ÒÚÍ‡ ÔÂ‚˚Ï ÒÓÒÚ‡‚ÓÏ
    MarhTracert[1].IzvStrUZ := false;//Ò·ÓÒ ÔËÁÌ‡Í‡ Ì‡ÎË˜Ëˇ Á‡ÌˇÚ˚ı ÒÂÍˆËÈ Ì‡ ÔÂ‰Ï‡¯.

    MarhTracert[1].ObjStart := Svetofor; //----- Ì‡˜ËÌ‡ÂÏ ÒÏÓÚÂÚ¸ ÓÚ ÓÚÍ˚‚‡ÂÏÓ„Ó ÒË„Ì‡Î‡

    jmp := ObjZav[Svetofor].Neighbour[1]; //------------------------- ÒÓÒÂ‰ ÔÂÂ‰ ÒË„Ì‡ÎÓÏ

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    MarhTracert[1].Level := tlFindIzvStrel;//-- ÂÊËÏ "ÔÓ‚ÂÍ‡ ÌÂÁ‡ÏÍ. ÔÂ‰Ï‡¯. ÒÚÂÎÓÍ"
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    while i > 0 do //--------------------------------------------- ‚˚ÔÓÎÌËÚ¸ ˆËÍÎ ÔÓ‚ÂÍË
    begin
      //------------------------------------------------ ÔÂÂÍÎ˛˜‡ÚÂÎ¸ ÔÓ ÂÁÛÎ¸Ú‡Ú‡Ï ¯‡„‡
      case StepTrace(jmp, MarhTracert[1].Level, MarhTracert[1].Rod, 1) of
        trStop, //----- ÂÁÛÎ¸Ú‡Ú ¯‡„‡ = ÍÓÌÂˆ Ú‡ÒÒËÓ‚ÍË ËÁ-Á‡ Ó·Ì‡ÛÊÂÌËˇ ‚‡Ê‰Â·ÌÓÒÚÂÈ
        trEnd,  //-------------------------------------- ËÎË - ÍÓÌÂˆ Ú‡ÒÒËÓ‚ÍË Ù‡„ÏÂÌÚ‡
        trBreak : //-------------------------- ËÎË - ÔËÓÒÚ‡ÌÓ‚ËÚ¸ ÔÓ‰‚ËÊÂÌËÂ ÔÓ Ó·˙ÂÍÚ‡Ï
        begin
          //------------ ÂÁÛÎ¸Ú‡Ú = ÔËÁÌ‡Í ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÓÍ Ë  ÔËÁÌ‡Í Á‡ÌˇÚ˚ı ÒÂÍˆËÈ
          result := MarhTracert[1].IzvStrNZ and MarhTracert[1].IzvStrUZ;
          if result then //----------------------------------------- ÂÒÎË ÂÒÚ¸ ÚÓ Ë ‰Û„ÓÂ
          begin //-------------------------------------------------- ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
            SingleBeep := true;
{$IFNDEF TABLO}
            TimeLockCmdDsp := LastTime;
{$ENDIF}
            LockCommandDsp := true;
            ShowWarning := true;
          end;
          break;
        end;
      end;
      dec(i);
    end;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.FindIzvStrelki]'); result := false;
  end;
end;
//========================================================================================
function GetSoglOtmeny(Uslovie : SmallInt) : string;
//------------------------------------------ ÔÓÎÛ˜ÂÌËÂ ÔËÁÌ‡Í‡ ‡ÁÂ¯ÂÌËˇ ÓÚÏÂÌ˚ Ï‡¯ÛÚ‡
begin
  try
    result := '';
    if Uslovie > 0 then
    begin //-------------------------------------- ÔÓ‚ÂËÚ¸ ‡ÁÂ¯ÂÌËÂ Ì‡ ÓÚÏÂÌÛ Ï‡¯ÛÚ‡
      case ObjZav[Uslovie].TypeObj of //---------------------------- ÂÒÎË ÛÒÎÓ‚ËÂ ÚËÔ‡ ...
        30 :
        begin //------------------------------------------- ‰‡˜‡ ÒÓ„Î‡ÒËˇ ÔÓÂÁ‰ÌÓ„Ó ÔËÂÏ‡
          if ObjZav[Uslovie].bParam[2] then  //--- ÂÒÎË "»"
          //------------------------------------- Á‡ÏÍÌÛÚ Ï‡¯ÛÚ ‰Ó (Ò‚ÂÚÓÙÓ‡ Û‚ˇÁÍË)...
          result := GetShortMsg(1,254,ObjZav[ObjZav[Uslovie].BaseObject].Liter,1);
        end;

      33 :
      begin //---------------------------------------------------------- ‰ËÒÍÂÚÌ˚È ‰‡Ú˜ËÍ
        if ObjZav[Uslovie].ObjConstB[1] then  //-------------------- ÂÒÎË ‰‡Ú˜ËÍ ËÌ‚ÂÒÌ˚È
        begin
          if ObjZav[Uslovie].bParam[1] then   //------------------- ÂÒÎË ‰‡Ú˜ËÍ ÛÒÚ‡ÌÓ‚ÎÂÌ
          result := MsgList[ObjZav[Uslovie].ObjConstI[3]]; //------ ÒÓÓ·˘ËÚ¸ Ó· ÓÚÍÎ˛˜ÂÌËË
        end else
        begin
          if ObjZav[Uslovie].bParam[1] then
          result := MsgList[ObjZav[Uslovie].ObjConstI[2]]; //-------- ÒÓÓ·˘ËÚ¸ Ó ‚ÍÎ˛˜ÂÌËË
        end;
      end;

      38 :
      begin //------------------------------------------------------------ Ï‡¯ÛÚ Ì‡‰‚Ë„‡
        if ObjZav[Uslovie].bParam[1] then    //-------------------------------- ÂÒÎË ¬ ???
        //----------------------------------------------- ÛÒÚ‡ÌÓ‚ÎÂÌ Ï‡¯ÛÚ Ì‡‰‚Ë„‡ Ò ...
        result := GetShortMsg(1,346,ObjZav[ObjZav[Uslovie].BaseObject].Liter,1);
      end;
    end;
  end;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.GetSoglOtmeny]'); result := '';
  end;
end;
//========================================================================================
function GetIzvestitel(Svetofor : SmallInt; Marh : Byte) : Byte;
//------------------------ œÓÎÛ˜ËÚ¸ ÒÓÒÚÓˇÌËÂ ËÁ‚ÂÒÚËÚÂÎˇ ÔË ÓÚÏÂÌÂ Ï‡¯ÛÚ‡ (“ÓÎ¸ÍÓ ƒ—œ)
//-------------------------------------  Svetofor - ËÌ‰ÂÍÒ Ò‚ÂÚÓÙÓ‡t; Marh - ÚËÔ Ï‡¯ÛÚ‡

var
  i : integer;
  jmp : TOZNeighbour;
begin
  try
    result := 0;
    if Svetofor < 1 then exit; //------------------------------ ÌÂ ÛÍ‡Á‡Ì Ò‚ÂÚÓÙÓ - ‚˚ÈÚË
    MarhTracert[1].Rod := Marh;
    case Marh of
      MarshP :  //------------------------------------------------------- ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ
      begin
        //------------------------------------------ ÔÓ‚ÂËÚ¸ ÒıÂÏÛ ÔÓÂÁ‰ÌÓ„Ó ËÁ‚ÂÒÚËÚÂÎˇ
        if ObjZav[Svetofor].ObjConstI[27] > 0 then //------ ÂÒÎË ÂÒÚ¸ ÔÓÂÁ‰ÌÓÈ ËÁ‚ÂÒÚËÚÂÎ¸
        begin
          if ObjZav[ObjZav[Svetofor].ObjConstI[27]].bParam[1] then//ÂÒÎË ËÁ‚ÂÒÚËÚÂÎ¸ Á‡ÌˇÚ
          begin result := 1; exit; end;//--------- œÓÂÁ‰ Ì‡ ÔÂ‰Ï‡¯ÛÚÌÓÏ Û˜‡ÒÚÍÂ - ‚˚ÈÚË
        end;
        //---------------------------------------------- ÔÓÈÚË ÔÓ ÔÂ‰Ï‡¯ÛÚÌÓÏÛ Û˜‡ÒÚÍÛ
        if ObjZav[Svetofor].ObjConstB[19] //---- ÂÒÎË ÔÂ‰Ï‡¯ÛÚÌ˚È ÍÓÓÚÍËÈ ‰Îˇ ÔÓÂÁ‰Ì˚ı
        then MarhTracert[1].IzvCount := 0   //----------------------- ÚÓ ·ÎÓÍ-Û˜‡ÒÚÍÓ‚ ÌÂÚ
        else MarhTracert[1].IzvCount := 1; //------ ÂÒÎË ÌÂ ÍÓÓÚÍËÈ, ÚÓ ·ÎÓÍ-Û˜‡ÒÚÓÍ Ó‰ËÌ
      end;

      MarshM : //------------------------------------------------------ Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
      begin
        if ObjZav[Svetofor].ObjConstB[20]  //- ÂÒÎË ÔÂ‰Ï‡¯ÛÚÌ˚È ÍÓÓÚÍËÈ ‰Îˇ Ï‡ÌÂ‚Ó‚˚ı
        then MarhTracert[1].IzvCount := 0 //------------------------- ÚÓ ·ÎÓÍ-Û˜‡ÒÚÍÓ‚ ÌÂÚ
        else MarhTracert[1].IzvCount := 1; //------ ÂÒÎË ÌÂ ÍÓÓÚÍËÈ, ÚÓ ·ÎÓÍ-Û˜‡ÒÚÓÍ Ó‰ËÌ
      end;

      else MarhTracert[1].IzvCount := 1; //---- ‰Îˇ ÔÓ˜Ëı Ï‡¯ÛÚÓ‚ ·ÎÓÍ-Û˜‡ÒÚÓÍ Ó‰ËÌ ???
    end;

    if not ObjZav[Svetofor].bParam[2] and  //------------ ÂÒÎË ÌÂÚ Ã—2 Ë ÌÂÚ —2 , ÚÓ ‚˚ÈÚË
    not ObjZav[Svetofor].bParam[4]
    then exit; //----------------------------------------------------------- ÒË„Ì‡Î Á‡Í˚Ú

    i := 1000;
    jmp := ObjZav[Svetofor].Neighbour[1]; //--------------------- Ì‡˜‡Î¸Ì‡ˇ ÚÓ˜Í‡ Ï‡¯ÛÚ‡

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    MarhTracert[1].Level := tlFindIzvest;//- ÂÊËÏ Ò·Ó ËÁ‚ÂÒÚËÚÂÎˇ ÔÂÂ‰ ÓÚÏÂÌÓÈ Ï‡¯ÛÚ‡
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    while i > 0 do
    begin
      case StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1) of
      trStop, trEnd : break;

      trBreak :
      begin
        //------------------------------------- ÔÓ‚ÂËÚ¸ ÏÂÒÚÓÌ‡ıÓÊ‰ÂÌËÂ Á‡ÌˇÚÓ„Ó Û˜‡ÒÚÍ‡
        if MarhTracert[1].IzvCount < 2 then
        begin //--------------------------------------------------- ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ
          if ObjZav[jmp.Obj].TypeObj = 26 then result := 3
          else

          if ObjZav[jmp.Obj].TypeObj = 15 then result := 3
          else result := 1;
        end
        else  result := 2; //------------------------------------------- ÔÓÂÁ‰ Ì‡ Ï‡¯ÛÚÂ
        SingleBeep := true;
{$IFNDEF TABLO}
        TimeLockCmdDsp := LastTime;
{$ENDIF}
        LockCommandDsp := true;
        ShowWarning := true;
        break;
      end;
    end;
    dec(i);
  end;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.GetIzvestitel]'); result := 0;
  end;
end;
{$IFDEF RMDSP}
//========================================================================================
function OtmenaMarshruta(Svetofor : SmallInt; Marh : Byte) : Boolean;
var
  index,i : integer;
  jmp : TOZNeighbour;
//----------------------------------- ¬˚‰‡Ú¸ ÍÓÏ‡Ì‰Û ÓÚÏÂÌ˚ Ï‡¯ÛÚ‡ ‚ ÒÂ‚Â (“ÓÎ¸ÍÓ ƒ—œ)
begin
  result := false;
  try
    //--------------------------- Ï‡¯ÛÚ Á‡ÏÍÌÛÚ ËÒÔÓÎÌËÚÂÎ¸Ì˚ÏË ÛÒÚÓÈÒÚ‚‡ÏË ËÎË ÒÂ‚ÂÓÏ}
    index := Svetofor;
    MarhTracert[1].TailMsg := '';
    MarhTracert[1].ObjStart := Svetofor;
    MarhTracert[1].Rod := Marh;
    MarhTracert[1].Finish := false;
    if ObjZav[ObjZav[MarhTracert[1].ObjStart].BaseObject].bParam[2] then
    begin
      //--------------------------------------------- ÒÌˇÚ¸ ·ÎÓÍËÓ‚ÍË „ÓÎÓ‚ÌÓ„Ó Ò‚ÂÚÓÙÓ‡
      ObjZav[MarhTracert[1].ObjStart].bParam[14] := false;
      ObjZav[MarhTracert[1].ObjStart].bParam[7] := false;
      ObjZav[MarhTracert[1].ObjStart].bParam[9] := false;
    end;
    i := 1000;
    jmp := ObjZav[MarhTracert[1].ObjStart].Neighbour[2]; // Ì‡˜‡Î¸Ì‡ˇ ÚÓ˜Í‡

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    MarhTracert[1].Level := tlOtmenaMarh;
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    //------------------------------------------------ ÒÌˇÚ¸ ·ÎÓÍËÓ‚ÍË ˝ÎÂÏÂÌÚÓ‚ Ï‡¯ÛÚ‡
    while i > 0 do
    begin
      case StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1) of
        trStop, trEnd : break;
      end;
      dec(i);
    end;

    //----------------------------------------------------- ¬˚‰‡Ú¸ ÍÓÏ‡Ì‰Û ÓÚÏÂÌ˚ Ï‡¯ÛÚ‡
    case Marh of
      MarshM :
      begin
        if SendCommandToSrv(ObjZav[index].ObjConstI[3] div 8, cmdfr3_svzakrmanevr, index)
        then
        begin
          InsArcNewMsg(Index,24,7);
          ShowShortMsg(24, LastX, LastY, ObjZav[index].Liter);
          result := true;
        end;
      end;

      MarshP :
      begin
        if SendCommandToSrv(ObjZav[index].ObjConstI[5] div 8, cmdfr3_svzakrpoezd, index)
        then
        begin
          InsArcNewMsg(Index,25,7);
          ShowShortMsg(25, LastX, LastY, ObjZav[index].Liter);
          result := true;
        end;
      end;
    end;
    MarhTracert[1].ObjStart := 0;
  except
   reportf('Œ¯Ë·Í‡ [Marshrut.OtmenaMarshruta]');
   result := false;
  end;   
end;
{$ENDIF}
//========================================================================================
function SetProgramZamykanie(Group : Byte; Auto : Boolean) : Boolean;
//--------------------------------------------------------------- «‡ÏÍÌÛÚ¸ Ú‡ÒÒÛ Ï‡¯ÛÚ‡
var
  jmp : TOZNeighbour;
  i,j,k,obj_tras,Sig_End : integer;
begin
  try
    k := 0;
    //-------------------------------- ”ÒÚ‡ÌÓ‚ËÚ¸ ÔÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ ˝ÎÂÏÂÌÚÓ‚ Ï‡¯ÛÚ‡
    MarhTracert[Group].SvetBrdr := MarhTracert[Group].ObjStart;//Á‡ÔÓÏÌËÚ¸ Ò‚ÂÚÓÙÓ Ì‡˜‡Î‡
    MarhTracert[Group].Finish := false;    //------------- ÍÓÌÂˆ Ì‡·Ó‡ ÔÓÍ‡ Ì‡Ê‡Ú¸ ÌÂÎ¸Áˇ
    MarhTracert[Group].TailMsg := '';      //------ ÒÓÓ·˘ÂÌËˇ Ó "ı‚ÓÒÚÂ" Ï‡¯ÛÚ‡ ÔÓÍ‡ ÌÂÚ
    ObjZav[MarhTracert[Group].ObjStart].bParam[14] := true; //- ÔÓ„‡ÏÏÌÓ Á‡ÏÍÌÛÚ¸ ÒË„Ì‡Î

    ObjZav[MarhTracert[Group].ObjStart].iParam[1] :=
    MarhTracert[Group].ObjStart; //----------------------------- Á‡ÔÓÏÌËÚ¸ Ì‡˜‡ÎÓ Ï‡¯ÛÚ‡

    i := MarhTracert[Group].Counter; //---------------- Á‡ÔÓÏÌËÚ¸ ˜ËÒÎÓ ˝ÎÂÏÂÌÚÓ‚ Ï‡¯ÛÚ‡

    jmp := ObjZav[MarhTracert[Group].ObjStart].Neighbour[2]; //----------- ÒÓÒÂ‰ ‚ ÚÓ˜ÍÂ 2

    //##############   Œ Ã œ ‹ ﬁ “ ≈ – Õ Œ ≈  « ¿ Ã €   ¿ Õ » ≈ ##########################
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    MarhTracert[Group].Level := tlZamykTrace; // ˝Ú‡Ô Ú‡ÒÒËÓ‚ÍË = ÍÓÏÔ¸˛ÚÂÌÓÂ Á‡Ï˚Í‡ÌËÂ
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    MarhTracert[Group].FindTail := true; //--------------- ÔËÁÌ‡Í Ì‡·Ó‡ ‰Îˇ ÍÓÌˆ‡ Ú‡ÒÒ˚
    j := MarhTracert[Group].ObjEnd;

    if ObjZav[j].TypeObj <> 5 then
    begin
      k := 1;
      obj_tras := MarhTracert[Group].ObjTrace[i];
      while ((ObjZav[obj_tras].TypeObj <> 5) and (k <> i)) do
      begin
        obj_tras := MarhTracert[Group].ObjTrace[i-k];
        inc(k);
      end;
    end
    else obj_tras := j;

    if (k > 0) and (i <> k) then MarhTracert[Group].ObjEnd := obj_tras;
    Sig_End := obj_tras;
    if ObjZav[Sig_End].TypeObj = 5 then
    begin
      if ((MarhTracert[Group].Rod = MarshP) and not ObjZav[Sig_End].ObjConstB[5])
      or((MarhTracert[Group].Rod = MarshM) and
      not(ObjZav[Sig_End].ObjConstB[7] or ObjZav[Sig_End].ObjConstB[8])) then
      begin
        obj_tras := MarhTracert[Group].ObjStart;
        ObjZav[obj_tras].bParam[9] := false;
        ObjZav[obj_tras].bParam[7] := false;
        ObjZav[obj_tras].bParam[14] := false;
        ResetTrace;
        InsArcNewMsg(obj_tras,77,1);
        ShowShortMsg(77, LastX, LastY, ObjZav[obj_tras].Liter);
        result := false;
        exit;
      end;
    end;
    

    MarhTracert[Group].CIndex := 1; //----------------- ÔÓ‚ÂˇÂÏ˚È Ó·˙ÂÍÚ ÔÂ‚˚È ‚ Ú‡ÒÒÂ
    if j < 1 then j := MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter];
    while i > 0 do
    begin
      if jmp.Obj = j then //-------------------------------- Œ·Ì‡ÛÊÂÌ Ó·˙ÂÍÚ ÍÓÌˆ‡ Ú‡ÒÒ˚
      begin
        case ObjZav[jmp.Obj].TypeObj of
          //-------------------------- ÒÚÂÎÍ‡ ‚ ÍÓÌˆÂ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡ ÌÂÓ·ıÓ‰ËÏÓ Á‡ÏÍÌÛÚ¸
          2 : StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group);

          5 : //-------------------------------------------------- Ò‚ÂÚÓÙÓ ‚ ÍÓÌˆÂ Ú‡ÒÒ˚
          begin
            //ÔÓÔ‡ÎË ‚ Ú˜Í 2,ÁÌ‡˜ËÚ ‚ÒÚÂ˜Ì˚È ‚ ÍÓÌˆÂ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡, ÌÂÓ·ıÓ‰ËÏÓ Á‡ÏÍÌÛÚ¸
            if jmp.Pin = 2 then
            StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group)
            else //------------------------ ÂÒÎË ÌÂ ÚÓ˜Í‡ 2, ÚÓ ÔÓÔÛÚÌ˚È Ò‚ÂÚÓÙÓ ‚ ı‚ÓÒÚÂ
            if MarhTracert[Group].FindTail //-------------- ÂÒÎË ı‚ÓÒÚ Ï‡¯ÛÚ‡ Â˘∏ ÔÛÒÚÓÈ
            then MarhTracert[Group].TailMsg:=' ‰Ó '+ObjZav[jmp.Obj].Liter;//ı‚ÓÒÚ Ï‡¯ÛÚ‡
          end;

          //------------------------------- ¿¡ ‚ ÍÓÌˆÂ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡ ÌÂÓ·ıÓ‰ËÏÓ Á‡ÏÍÌÛÚ¸
          15 : StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group);

          30 : //------------------------------------------ Ó·˙ÂÍÚ ‰‡˜Ë ÔÓÂÁ‰ÌÓ„Ó ÒÓ„Î‡ÒËˇ
          begin
            if MarhTracert[Group].FindTail// ÂÒÎË ÌÛÊÌÓ ËÒÍ‡Ú¸ ı‚ÓÒÚ, ÚÓ ˝ÚÓ ÒË„Ì‡Î Û‚ˇÁÍË
            then MarhTracert[Group].TailMsg:=' ‰Ó '+ObjZav[ObjZav[jmp.Obj].BaseObject].Liter;
          end;

          //------------------------------------------------------- Ó·˙ÂÍÚ Û‚ˇÁÍË Ò „ÓÍÓÈ
          32 : MarhTracert[Group].TailMsg:=' ‰Ó '+ ObjZav[jmp.Obj].Liter;//Õ‡‰‚Ë„ Ì‡ „ÓÍÛ
        end;
        break; //---------------------------- ‚˚ıÓ‰ ËÁ ˆËÍÎ‡ ÔË ‰ÓÒÚËÊÂÌËË ÍÓÌˆ‡ Ï‡¯ÛÚ‡
      end;
      //----- ÂÒÎË ÍÓÌÂˆ Ú‡ÒÒ˚ Â˘Â ÌÂ ‰ÓÒÚË„ÌÛÚ ÚÓ ‰ÂÎ‡ÂÏ Ó˜ÂÂ‰ÌÓÈ ¯‡„ Ë ‡Ì‡ÎËÁËÛÂÏ Â„Ó
      case StepTrace(jmp,MarhTracert[Group].Level,MarhTracert[Group].Rod,Group) of
        trStop, trEnd : //ÂÒÎË ‚˚¯ÎË Ì‡ ‚‡Ê‰Â·ÌÓÒÚ¸ ËÎË ÍÓÌÂˆ Ù‡„ÏÂÌÚ‡, ÚÓ ÔÂ‚‡Ú¸ ˆËÍÎ
        begin i := -1; break; end;
      end;
      dec(i); //---------------------------- ÛÏÂÌ¸¯‡ÂÏ ˜ËÒÎÓ ÓÒÚ‡‚¯ËıÒˇ ˝ÎÂÏÂÌÚÓ‚ Ï‡¯ÛÚ‡
      inc(MarhTracert[Group].CIndex); //------------------- ÔÂÂıÓ‰ËÏ Ì‡ ÒÎÂ‰Û˛˘ËÈ ˝ÎÂÏÂÌÚ
    end;

    if (i < 1) and not Auto then
    begin // ÓÚÍ‡Á ÔÓ ‡ÁÛ¯ÂÌË˛ Ú‡ÒÒ˚
      ResetTrace;
      result := false;
      InsArcNewMsg(MarhTracert[Group].ObjStart,228,1);
      ShowShortMsg(228, LastX, LastY, ObjZav[MarhTracert[Group].ObjStart].Liter);
      exit;
    end;
    result := true;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.SetProgramZamykanie]');
    result := false;
  end;
end;
//========================================================================================
function SendMarshrutCommand(Group : Byte) : Boolean;
var
  i,j : integer;
  os,oe : SmallInt;
begin
  try
     MarhTracert[Group].Finish := false;
     //--------------------------------------------------- ÒÙÓÏËÓ‚‡Ú¸ Ï‡¯ÛÚÌÛ˛ ÍÓÏ‡Ì‰Û
     for i := 1 to 10 do MarhTracert[Group].MarhCmd[i] := 0;

     if ObjZav[MarhTracert[Group].ObjStart].TypeObj = 30 then
     os := ObjZav[ObjZav[MarhTracert[Group].ObjStart].BaseObject].ObjConstI[5] div 8
     else
     if ObjZav[MarhTracert[Group].ObjStart].ObjConstI[3] > 0 then
     os := ObjZav[MarhTracert[Group].ObjStart].ObjConstI[3] div 8
     else os := ObjZav[MarhTracert[Group].ObjStart].ObjConstI[5] div 8;

     if ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 30 then
     oe := ObjZav[ObjZav[MarhTracert[Group].ObjEnd].BaseObject].ObjConstI[5] div 8
     else
     if ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 24 then
     oe := ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[13] div 8
     else
     if ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 26 then
     oe := ObjZav[ObjZav[MarhTracert[Group].ObjEnd].BaseObject].ObjConstI[4] div 8
     else
     if ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 32 then
     oe := ObjZav[ObjZav[MarhTracert[Group].ObjEnd].BaseObject].ObjConstI[2] div 8
     else
     if ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[3] > 0 then
     oe := ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[3] div 8
     else
     if ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[5] > 0 then
     oe := ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[5] div 8
     else
     oe := ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[7] div 8;

     MarhTracert[Group].MarhCmd[1] := os;
     MarhTracert[Group].MarhCmd[2] := os div 256;
     MarhTracert[Group].MarhCmd[3] := oe;
     MarhTracert[Group].MarhCmd[4] := oe div 256;
     MarhTracert[Group].MarhCmd[5] := MarhTracert[Group].StrCount;

     case MarhTracert[Group].Rod of // ÛÒÚ‡ÌÓ‚ËÚ¸ Í‡ÚÂ„ÓË˛ Ï‡¯ÛÚ‡
      MarshM :
      begin
        if MarhTracert[Group].Povtor then
        MarhTracert[Group].MarhCmd[10] := cmdfr3_povtormarhmanevr
        else MarhTracert[Group].MarhCmd[10] := cmdfr3_marshrutmanevr;
        tm := 'Ï‡ÌÂ‚Ó‚Ó„Ó';
      end;

      MarshP :
      begin
        if MarhTracert[Group].Povtor then
        MarhTracert[Group].MarhCmd[10] := cmdfr3_povtormarhpoezd
        else MarhTracert[Group].MarhCmd[10] := cmdfr3_marshrutpoezd;
        tm := 'ÔÓÂÁ‰ÌÓ„Ó';
      end;

      MarshL :
      begin
        MarhTracert[Group].MarhCmd[10] := cmdfr3_marshrutlogic;
        tm := 'ÎÓ„Ë˜ÂÒÍÓ„Ó';
      end;
    end;

    if MarhTracert[Group].StrCount > 0 then
    begin
      for i := 1 to MarhTracert[Group].StrCount do
      begin
        if MarhTracert[Group].PolTrace[i,2] then
        begin
          case i of
            1 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 1;
            2 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 2;
            3 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 4;
            4 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 8;
            5 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 16;
            6 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 32;
            7 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 64;
            8 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 128;
            9 :  MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 1;
            10 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 2;
            11 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 4;
            12 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 8;
            13 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 16;
            14 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 32;
            15 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 64;
            16 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 128;
            17 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 1;
            18 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 2;
            19 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 4;
            20 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 8;
            21 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 16;
            22 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 32;
            23 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 64;
            24 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 128;
          end;
        end;
      end;
    end;

    CmdSendT := LastTime;
    WorkMode.MarhRdy := true;
    InsArcNewMsg(MarhTracert[Group].ObjStart,5,7);

    ShowShortMsg(5, LastX, LastY, tm + ' Ï‡¯ÛÚ‡ ÓÚ '+
    ObjZav[MarhTracert[Group].ObjStart].Liter+ MarhTracert[Group].TailMsg);

    LastMsgToDSP := ObjZav[MarhTracert[Group].ObjStart].Liter+ MarhTracert[Group].TailMsg;

    CmdBuff.LastObj := MarhTracert[Group].ObjStart;

    //-------------------------------------------------------- Ò·ÓÒ ÒÚÛÍÚÛ˚ Ú‡ÒÒËÓ‚ÍË

    MarhTracert[Group].ObjStart := 0;
    MarhTracert[Group].PutPriem := 0;
    for i := MarhTracert[Group].Counter downto 1 do
    begin
      j := MarhTracert[Group].ObjTrace[i];
      if (ObjZav[j].TypeObj = 4)then
      begin
        MarhTracert[Group].PutPriem := j;
        break;
      end;
    end;

    for i := 1 to High(MarhTracert[Group].ObjTrace) do MarhTracert[Group].ObjTrace[i] := 0;
    MarhTracert[Group].Counter := 0;
    for i := 1 to High(MarhTracert[Group].StrTrace) do
    begin
      MarhTracert[Group].StrTrace[i] := 0;
      MarhTracert[Group].PolTrace[i,1] := false;
      MarhTracert[Group].PolTrace[i,2] := false;
    end;
    MarhTracert[Group].StrCount := 0;
    MarhTracert[Group].ObjEnd := 0;
    MarhTracert[Group].ObjLast := 0;
    MarhTracert[Group].PinLast := 0;
    MarhTracert[Group].ObjPrev := 0;
    MarhTracert[Group].PinPrev := 0;
    MarhTracert[Group].Rod := 0;
    MarhTracert[Group].Povtor := false;
    WorkMode.GoTracert := false;
    WorkMode.CmdReady  := true; //-------- «‡ÔÂÚ Ï‡¯ÛÚÌ˚ı ÍÓÏ‡Ì‰ ‰Ó ÔÓÎÛ˜ÂÌËˇ Í‚ËÚ‡ÌˆËË
    result := true;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.SendMarshrutCommand]'); result := false;
  end;
end;
//========================================================================================
function SendTraceCommand(Group : Byte) : Boolean;
//--------------------------------------------- ¬˚‰‡Ú¸ ÍÓÏ‡Ì‰Û ÛÒÚ‡ÌÓ‚ÍË Ï‡¯ÛÚ‡ ‚ ÒÂ‚Â
var
  i,baza : integer;
  os,oe : SmallInt;
begin
  try
    if (MarhTracert[Group].GonkaList = 0) or //ÂÒÎË ‚ÒÂ ÒÚÂÎÍË Ú‡ÒÒ˚ ÛÒÚ‡ÌÓ‚ÎÂÌ˚ ËÎË ...
    not MarhTracert[Group].GonkaStrel then //------ ËÎË ÔÂÂ‚Ó‰ ÒÚÂÎÓÍ Ú‡ÒÒ˚ ÌÂ ‰ÓÔÛÒÚËÏ
    begin
      ResetTrace;
      result := false;
      exit;
    end;
    MarhTracert[Group].Finish     := false;  //–‡ÁÂ¯ÂÌËÂ Ì‡Ê‡Ú¸ ÍÌÓÔÍÛ ÍÓÌˆ‡ Ì‡·Ó‡ ÒÌˇÚ¸
    MarhTracert[Group].GonkaStrel := false;
    MarhTracert[Group].GonkaList  := 0;

    //--------------------------------------------------------------- ÒÙÓÏËÓ‚‡Ú¸ ÍÓÏ‡Ì‰Û
    for i := 1 to 10 do MarhTracert[Group].MarhCmd[i] := 0; //---- Ó˜ËÒÚËÚ¸ Ï‡ÒÒË‚ ÍÓÏ‡Ì‰˚

    baza := ObjZav[MarhTracert[Group].ObjStart].BaseObject; //--- ‚ÁˇÚ¸ ·‡ÁÓ‚˚È ‰Îˇ Ì‡˜‡Î‡

    if ObjZav[MarhTracert[Group].ObjStart].TypeObj = 30 then //ÂÒÎË Ì‡˜‡ÎÓ "‰‡˜‡ ÒÓ„Î‡ÒËˇ"
    os := ObjZav[baza].ObjConstI[5] div 8 //----- ËÌ‰ÂÍÒ ‰‡Ú˜ËÍ‡ —2 Ò‚ÂÚÓÙÓ‡ Û‚ˇÁÍË ‚ FR3
    else

    if ObjZav[MarhTracert[Group].ObjStart].ObjConstI[3] > 0 then  //-------- ÂÒÎË ÂÒÚ¸ Ã—2
    os := ObjZav[MarhTracert[Group].ObjStart].ObjConstI[3] div 8 //------ ËÌ‰ÂÍÒ Ã—2 ‚ FR3

    else
    os := ObjZav[MarhTracert[Group].ObjStart].ObjConstI[5] div 8; //------ ËÌ‰ÂÍÒ —2 ‚ FR3

    baza := ObjZav[MarhTracert[Group].ObjEnd].BaseObject;  //--------- ‚ÁˇÚ¸ ·‡ÁÓ‚˚È ÍÓÌˆ‡

    if ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 30 then // ÂÒÎË ÍÓÌÂˆ - "‰‡˜‡ ÒÓ„Î‡ÒËˇ"
    oe := ObjZav[baza].ObjConstI[5] div 8 //------- ËÌ‰ÂÍÒ ‰‡Ú˜ËÍ‡ C2 ÒË„Ì‡Î‡ Û‚ˇÁÍË ‚ FR3
    else

    if ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 24 then//ÂÒÎË ÍÓÌÂˆ - Û‚ˇÁÍ‡ Ò Á‡ÔÓÒÓÏ
    oe := ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[13] div 8//- Ã— ÒË„Ì‡Î‡ Ô‡Í‡ ÒÓÒÂ‰‡
    else

    if ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 26 then//---- ÂÒÎË ÍÓÌÂˆ - Û‚ˇÁÍ‡ Ò œ¿¡
    oe := ObjZav[baza].ObjConstI[4] div 8 //--- ËÌ‰ÂÍÒ ‰‡Ú˜ËÍ‡ C1 ‚ıÓ‰ÌÓ„Ó Ò‚ÂÚÓÙÓ‡ ‚ FR3
    else

    if ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 32 then // ÂÒÎË ÍÓÌÂˆ - Û‚ˇÁÍ‡ Ò „ÓÍÓÈ
    oe := ObjZav[baza].ObjConstI[2] div 8 // ËÌ‰ÂÍÒ ‰Îˇ ÃC1 Ï‡ÌÂ‚.Ò‚ÂÚÓÙÓ‡ Ò „ÓÍË ‚ FR3
    else

    if ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[3] > 0 then  //-- ÂÒÎË Û ÍÓÌˆ‡ ÂÒÚ¸ Ã—2
    oe := ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[3] div 8 //-------- ËÌ‰ÂÍÒ Ã—2 ‚ FR3
    else

    if ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[5] > 0 then //---- ÂÒÎË Û ÍÓÌˆ‡ ÂÒÚ¸ —2
    oe := ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[5] div 8  //-------- ËÌ‰ÂÍÒ —2 ‚ FR3
    else

    oe := ObjZav[MarhTracert[Group].ObjEnd].ObjConstI[7] div 8; //--- ËÌ‡˜Â ˜ÚÓ ˝ÚÓ ??????

    MarhTracert[Group].MarhCmd[1] := os;
    MarhTracert[Group].MarhCmd[2] := os div 256;
    MarhTracert[Group].MarhCmd[3] := oe;
    MarhTracert[Group].MarhCmd[4] := oe div 256;
    MarhTracert[Group].MarhCmd[5] := MarhTracert[Group].StrCount;
    MarhTracert[Group].MarhCmd[10] := cmdfr3_ustanovkastrelok;

    if MarhTracert[Group].StrCount > 0 then //ÂÒÎË ÂÒÚ¸ ÒÚÂÎÍË, ÚÓ ÛÔ‡ÍÓ‚‡Ú¸ Ëı ÔÓÎÓÊÂÌËÂ
    begin
      for i := 1 to MarhTracert[Group].StrCount do
      begin
        if MarhTracert[Group].PolTrace[i,2] then
        begin
          case i of
            1 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 1;
            2 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 2;
            3 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 4;
            4 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 8;
            5 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 16;
            6 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 32;
            7 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 64;
            8 :  MarhTracert[Group].MarhCmd[6] := MarhTracert[Group].MarhCmd[6] + 128;
            9 :  MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 1;
            10 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 2;
            11 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 4;
            12 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 8;
            13 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 16;
            14 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 32;
            15 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 64;
            16 : MarhTracert[Group].MarhCmd[7] := MarhTracert[Group].MarhCmd[7] + 128;
            17 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 1;
            18 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 2;
            19 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 4;
            20 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 8;
            21 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 16;
            22 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 32;
            23 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 64;
            24 : MarhTracert[Group].MarhCmd[8] := MarhTracert[Group].MarhCmd[8] + 128;
          end;
        end;
      end;
    end;

    CmdSendT := LastTime;

    WorkMode.MarhRdy := true;

    InsArcNewMsg(MarhTracert[Group].ObjStart,5,7);
    tm := GetShortMsg(1,5, ' ÒÚÂÎÓÍ ÔÓ Ú‡ÒÒÂ Ï‡¯ÛÚ‡ ÓÚ '+ //- ¬˚‰‡Ì‡ ÍÓÏ‡Ì‰‡ ÛÒÚ‡ÌÓ‚ÍË
    ObjZav[MarhTracert[Group].ObjStart].Liter + MarhTracert[Group].TailMsg,7);

    LastMsgToDSP := ObjZav[MarhTracert[Group].ObjStart].Liter+ MarhTracert[Group].TailMsg;

    CmdBuff.LastObj := MarhTracert[Group].ObjStart;

    //-------------------------------------------------------- Ò·ÓÒ ÒÚÛÍÚÛ˚ Ú‡ÒÒËÓ‚ÍË
    ResetTrace;
    PutShortMsg(2,LastX,LastY,tm); //----------------------------------- “‡ÒÒ‡ $ Ò·Ó¯ÂÌ‡
    WorkMode.CmdReady  := true; //-------- «‡ÔÂÚ Ï‡¯ÛÚÌ˚ı ÍÓÏ‡Ì‰ ‰Ó ÔÓÎÛ˜ÂÌËˇ Í‚ËÚ‡ÌˆËË
    result := true;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.SendTraceCommand]');
    result := false;
  end;
end;
//========================================================================================
function BeginTracertMarshrut(index, command : SmallInt) : Boolean;
var
  cvet : integer;
//----------------------------------------------- ËÌËˆËËÓ‚‡Ú¸ Ì‡˜‡ÎÓ Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡
begin
  try
    ResetTrace; //------------------------------------- Ò·ÓÒ Î˛·ÓÈ ‡ÌÂÂ Ì‡·‡ÌÌÓÈ Ú‡ÒÒ˚
    case command of
      CmdMenu_BeginMarshManevr :  //---------------------------- Ì‡˜‡Ú¸ Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
      begin
        MarhTracert[1].Rod := MarshM;
        ObjZav[index].bParam[7] := true; //------------------------- ÛÒÚ‡ÌÓ‚ËÚ¸ ÔËÁÌ‡Í ÕÃ
        cvet := 7;
      end;

      CmdMenu_BeginMarshPoezd :  //------------------------------- Ì‡˜‡Ú¸ ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ
      begin
        MarhTracert[1].Rod := MarshP;
        ObjZav[index].bParam[9] := true; //-------------------------- ÛÒÚ‡ÌÓ‚ËÚ¸ ÔËÁÌ‡Í Õ
        cvet := 2;
      end;

      else
        InsArcNewMsg(MarhTracert[1].ObjStart,32,1); //"Œ·Ì‡ÛÊÂÌ ÌÂËÁ‚ÂÒÚÌ˚È ÚËÔ Ï‡¯ÛÚ‡"
        result := false;
        ShowShortMsg(32,LastX,LastY,ObjZav[MarhTracert[1].ObjStart].Liter);
        exit;
    end;
    WorkMode.GoTracert := true; //-------------------------- Ó·˙ˇ‚ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ‡ÍÚË‚ÌÓÈ
    MarhTracert[1].AutoMarh := false; //---------------- Ò·ÓÒËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
    MarhTracert[1].MsgCount := 0; MarhTracert[1].WarCount := 0;
    MarhTracert[1].ObjStart := index; //---------- Ì‡˜ËÌ‡ÂÏ Ú‡ÒÒËÓ‚ÍÛ Ò ÔÂ‚Ó„Ó Ì‡Ê‡ÚÓ„Ó
    MarhTracert[1].ObjLast := index; //--------------- Ò˜ËÚ‡ÂÏ, ˜ÚÓ ˝ÚÓÚ Ó·˙ÂÍÚ Ë ÔÓÒÎÂ‰ËÈ
    MarhTracert[1].PinLast := 2; //--------------------------- Ì‡˜‡ÎÓ ÔÓËÒÍ‡ Á‡ Ò‚ÂÚÓÙÓÓÏ
    MarhTracert[1].ObjPrev := MarhTracert[1].ObjLast;
    MarhTracert[1].PinPrev := MarhTracert[1].PinLast;
    InsArcNewMsg(MarhTracert[1].ObjStart,78,cvet); //---------- ‚‚Â‰ËÚÂ Ú‡ÒÒÛ Ï‡¯ÛÚ‡ ÓÚ
    ShowShortMsg(78,LastX,LastY,ObjZav[MarhTracert[1].ObjStart].Liter);
    result := true;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.BeginTracertMarshrut]');
    result := false;
  end;
end;
//========================================================================================
function RestorePrevTrace : Boolean;
//----------------------------- ¬ÓÒÒÚ‡ÌÓ‚ËÚ¸ Ú‡ÒÒÛ ‰Ó ÔÓÒÎÂ‰ÌÂÈ ÒÛ˘ÂÒÚ‚Û˛˘ÂÈ ÍÓÌÙË„Û‡ˆËË
var
  i : integer;
begin
  try
    i := MarhTracert[1].Counter; //------------------------------- ˜ËÒÎÓ Ó·˙ÂÍÚÓ‚ ‚ Ú‡ÒÒÂ

    while i > 0 do
    begin
      if MarhTracert[1].ObjTrace[i] = MarhTracert[1].ObjPrev then break //- ÂÒÎË ‚ÂÌÛÎËÒ¸
      else //------------------------------ ÔÓÍ‡ ÌÂ Ì‡È‰ÂÌ‡ ÔÓÒÎÂ‰Ìˇˇ Û‰‡˜Ì‡ˇ ÚÓ˜Í‡ Ú‡ÒÒ˚
      begin
        if ObjZav[MarhTracert[1].ObjTrace[i]].TypeObj = 2 then //--- ÂÒÎË ‚˚¯ÎË Ì‡ ÒÚÂÎÍÛ
        begin //----------------------------------- Ò·ÓÒËÚ¸ Ô‡‡ÏÂÚ˚ Ú‡ÒÒËÓ‚ÍË ÒÚÂÎÍË
          ObjZav[MarhTracert[1].ObjTrace[i]].bParam[10] := false;
          ObjZav[MarhTracert[1].ObjTrace[i]].bParam[11] := false;
          ObjZav[MarhTracert[1].ObjTrace[i]].bParam[12] := false;
          ObjZav[MarhTracert[1].ObjTrace[i]].bParam[13] := false;
        end;
        MarhTracert[1].ObjTrace[i] := 0; //----------------------- Û·‡Ú¸ Ó·˙ÂÍÚ ËÁ Ú‡ÒÒ˚
      end;
      dec(i);
    end;

    MarhTracert[1].Counter := i; //---------------- ÚÂÔÂ¸ ‚ Ú‡ÒÒÂ ÏÂÌ¸¯ÂÂ ˜ËÒÎÓ Ó·˙ÂÍÚÓ‚
    MarhTracert[1].ObjLast := MarhTracert[1].ObjPrev; //---- ‚ÓÒÒÚ‡ÌÓ‚ËÏ ËÌ‰ÂÍÒ ÔÓÒÎÂ‰ÌÂ„Ó
    MarhTracert[1].PinLast := MarhTracert[1].PinPrev; //----- ‚ÓÒÒÚ‡ÌÓ‚ËÏ ÚÓ˜ÍÛ ÔÓÒÎÂ‰ÌÂ„Ó
    MarhTracert[1].MsgCount := 0;
    RestorePrevTrace := true;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.RestorePrevTrace]'); result := false;
  end;
end;
//========================================================================================
function EndTracertMarshrut : Boolean;
//------------------------------------------------------- ÙÛÌÍˆËˇ Á‡‚Â¯ÂÌËˇ Ì‡·Ó‡ Ú‡ÒÒ˚
begin
  try
    if Marhtracert[1].Counter < 1 then //------------------- ÂÒÎË ‚ Ï‡¯ÛÚÂ ÌÂÚ ˝ÎÂÏÂÌÚÓ‚
    begin result := false; exit; end
    else
    if MarhTracert[1].ObjEnd < 1 then //------------------ ÂÒÎË ÌÂÚ Ó·˙ÂÍÚ‡ ÍÓÌˆ‡ Ï‡¯ÛÚ‡
    begin //-------------------- ÔÂÂÍÎ˛˜‡ÚÂÎ¸ ÔÓ ÚËÔÛ ÔÓÒÎÂ‰ÌÂ„Ó ˝ÎÂÏÂÌÚ‡ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡
      case ObjZav[MarhTracert[1].ObjTrace[MarhTracert[1].Counter]].TypeObj of

        5,15,26,30 :// ÂÒÎË ˝ÚÓ ÒË„Ì‡Î,¿¡,œ¿¡ ËÎË "ÒÓ„Î‡ÒËÂ", ÚÓ ˝ÚÓ Ë ÂÒÚ¸ ÍÓÌÂˆ Ï‡¯ÛÚ‡
        MarhTracert[1].ObjEnd := MarhTracert[1].ObjTrace[MarhTracert[1].Counter];

        else  result := false; exit; //---------------------------- ËÌ‡˜Â ‚˚ıÓ‰ Ò ÌÂÛ‰‡˜ÂÈ
      end;
    end;

    //-------------------------------------------------------- ÂÒÎË ÒË„Ì‡Î ÔÓÔÛÚÌ˚È Ë ....
    if (ObjZav[MarhTracert[1].ObjLast].TypeObj = 5) and (MarhTracert[1].PinLast = 2) and
    //--- ÌÂ ÓÚÍ˚Ú˚ ÌË Ï‡ÌÂ‚Ó‚˚È 1-„Ó ËÎË 2-„Ó Í‡ÒÍ‡‰‡ ÌË ÔÓÂÁ‰ÌÓÈ 1-„Ó ËÎË 2-„Ó Í‡ÒÍ‡‰‡
    not (ObjZav[MarhTracert[1].ObjLast].bParam[1] or ObjZav[MarhTracert[1].ObjLast].bParam[2] or
    ObjZav[MarhTracert[1].ObjLast].bParam[3] or ObjZav[MarhTracert[1].ObjLast].bParam[4]) then
    begin
      if ObjZav[MarhTracert[1].ObjLast].bParam[5] then //---------- ÂÒÎË ÌÂ ÌÓÏ‡ Ó„ÌÂ‚Ó„Ó
      begin //----------------------------- Ã‡¯ÛÚ ÌÂ ÔËÍ˚Ú Á‡ÔÂ˘‡˛˘ËÏ Ó„ÌÂÏ ÔÓÔÛÚÌÓ„Ó
        inc(MarhTracert[1].WarCount);
        MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
        //---------------------------- "Ã‡¯ÛÚ ÌÂ Ó„‡Ê‰ÂÌ.ÕÂËÒÔ‡‚ÂÌ Á‡ÔÂ˘‡˛˘ËÈ Ó„ÓÌ¸."
        GetShortMsg(1,115, ObjZav[MarhTracert[1].ObjLast].Liter,1);
        InsWar(1,MarhTracert[1].ObjLast,115);
      end;

      //----------- œÓ‚ÂËÚ¸ ÓÚÍ˚ÚËÂ ‚ÔÂÂ‰Ë ÒÚÓˇ˘Â„Ó ÒË„Ì‡Î‡ ÂÒÎË ÍÓÓÚÍËÈ ·ÎÓÍ-Û˜‡ÒÚÓÍ
      case MarhTracert[1].Rod of
        MarshP :    //----------------------------------------------------- Ï‡¯ÛÚ ÔÓÂÁ‰ÌÓÈ
        begin
          //-------------------------- ÂÒÎË ÍÓÓÚÍËÈ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ ÔÓÂÁ‰ÌÓÈ Ë ...
          if ObjZav[MarhTracert[1].ObjLast].ObjConstB[19] and
          not ObjZav[MarhTracert[1].ObjLast].bParam[4] then //--- ÌÂÚ 2-„Ó Í‡ÒÍ‡‰‡ ÔÓÂÁ‰ÌÓ„Ó
          begin
            InsArcNewMsg(MarhTracert[1].ObjLast,391,1);//----------------- "ÒË„Ì‡Î Á‡Í˚Ú"
            ShowShortMsg(391,LastX,LastY, ObjZav[MarhTracert[1].ObjLast].Liter);
            result := false;
            exit;
          end;
        end;

        MarshM :  //---------------------------------------------------- Ï‡¯ÛÚ Ï‡ÌÂ‚Ó‚˚È
        begin
          //------------------------ ÂÒÎË ÍÓÓÚÍËÈ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ Ï‡ÌÂ‚Ó‚˚È Ë ...
          if ObjZav[MarhTracert[1].ObjLast].ObjConstB[20] and
          not ObjZav[MarhTracert[1].ObjLast].bParam[2] then //- ÌÂÚ 2-„Ó Í‡ÒÍ‡‰‡ Ï‡ÌÂ‚Ó‚Ó„Ó
          begin
            InsArcNewMsg(MarhTracert[1].ObjLast,391,1);//----------------- "ÒË„Ì‡Î Á‡Í˚Ú"
            ShowShortMsg(391,LastX,LastY, ObjZav[MarhTracert[1].ObjLast].Liter);
            result := false;
            exit;
          end;
        end;

        else  result := false; exit; //---------------------- ‰Û„Ëı Ï‡¯ÛÚÓ‚ ·˚Ú¸ ÌÂ ÏÓÊÂÚ
      end;
    end;

    //------ œÓ‚ÂËÚ¸ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ Ì‡ ÓÚÒÛÚÒÚ‚ËÂ ÔÓÂÁ‰‡ Ì‡ ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı
    if FindIzvStrelki(MarhTracert[1].ObjStart, MarhTracert[1].Rod) then //-------- ÂÒÎË ÂÒÚ¸
    begin
      inc(MarhTracert[1].WarCount);
      MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
      //- ÔÂ‰ÛÔÂÊ‰ÂÌËÂ "¬ÌËÏ‡ÌËÂ ÂÒÚ¸ ÌÂÁ‡ÏÍÌÛÚ˚Â ÒÚÂÎÍË ÔÂ‰Ï‡¯ÛÚÌÓ„Ó Û˜‡ÒÚÍ‡ ÒË„Ì‡Î‡"
      GetShortMsg(1,333, ObjZav[MarhTracert[1].ObjStart].Liter,1);
      InsWar(1,MarhTracert[1].ObjStart,333);
    end;
    MarhTracert[1].Finish := true;
    result := true;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.EndTracertMarshrut]'); result := false;
  end;
end;
{$IFNDEF RMARC}
//========================================================================================
function AddToTracertMarshrut(index : SmallInt) : Boolean;
//--------------------------- —‰ÂÎ‡Ú¸ Ú‡ÒÒËÓ‚ÍÛ ‰Ó ÒÎÂ‰Û˛˘ÂÈ ÚÓ˜ÍË, ÛÍ‡Á‡ÌÌÓÈ ÓÔÂ‡ÚÓÓÏ
var i,j,nextptr : integer;
begin
  try
    if (index = MarhTracert[1].ObjStart) or (index = MarhTracert[1].ObjEnd) then
    begin
      InsArcNewMsg(MarhTracert[1].ObjStart,1,7); //------- "ÔÓ‰ÓÎÊ‡ÈÚÂ Ì‡·Ó Ï‡¯ÛÚ‡ ÓÚ"
      ShowShortMsg(1, LastX, LastY, ObjZav[MarhTracert[1].ObjStart].Liter);
      result := false;
      exit;
    end;
    for i := 1 to MarhTracert[1].Counter do
    if Marhtracert[1].ObjTrace[i] = index then
    begin //------------------------- ÂÒÎË Ó·˙ÂÍÚ ÛÊÂ ‚ Ú‡ÒÒÂ - Á‡ÔÓÒËÚ¸ ÒÎÂ‰Û˛˘Û˛ ÚÓ˜ÍÛ
      InsArcNewMsg(MarhTracert[1].ObjStart,1,7);
      ShowShortMsg(1, LastX, LastY, ObjZav[MarhTracert[1].ObjStart].Liter);
      result := false;
      exit;
    end;

    //--------------------------------------------------------- Ì‡ÈÚË Á‡ÔËÒ¸ ‚ ÒÔËÒÍÂ ¿ Õ–
    for i := 1 to High(AKNR) do
    begin
      if (AKNR[i].ObjStart = 0) or (AKNR[i].ObjEnd = 0) then break
      else
      begin
        if (AKNR[i].ObjStart = MarhTracert[1].ObjLast) and (AKNR[i].ObjEnd = index) then
        for j := 1 to High(AKNR[i].ObjAuto) do
        begin
          if AKNR[i].ObjAuto[j] = 0 then break
          else
          begin
            nextptr := AKNR[i].ObjAuto[j];
            result := NextToTracertMarshrut(nextptr);
            if not result then exit;
          end;
        end;
      end;
    end;
    result := NextToTracertMarshrut(index);
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.AddToTracertMarshrut]'); result := false;
  end;
end;
//========================================================================================
function NextToTracertMarshrut(index : SmallInt) : Boolean;
//----------------------------------------------------- œÓ‰ÎËÚ¸ Ú‡ÒÒÛ ‰Ó ÒÎÂ‰Û˛˘ÂÈ ÚÓ˜ÍË
//------------------- index - ËÌ‰ÂÍÒ Ó·˙ÂÍÚ‡, Á‡‰‡ÌÌÓ„Ó Ì‡Ê‡ÚËÂÏ ÒÎÂ‰Û˛˘Â„Ó Ó·˙ÂÍÚ‡ ˝Í‡Ì‡

var
  i,j,c,k,wc,oe,strelka,signal : Integer;
  jmp : TOZNeighbour;
  TST_TRAS : TTracertResult;
  b,res : boolean;
begin
  try
    signal := 0;
    MarhTracert[1].FindNext := false;//œËÁÌ‡Í-ÚÂ·Ó‚‡ÌËÂ ÔÓ‚ÂÍË ‚ÓÁÏÓÊÌÓÒÚË ÔÓ‰ÓÎÊÂÌËˇ
    MarhTracert[1].LvlFNext := false;//œËÁÌ‡Í ÔÓˆÂ‰Û ÔÓËÒÍ‡ Ú‡ÒÒ˚ ‰Îˇ ÒÎÂ‰Û˛˘Â„Ó Ï‡¯.
    MarhTracert[1].Dobor    := false;//---- œËÁÌ‡Í ÔÓ‚ÂÍË ‚ÓÁÏÓÊÌÓÒÚË "‰Ó·Ó‡" Ï‡¯ÛÚ‡
    MarhTracert[1].HTail    := index; //------------- "ı‚ÓÒÚ" Ú‡ÒÒ˚, ÛÍ‡Á‡ÌÌ˚È ÓÔÂ‡ÚÓÓÏ
    Marhtracert[1].FullTail := false; //----------  œËÁÌ‡Í ÔÓÎÌÓÚ˚ ‰Ó·Ó‡ ı‚ÓÒÚ‡ Ï‡¯ÛÚ‡
    Marhtracert[1].VP := 0; //------------------------- Ó·˙ÂÍÚ Ï‡¯ÛÚ‡ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË
    MarhTracert[1].TailMsg  := ''; //--- ÒÓÓ·˘ÂÌËÂ Ó ÍÓÌˆÂ Ï‡¯ÛÚ‡ ("Á‡" ÒË„Ì‡Î ËÎË "‰Ó")
    MarhTracert[1].FindTail := true; //----------- ÔËÁÌ‡Í ÔÓ‚ÂÍË ÔÓ‰ÓÎÊÂÌËˇ, ÂÒÎË "Á‡"
    LastJmp.TypeJmp := 0; LastJmp.Obj := 0; LastJmp.Pin := 0;

    if WorkMode.GoTracert and not WorkMode.MarhRdy then //Ë‰ÂÚ Ú‡ÒÒËÓ‚Í‡,Ï‡¯. ÌÂ „ÓÚÓ‚
    begin
      result := true;
      if index = MarhTracert[1].ObjLast then //------- ÂÒÎË ‚˚¯ÎË Ì‡ Á‡‰‡ÌÌ˚È ÍÓÌÂˆ Ú‡ÒÒ˚
      begin
        InsArcNewMsg(MarhTracert[1].ObjStart,1,7);//------ "ÔÓ‰ÓÎÊ‡ÈÚÂ Ì‡·Ó Ï‡¯ÛÚ‡ ÓÚ"
        ShowShortMsg(1, LastX, LastY, ObjZav[MarhTracert[1].ObjStart].Liter);
        result := true;
        exit;
      end;
      //------------------------------------------ —Óı‡ÌËÚ¸ Ô‡‡ÏÂÚ˚ Ì‡˜‡ÚÓÈ Ú‡ÒÒËÓ‚ÍË
      MarhTracert[1].ObjPrev := MarhTracert[1].ObjLast; //-- Ó·˙ÂÍÚ ‚ ÍÓÌˆÂ Ì‡˜‡ÚÓÈ Ú‡ÒÒ˚
      MarhTracert[1].PinPrev := MarhTracert[1].PinLast; // Á‡‚Â¯‡˛˘‡ˇ ÚÓ˜Í‡ ˝ÚÓ„Ó Ó·˙ÂÍÚ‡

      if MarhTracert[1].Counter < High(MarhTracert[1].ObjTrace) then //ÂÒÎË Ò‚Ó·Ó‰ÌÓ ÏÂÒÚÓ
      begin //---------------- Ú‡ÒÒËÓ‚Í‡ - ÔÂ‚Ë˜Ì‡ˇ Ù‡Á‡, ÔÓËÒÍ ÏÂÊ‰Û Á‡‰‡ÌÌ˚ÏË ÚÓ˜Í‡ÏË
        i := TryMarhLimit; //------------------------- ÛÒÚ‡ÌÓ‚ËÚ¸ Ó„‡ÌË˜ËÚÂÎ¸ Ú‡ÒÒËÓ‚ÍË
        jmp :=ObjZav[MarhTracert[1].ObjLast].Neighbour[MarhTracert[1].PinLast];//ÍÓÌÌÂÍÚÓ

        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        MarhTracert[1].Level := tlFindTrace; //- Ì‡ÁÌ‡˜‡ÂÏ ÛÓ‚ÂÌ¸ ÔÓ‚ÂÍË Ì‡ÎË˜Ëˇ Ú‡ÒÒ˚
        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        //-------------------------------------------- Á‰ÂÒ¸ Ì‡˜ËÌ‡ÂÚÒˇ ˆËÍÎ ÔÓËÒÍ‡ Ú‡ÒÒ˚
        while i > 0 do //-------- ˆËÍÎ ‰Ó Ì‡ıÓÊ‰ÂÌËˇ Ú‡ÒÒ˚, ÎË·Ó ÔÂ‚˚¯ÂÌËˇ ˜ËÒÎ‡ ÔÓÔ˚ÚÓÍ
        begin //------------------------------------------ Ú‡ÒÒËÓ‚‡Ú¸ ‰Ó ÛÍ‡Á‡ÌÌÓÈ ÚÓ˜ÍË

          if jmp.Obj = index then break; //-------- Œ·Ì‡ÛÊÂÌ Ó·˙ÂÍÚ, ÛÍ‡Á‡ÌÌ˚È ÓÔÂ‡ÚÓÓÏ

          case StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1) of //- Ò‰ÂÎ‡Ú¸ ¯‡„
            trRepeat : //---------- ÍÓÌÂˆ ÌÂ Ì‡È‰ÂÌ, ÔÓ‰ÓÎÊ‡ÂÏ ÔÓËÒÍ ÓÚ ÔÓÒÎÂ‰ÌÂÈ ÒÚÂÎÍË
            begin
              if MarhTracert[1].Counter > 0 then
              begin //------------------------- ¬ÓÁ‚‡Ú Í ÔÓÒÎÂ‰ÌÂÈ ÌÂÔÂÂ‚Â‰ÂÌÌÓÈ ÒÚÂÎÍÂ
                j := MarhTracert[1].Counter; //------- Ì‡˜ËÌ‡ÂÏ ÓÚ ÚÂÍÛ˘Â„Ó Ó·˙ÂÍÚ‡ Ú‡ÒÒ˚

                while j > 0 do
                begin
                  case ObjZav[MarhTracert[1].ObjTrace[j]].TypeObj of //--- ÔÂÂıÓ‰ ÔÓ ÚËÔÛ
                    2 :
                    begin //------------------------------------------------------ ÒÚÂÎÍ‡
                      strelka := MarhTracert[1].ObjTrace[j];// ·ÂÂÏ ËÌ‰ÂÍÒ ÒÚ. ËÁ Ú‡ÒÒ˚

                      if ObjZav[strelka].ObjConstB[3] then //- ÓÒÌÓ‚Ì˚Â Ï‡¯ÛÚ˚ ÔÓ ÏËÌÛÒÛ
                      begin
                        if (ObjZav[strelka].bParam[10] and //----- ·˚Î ÔÓıÓ‰ ÔÂ‚˚È Ë ...
                        not ObjZav[strelka].bParam[11]) or //--- ÌÂ ·˚ÎÓ ÔÓÍ‡ 2-„Ó ËÎË ...
                        ObjZav[strelka].bParam[12] or  // ÔÓ¯ÂÒÚÌ‡ˇ ÌÛÊÌ‡ ‚ ÔÎ˛ÒÂ ËÎË ...
                        ObjZav[strelka].bParam[13] then //------ ÔÓ¯ÂÒÚÌ‡ˇ ÌÛÊÌ‡ ‚ ÏËÌÛÒÂ
                        begin
                          ObjZav[strelka].bParam[10] :=false;//Ò·ÓÒ ÙËÍÒ‡ˆËË 1-„Ó ÔÓıÓ‰‡
                          ObjZav[strelka].bParam[11] :=false;//Ò·ÓÒ ÙËÍÒ‡ˆËË 2-„Ó ÔÓıÓ‰‡
                          ObjZav[strelka].bParam[12] :=false; //-- Ò·ÓÒ ÔÓ¯ÂÒÚÌÓ„Ó ÔÎ˛Ò‡
                          ObjZav[strelka].bParam[13] :=false; //- Ò·ÓÒ ÔÓ¯ÂÒÚÌÓ„Ó ÏËÌÛÒ‡
                          MarhTracert[1].ObjTrace[j] :=0; //----- Û·‡Ú¸ ËÁ Ú‡ÒÒ˚ ÒÚÂÎÍÛ
                          dec(MarhTracert[1].Counter);  //------ ÛÏÂÌ¸¯ËÚ¸ ˜ËÒÎÓ ˝ÎÂÏÂÌÚÓ‚
                        end else
                        begin
                          ObjZav[strelka].bParam[11] := false; // Ò·ÓÒ ÔËÁÌ‡Í‡ 2-„Ó ıÓ‰‡
                          jmp := ObjZav[strelka].Neighbour[2]; //--- ÔÂÂıÓ‰ Ì‡ ÔÎ˛Ò-‚ÂÚÍÛ
                          break;
                        end;
                      end else //------------------------------ ÓÒÌÓ‚Ì˚Â Ï‡¯ÛÚ˚ ÔÓ ÔÎ˛ÒÛ
                      begin
                        if ObjZav[strelka].bParam[11] or //- ‚ÚÓÓÈ ıÓ‰ ÔÓ ÒÚÂÎÍÂ ËÎË ...
                        ObjZav[strelka].bParam[12] or //------- ÔÓ¯ÂÒÚÌ‡ˇ ‚ ÔÎ˛ÒÂ ËÎË ...
                        ObjZav[strelka].bParam[13] then //------------ ÔÓ¯ÂÒÚÌ‡ˇ ‚ ÏËÌÛÒÂ
                        begin
                          ObjZav[strelka].bParam[10] :=false;//Ò·ÓÒ ÙËÍÒ‡ˆËË 1-„Ó ÔÓıÓ‰‡
                          ObjZav[strelka].bParam[11] :=false;//Ò·ÓÒ ÙËÍÒ‡ˆËË 2-„Ó ÔÓıÓ‰‡
                          ObjZav[strelka].bParam[12] :=false; //-- Ò·ÓÒ ÔÓ¯ÂÒÚÌÓ„Ó ÔÎ˛Ò‡
                          ObjZav[strelka].bParam[13] :=false; //- Ò·ÓÒ ÔÓ¯ÂÒÚÌÓ„Ó ÏËÌÛÒ‡
                          MarhTracert[1].ObjTrace[j] := 0;
                          dec(MarhTracert[1].Counter);
                        end else
                        begin
                          ObjZav[strelka].bParam[11] := true;
                          jmp := ObjZav[strelka].Neighbour[3]; //-- œÂÂıÓ‰ Ì‡ ÏËÌÛÒ-‚ÂÚ‚¸
                          break;
                        end;
                      end;
                    end;

                    else //------------------------------ Î˛·ÓÈ Ó·˙ÂÍÚ ÓÚÎË˜Ì˚È ÓÚ ÒÚÂÎÍË
                      if MarhTracert[1].ObjTrace[j] = MarhTracert[1].ObjLast then
                      begin j := 0; break; end //------ ‚ÂÌÛÎËÒ¸ ‚ Ò‡ÏÓÂ Ì‡˜‡ÎÓ, ÔÂ‚‡Ú¸
                      else
                      begin //--------------------------- ÓÚÍ‡ÚËÚ¸ Ì‡ Ó‰ËÌ Ó·˙ÂÍÚ Í Ì‡˜‡ÎÛ
                        MarhTracert[1].ObjTrace[j] := 0;
                        dec(MarhTracert[1].Counter);
                      end;
                  end; //------------------------------------------------------ ÍÓÌÂˆ case
                  dec(j);
                end; //------------------------------------------ „‡ÌËˆ‡ while ‰Îˇ ÓÚÍ‡Ú‡

                if j < 1 then //----------------------- ÌÂÛ‰‡˜Ì˚È ÓÚÍ‡Ú, Ú‡ÒÒ‡ ÌÂ Ì‡È‰ÂÌ‡
                begin //------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË - ÚÓ˜Í‡ ÛÍ‡Á‡Ì‡ ÌÂ‚ÂÌÓ
                  InsArcNewMsg(MarhTracert[1].ObjStart,86,1);
                  RestorePrevTrace;
                  result := false;
                  ShowShortMsg(86, LastX, LastY, '');
//                  SingleBeep := true;
                  exit;
                end;
              end else //-------------------------- ‚ Ú‡ÒÒÂ ÌÂÚ ˝ÎÂÏÂÌÚÓ‚ (ÔÛÒÚ‡ˇ Ú‡ÒÒ‡)
              begin //--------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË - ÚÓ˜Í‡ ÛÍ‡Á‡Ì‡ ÌÂ‚ÂÌÓ
                InsArcNewMsg(MarhTracert[1].ObjStart,86,1);
                RestorePrevTrace; //------- ‚ÓÒÒÚ‡ÌÓ‚ËÚ¸ Ú‡ÒÒÛ ‰Ó ÔÓÒÎÂ‰ÌÂÈ Û‰‡˜ÌÓÈ ÚÓ˜ÍË
                result := false;
                ShowShortMsg(86, LastX, LastY, ''); //--- "“Ó˜Í‡ Ú‡ÒÒ˚ $ ÛÍ‡Á‡Ì‡ ÌÂ‚ÂÌÓ"
                exit;
              end;
            end;

            trStop : //------------ ÔË ÔÓÔ˚ÚÍÂ ÔÓÈÚË ˜ÂÂÁ Ó·˙ÂÍÚ - ÚÓÔÓÎÓ„Ëˇ ÌÂ ÔÛÒÍ‡ÂÚ
            begin
              InsArcNewMsg(MarhTracert[1].ObjStart,77,1);
              RestorePrevTrace; //-------------- ‚ÓÒÒÚ‡ÌÓ‚ËÚ¸Òˇ ‰Ó ÔÓÒÎÂ‰ÌÂÈ Û‰‡˜ÌÓÈ ÚÓ˜ÍË
              result := false;
              ShowShortMsg(77, LastX, LastY, '');  //--------------- Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
              exit;
            end;

            trEnd :
            begin //----------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË - Ï‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
              InsArcNewMsg(MarhTracert[1].ObjStart,77,1);
              RestorePrevTrace;
              result := false;
              ShowShortMsg(77, LastX, LastY, ''); exit;
            end;
          end; //------------------------------------------------- ÍÓÌÂˆ ˘‡„‡ ˜ÂÂÁ Ó·˙ÂÍÚ
          dec(i); //------ ÔÂÂÈÚË Í ÒÎÂ‰Û˛˘ÂÏÛ ¯‡„Û, ÛÏÂÌ¸¯Ë‚ ˜ËÒÎÓ ‰ÓÔÛÒÚËÏ˚ı ÓÒÚ‡‚¯ËıÒˇ
        end; //------------------------------ ÍÓÌÂˆ ˆËÍÎ‡ ÔÓÔ˚ÚÓÍ ¯‡„‡ÌËˇ ÔÓ Ó·˙ÂÍÚ‡Ï ·‡Á˚

        if i < 1 then //--------------------------- ‚˚¯ÎË Á‡ ÔÂ‰ÂÎ˚ ÛÒÚ‡ÌÓ‚ÎÂÌÌÓ„Ó ÎËÏËÚ‡
        begin //------------------------------------------------- ÔÂ‚˚¯ÂÌ Ò˜ÂÚ˜ËÍ ÔÓÔ˚ÚÓÍ
          InsArcNewMsg(MarhTracert[1].ObjStart,231,1);// œÂ‚˚¯ÂÌ Ò˜ÂÚ ÔÓÔ˚ÚÓÍ Ú‡ÒÒËÓ‚ÍË
          RestorePrevTrace;
          result := false;
          ShowShortMsg(231, LastX, LastY, '');
          exit;
        end;

        MarhTracert[1].ObjLast := index; //------------------------ Ó·ÌÓ‚ÎˇÂÏ ÍÓÌÂˆ Ú‡ÒÒ˚

        if ObjZav[index].TypeObj = 5 then MarhTracert[1].ObjEnd := index;

        case jmp.Pin of
          1 : MarhTracert[1].PinLast := 2; // Á‡ÔÓÏËÌ‡ÂÏ ÚÓ˜ÍÛ ‚˚ıÓ‰‡ ËÁ ÍÓÌÂ˜ÌÓ„Ó Ó·˙ÂÍÚ‡
          else MarhTracert[1].PinLast := 1;
        end;

        //------------------- œÓ‚ÂËÚ¸ ÌÂÓ·ıÓ‰ËÏÓÒÚ¸ ÔÓËÒÍ‡ ÔÂ‰ÔÓÎ‡„‡ÂÏÓÈ ÍÓÌÂ˜ÌÓÈ ÚÓ˜ÍË
        b := true;
        MarhTracert[1].PutPO := false; //--------------- Ò·ÓÒ ÔËÁÌ‡Í‡ Ú‡ÒÒËÓ‚ÍË ‚ ÔÛÚË

        if ObjZav[MarhTracert[1].ObjLast].TypeObj = 5 then
        begin //------------------ ƒÎˇ Ò‚ÂÚÓÙÓ‡ ÔÓ‚ÂËÚ¸ ÛÒÎÓ‚Ëˇ ÔÓ‰ÓÎÊÂÌËˇ Ú‡ÒÒËÓ‚ÍË
          signal := MarhTracert[1].ObjLast;
          if ObjZav[signal].ObjConstB[1] then  //-- ÂÒÚ¸ ÍÓÌÂˆ Ú‡ÒÒËÓ‚ÍË ‚ ÚÓ˜ÍÂ ÒË„Ì‡Î‡
          begin//“Ó˜Í‡ ‡Á˚‚‡ Ï‡¯ÛÚÓ‚ ◊/Õ (ÒÏÂÌ‡ Ì‡Ô‡‚ÎÂÌËˇ ‰‚ËÊÂÌËˇ Ì‡ ÒÚ‡ÌˆËË, ÚÛÔËÍ)
            b := false;
            MarhTracert[1].ObjEnd := signal;
          end
          else
          case MarhTracert[1].PinLast of
            1 :  //----------------------- ‚˚ıÓ‰ ËÁ ÒË„Ì‡Î‡ ‚ ÚÓ˜ÍÂ 1 (‚˚ÂÁ‰ Á‡ ‚ÒÚÂ˜Ì˚È)
            begin
              case MarhTracert[1].Rod of
                MarshP :
                begin
                  if ObjZav[signal].ObjConstB[6] then //---- ÂÒÚ¸ ÍÓÌÂˆ ÔÓÂÁ‰Ì˚ı ‚ ÚÓ˜ÍÂ 2
                  begin //------------------ «‡‚Â¯ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË ÔÓÂÁ‰ÌÓÈ ËÁ ÚÛÔËÍ‡
                    b := false;
                    MarhTracert[1].ObjEnd := signal;
                  end else //-------------- ÌÂÚ ÍÓÌˆ‡ œ ‚ ÚÓ˜ÍÂ 2 ( Á‡ ‚ÒÚÂ˜Ì˚Ï ÒË„Ì‡ÎÓÏ)
                  if ((ObjZav[signal].Neighbour[1].TypeJmp = 0) or
                  (ObjZav[signal].Neighbour[1].TypeJmp = LnkNecentr))
                  then begin b := false; i := 0; end; //ŒÚÍ‡Á ÂÒÎË ÌÂÚ ÔÓÂÁ‰ÌÓ„Ó ËÁ ÚÛÔËÍ‡
                end;

                MarshM :
                begin
                  if ObjZav[signal].ObjConstB[8] then //-- ÂÒÚ¸ ÍÓÌÂˆ Ï‡ÌÂ‚Ó‚˚ı ‚ ÚÓ˜ÍÂ 2
                  begin //----- «‡‚Â¯ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ Á‡ ‚ÒÚÂ˜Ì˚Ï, ÌÓ ÔÓ‚ÂËÚ¸ ÍÛ‰‡ Â‰ÂÏ
                    b := true;
                    MarhTracert[1].ObjEnd := signal;
                  end;
                end;

                else b := true; //---------------------------- ÌÂÓÔÂ‰ÂÎÂÌÌ˚È ÚËÔ Ï‡¯ÛÚ‡
              end;
            end;

            else //--- ‚˚ıÓ‰ ËÁ ÒË„Ì‡Î‡ ÍÓÌˆ‡ ‚ ÚÓ˜ÍÂ 2 (Á‡ ÔÓÔÛÚÌ˚Ï, ÁÌ‡˜ËÚ Ï‡¯ÛÚ "‰Ó")

            //-------------- ÂÒÎË Ï‡ÌÂ‚Ó‚˚È Ë ÂÒÚ¸ ÍÓÌÂˆ Ï‡ÌÂ‚Ó‚˚ı ‚ ÚÓ˜ÍÂ 1 ("‰Ó")  ËÎË
            if(((MarhTracert[1].Rod=MarshM) and ObjZav[signal].ObjConstB[7]) or
            //--------------------------- ÂÒÎË ÔÓÂÁ‰ÌÓÈ Ë ÂÒÚ¸ ÍÓÌÂˆ ÔÓÂÁ‰Ì˚ı ‚ ÚÓ˜ÍÂ 1 Ë
            ((MarhTracert[1].Rod = MarshP) and ObjZav[signal].ObjConstB[5])) and
            //---------------- ÂÒÎË ·ÎÓÍËÓ‚Í‡ FR4 ËÎË ·ÎÓÍËÓ‚Í‡ ‚ –Ã ƒ—œ ËÎË –Ã/Ã» ËÎË
            (ObjZav[signal].bParam[12] or
            ObjZav[signal].bParam[13] or
            ObjZav[jmp.Obj].bParam[18] or
            //-----------------------------------------------ÂÒÚ¸ Ì‡˜‡ÎÓ ÔÓÂÁ‰Ì˚ı Ë —1 ËÎË
            (ObjZav[signal].ObjConstB[2] and
            (ObjZav[signal].bParam[3] or
            //----------------------------------------------- —2 ËÎË Õ‡˜‡ÎÓ ËÁ ÒÂ‚Â‡ ËÎË
            ObjZav[signal].bParam[4] or
            ObjZav[signal].bParam[8] or
            //--------------------------------- œœ– Ú‡ÒÒËÓ‚ÍË ËÎË ÂÒÚ¸ Ì‡˜‡ÎÓ Ï‡ÌÂ‚Ó‚˚ı
            ObjZav[signal].bParam[9])) or
            (ObjZav[signal].ObjConstB[3]
            //-------------------------------------------------------------- Ë Ã—1 ËÎË Ã—2
            and (ObjZav[signal].bParam[1]
            or ObjZav[signal].bParam[2]
            //--------------------------------- ËÎË ÂÒÚ¸ ÕÃ ËÁ ÒÂ‚Â‡ ËÎË Ãœ– Ú‡ÒÒËÓ‚ÍË
            or ObjZav[signal].bParam[6]
            or ObjZav[signal].bParam[7]
            //ËÎË Ã”—
            or ObjZav[signal].bParam[21]))) then
            begin //--------------- «‡‚Â¯ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË ÔÓÔÛÚÌ˚È ‚ÔÂÂ‰Ë ÛÊÂ ÓÚÍ˚Ú
              b := false;
              MarhTracert[1].ObjEnd := signal;
            end else //----------------------------------------------------- ÒË„Ì‡Î Á‡Í˚Ú
            begin
              case MarhTracert[1].Rod of
                MarshP :      //-------------------------------------------- ÂÒÎË ÔÓÂÁ‰ÌÓÈ
                begin //------------------------------- ÂÒÎË ÂÒÚ¸ ÍÓÌÂˆ ÔÓÂÁ‰Ì˚ı ‚ ÚÓ˜ÍÂ 1
                  if ObjZav[signal].ObjConstB[5] then
                  begin //---------------------- ÂÒÚ¸ ÍÓÌÂˆ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡ Û Ò‚ÂÚÓÙÓ‡
                    MarhTracert[1].FullTail := true;
                    MarhTracert[1].FindNext := true;
                  end;
                  //------------------- ÂÒÎË ÌÂÚ ÒÍ‚ÓÁÌÓ„Ó ÔÓÔÛÒÍ‡ Ë ÂÒÚ¸ Ì‡˜‡ÎÓ ÔÓÂÁ‰Ì˚ı
                  if ObjZav[signal].ObjConstB[16] and
                  ObjZav[signal].ObjConstB[2] then //-------------- ÕÂÚ ÒÍ‚ÓÁÌÓ„Ó ÔÓÔÛÒÍ‡
                  begin //-------------- «‡‚Â¯ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË ÌÂÚ ÒÍ‚ÓÁÌÓ„Ó ÔÓÔÛÒÍ‡
                    b := false;
                    MarhTracert[1].ObjEnd := signal;
                    MarhTracert[1].FullTail := true //------------- Á‡ÍÓÌ˜ËÚ¸ Ì‡·Ó Ú‡ÒÒ˚
                  end else
                  begin
                    if ObjZav[signal].ObjConstB[5] then b := false // ÂÒÚ¸ ÍÓÌÂˆ "œ" ‚ Ú.1
                    else b := true;

                    if ObjZav[signal].ObjConstB[5] and //------ ÂÒÚ¸ ÍÓÌÂˆ "œ" ‚ Ú.1 Ë ...
                    not ObjZav[signal].ObjConstB[2] then //---------- ÌÂÚ ÔÓÂÁ‰ÌÓ„Ó Ì‡˜‡Î‡
                    begin
                      MarhTracert[1].ObjEnd := signal; //-- ÍÓÌÂˆ, ÌÂÚ ÔÓÂÁ‰Ì˚ı ÓÚ ÒË„Ì‡Î‡
                    end;
                  end;
                end;

                MarshM :
                begin
                  if ObjZav[signal].ObjConstB[7] then //-- ÂÒÚ¸ ÍÓÌÂˆ Ï‡ÌÂ‚Ó‚˚ı ‚ ÚÓ˜ÍÂ 1
                  begin
                    MarhTracert[1].FullTail := true;
                    MarhTracert[1].FindNext := true;
                  end;

                  if ObjZav[signal].ObjConstB[7]
                  then b := false
                  else b := true;

                  if ObjZav[signal].ObjConstB[7] and //------ ÂÒÚ¸ ÍÓÌÂˆ Ã ‚ ÚÓ˜ÍÂ 1 Ë ...
                  not ObjZav[signal].ObjConstB[3] then //- Û ÒË„Ì‡Î‡ ÌÂÚ Ì‡˜‡Î‡ Ï‡ÌÂ‚Ó‚˚ı
                  begin
                    MarhTracert[1].ObjEnd := signal;//- «‡‚Â¯ËÚ¸, ÌÂÚ Ï‡ÌÂ‚Ó‚ ÓÚ ÒË„Ì‡Î‡
                  end;
                end;

                else  b := true; //--------------- ÌÂÓÔÂ‰ÂÎÂÌÌ˚È Ï‡¯ÛÚ ÒÎÂ‰ÛÂÚ ÔÂ‚‡Ú¸
              end;
            end;
          end;
        end else //--------------------------------- Ó·˙ÂÍÚ˚ ÚËÔ‡ "ÔÛÚ¸" ËÎË "”œ Ò ÍÓÌˆÓÏ"
        if ((ObjZav[MarhTracert[1].ObjLast].TypeObj = 4) or //---------- ÂÒÎË ÔÛÚ¸ ËÎË ...

        ((ObjZav[MarhTracert[1].ObjLast].TypeObj = 3) and //--------------------- ”œ Ë ...
        (MarhTracert[1].Rod = MarshP) and //----------------------- ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ Ë ...
        (MarhTracert[1].PinLast = 1) and  //-------------- ‚˚ıÓ‰ ËÁ ”œ ˜ÂÂÁ ÚÓ˜ÍÛ 1 Ë ...
        (ObjZav[MarhTracert[1].ObjLast].ObjConstB[10] = true)) or //ÂÒÚ¸ ÍÓÌÂˆ ‚ Ú˜Í 1 ËÎË

        ((ObjZav[MarhTracert[1].ObjLast].TypeObj = 3) and //--------------------- ”œ Ë ...
        (MarhTracert[1].Rod = MarshP) and //----------------------- ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ Ë ...
        (MarhTracert[1].PinLast = 2) and  //-------------- ‚˚ıÓ‰ ËÁ ”œ ˜ÂÂÁ ÚÓ˜ÍÛ 2 Ë ...
        (ObjZav[MarhTracert[1].ObjLast].ObjConstB[11] = true)))  //---- ÂÒÚ¸ ÍÓÌÂˆ ‚ Ú˜Í 2
        then  MarhTracert[1].PutPO := true
        //---------------- ƒÎˇ ÔÛÚË ËÎË ”œ Ò ÍÓÌˆÓÏ ÛÒÚ‡ÌÓ‚ËÚ¸ ÔËÁÌ‡Í ÍÓÌˆ‡ Ì‡·Ó‡ Ú‡ÒÒ˚
        else
        if ObjZav[MarhTracert[1].ObjLast].TypeObj = 24 then
        begin //-------------------------- ƒÎˇ ÏÂÊÔÓÒÚÓ‚ÓÈ Û‚ˇÁÍË Á‡‚Â¯ËÚ¸ Ì‡·Ó Ï‡¯ÛÚ‡
          b := false;
          MarhTracert[1].ObjEnd := MarhTracert[1].ObjLast;
        end else
        if ObjZav[MarhTracert[1].ObjLast].TypeObj = 32 then
        begin //------------------------------------- ƒÎˇ Ì‡‰‚Ë„‡ Á‡‚Â¯ËÚ¸ Ì‡·Ó Ï‡¯ÛÚ‡
          b := false;
          MarhTracert[1].ObjEnd := MarhTracert[1].ObjLast;
        end;

        //++++++++++++++++++++++++++++++++++++++++++++ ÔÓ‰ÎÂÌËÂ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡ Á‡ ÒË„Ì‡Î
        if b then  //-------------------------------- ÌÂÚ Á‡‚Â¯ÂÌËˇ Ï‡¯ÛÚ‡, ÌÛÊÂÌ ‰Ó·Ó
        begin //--- ƒÓ·ËÚ¸ ‰Ó ÍÓÌÂ˜ÌÓÈ ÚÓ˜ÍË ËÎË ÓÚÍÎÓÌˇ˛˘ÂÈ ÒÚÂÎÍË, ÔÂÂ¯‡„ÌÛÚ¸ ÍÓÌÂ˜Ì˚È
          MarhTracert[1].FullTail := false;

          //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          MarhTracert[1].Level := tlContTrace; //------------------ ÂÊËÏ ÔÓ‰ÎÂÌËˇ Ú‡ÒÒ˚
          //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          //---------------------- ƒ Œ ¡ Œ –   “ – ¿ — — €  ------------------------------
          i := 1000;

          while i > 0 do
          begin
            TST_TRAS := StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1);//¯‡„ÌÛÚ¸
            case TST_TRAS of
              trStop :
              begin //-------------------------- ÍÓÌÂˆ Ú‡ÒÒËÓ‚ÍË - Ï‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
                InsArcNewMsg(MarhTracert[1].ObjStart,77,1);
                RestorePrevTrace;
                result := false;
                ShowShortMsg(77, LastX, LastY, '');
                exit;
              end;

              trBreak :
              begin //------------------------- Ò‰ÂÎ‡Ú¸ ÓÚÍ‡Ú ‰Ó ÔÂ‰˚‰Û˘ÂÈ ÚÓ˜ÍË Ï‡¯ÛÚ‡
                b := false;
                break;
              end;

              trEnd :
                      break; //------------------------- ‰ÓÒÚË„ÌÛÚ‡ ‰ÂÎˇ˘‡ˇ ÚÓ˜Í‡ Ï‡¯ÛÚ‡

              trEndTrace :
              begin  //-------------------------------- ‰ÓÒÚË„ÌÛÚ‡ ÍÓÌÂ˜Ì‡ˇ ÚÓ˜Í‡ Ï‡¯ÛÚ‡
                MarhTracert[1].ObjEnd := MarhTracert[1].ObjTrace[MarhTracert[1].Counter];
                MarhTracert[1].ObjLast := ObjZav[signal].Neighbour[1].Obj;//ÔÓıÓ‰ Á‡ ÒË„.
                break;
              end;
            end;
            dec(i);
          end;

          if i < 1 then
          begin //----------------------------------------------- ÔÂ‚˚¯ÂÌ Ò˜ÂÚ˜ËÍ ÔÓÔ˚ÚÓÍ
            InsArcNewMsg(MarhTracert[1].ObjStart,231,1);
            RestorePrevTrace;
            result := false;
            ShowShortMsg(231, LastX, LastY, ''); exit;
          end;

          if b then
          begin //------------------------------------------------------------- ÌÂÚ ÓÚÍ‡Ú‡
            jmp.Obj := MarhTracert[1].ObjLast;
            case jmp.Pin of
              1 : MarhTracert[1].PinLast := 2;
              else  MarhTracert[1].PinLast := 1;
            end;
          end else
          begin //-------------------------------------------------- ·˚Î ÓÚÍ‡Ú Ì‡ Ó‰ËÌ ¯‡„
            //------------------------------------------------------ ÔÓÔÛÒÚËÚ¸ ƒ« ÒÚÂÎÓÍ

            //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            MarhTracert[1].Level := tlStepBack; //----- ÂÊËÏ ¯‡„ Ì‡Á‡‰ ÔÓ Ú‡ÒÒÂ Ï‡¯ÛÚ‡
            //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

            i := MarhTracert[1].Counter;
            while i > 0 do
            begin
              case StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1) of
                trStop : break;
              end;
              dec(i);
            end;
            MarhTracert[1].ObjLast := jmp.Obj;
            MarhTracert[1].PinLast := jmp.Pin;
          end;
        end else
        begin //------------------------------------------ ≈ÒÎË ÌÂÚ ‰Ó·Ó‡ ı‚ÓÒÚ‡ Ï‡¯ÛÚ‡
          if MarhTracert[1].Counter < High(MarhTracert[1].ObjTrace) then
          begin //---------------------------------------- ÔÓÏÂÒÚËÚ¸ ı‚ÓÒÚ ‚ ÒÔËÒÓÍ Ú‡ÒÒ˚
            inc(MarhTracert[1].Counter);
            MarhTracert[1].ObjTrace[MarhTracert[1].Counter] := jmp.Obj;
          end;
        end;

        LastJmp := jmp; //-------------------- —Óı‡ÌËÚ¸ ÔÓÒÎÂ‰ÌËÈ ÔÂÂıÓ‰ ÏÂÊ‰Û Ó·˙ÂÍÚ‡ÏË

        if i < 1 then
        begin //----------------------------------- ÓÚÍ‡Á ÔÓ ÌÂÒÓÓÚ‚ÂÚÒÚ‚Ë˛ ÍÓÌÂ˜ÌÓÈ ÚÓ˜ÍË
          InsArcNewMsg(index,86,1);   //------------------- “Ó˜Í‡ Ú‡ÒÒ˚ $ ÛÍ‡Á‡Ì‡ ÌÂ‚ÂÌÓ
          RestorePrevTrace; result := false;
          ShowShortMsg(86, LastX, LastY, ObjZav[index].Liter);
          exit;
        end;

        //-------------------------------------------- œÓ‚ÂËÚ¸ Óı‡ÌÌÓÒÚË ÔÓ ‚ÒÂÈ Ú‡ÒÒÂ
        i := 1000;
        Marhtracert[1].VP := 0;
        jmp := ObjZav[MarhTracert[1].ObjStart].Neighbour[2];

        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        MarhTracert[1].Level := tlVZavTrace; //----- ÂÊËÏ ÔÓ‚ÂÍ‡ Á‡‚ËÒËÏÓÒÚÂÈ ÔÓ Ú‡ÒÒÂ
        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


        j := MarhTracert[1].ObjEnd; //------------------ Ì‡È‰ÂÌÌ˚È ÍÓÌÂˆ ÔÓ‰ÎÂÌÌÓÈ Ú‡ÒÒ˚

        MarhTracert[1].CIndex := 1;
        if j < 1 then j := MarhTracert[1].ObjTrace[MarhTracert[1].Counter];

        res := false;
        while i > 0 do
        begin
          case StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1) of
            trStop :  begin i := 0; break; end;
            trBreak : break;
            trEnd :   break;
          end;
          dec(i);
          if res then break;         
          if jmp.Obj = j then res := true; //--------------- Œ·Ì‡ÛÊÂÌ Ó·˙ÂÍÚ ÍÓÌˆ‡ Ú‡ÒÒ˚
          inc(MarhTracert[1].CIndex);
        end;

        if MarhTracert[1].MsgCount > 0 then //-- ÂÒÚ¸ Á‡ÔÂ˘‡˛˘ËÂ ÒÓÓ·˘ÂÌËˇ (‚‡Ê‰Â·ÌÓÒÚ¸)
        begin
          InsArcNewMsg(MarhTracert[1].MsgObject[1],MarhTracert[1].MsgIndex[1],1);
          RestorePrevTrace;
          result := false;
          PutShortMsg(1, LastX, LastY, MarhTracert[1].Msg[1]);
          exit;
        end;

        if i < 0 then //--------------------- ÓÚÍ‡Á ÔÓ Óı‡ÌÌÓÒÚˇÏ - Ï‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        begin
          InsArcNewMsg(MarhTracert[1].ObjStart,77,1);
          RestorePrevTrace;
          result := false;
          ShowShortMsg(77, LastX, LastY, '');
          exit;
        end;

        //------------------------------ –‡ÒÍË‰‡Ú¸ ÔËÁÌ‡ÍË Ú‡ÒÒËÓ‚ÍË ÔÓ Ó·˙ÂÍÚ‡Ï Ú‡ÒÒ˚
        for i := 1 to MarhTracert[1].Counter do
        begin
          case ObjZav[MarhTracert[1].ObjTrace[i]].TypeObj of
            3 :   //--------------------------------------------------------------- ÒÂÍˆËˇ
            begin
              if  not ObjZav[MarhTracert[1].ObjTrace[i]].bParam[14] then
              ObjZav[MarhTracert[1].ObjTrace[i]].bParam[8] := false;
            end;

            4 :  //------------------------------------------------------------------ ÔÛÚ¸
            begin
              if  not ObjZav[MarhTracert[1].ObjTrace[i]].bParam[14] then
              ObjZav[MarhTracert[1].ObjTrace[i]].bParam[8] := false;
            end;
          end;
        end;

        //------------------------------------------ œÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË ÔÓ ‚ÒÂÈ Ú‡ÒÒÂ
        i := 1000;
        MarhTracert[1].MsgCount := 0;
        MarhTracert[1].WarCount := 0;
        MarhTracert[1].GonkaStrel := false; //----- Û·‡Ú¸ ÔËÁÌ‡Í „ÓÌÍË ÒÚÂÎÓÍ ÔÓ Ú‡ÒÒÂ
        MarhTracert[1].GonkaList  := 0;    // Ò·ÓÒËÚ¸ Ò˜ÂÚ˜ËÍ ÒÚÂÎÓÍ, ÚÂ·Û˛˘Ëı ÔÂÂ‚Ó‰‡
        jmp := ObjZav[MarhTracert[1].ObjStart].Neighbour[2];

        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        MarhTracert[1].Level := tlCheckTrace;//---- ÂÊËÏ ÔÓ‚ÂÍ‡ ‚‡Ê‰Â·ÌÓÒÚÂÈ ÔÓ Ú‡ÒÒÂ
        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        Marhtracert[1].VP := 0;
        j := MarhTracert[1].ObjEnd;
        if j < 1 then j := MarhTracert[1].ObjTrace[MarhTracert[1].Counter];
        MarhTracert[1].CIndex := 1;

        while i > 0 do
        begin
          if jmp.Obj = j then
          begin //------------------------------------------ Œ·Ì‡ÛÊÂÌ Ó·˙ÂÍÚ ÍÓÌˆ‡ Ú‡ÒÒ˚
            //----------------------------------------------- ÔÓËÒÍ ‚‡Ê‰Â·ÌÓÒÚÂÈ ‚ ı‚ÓÒÚÂ
            StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1);
            break;
          end;

          case StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1) of
            trStop : break;
          end;
          dec(i);
          inc(MarhTracert[1].CIndex);
        end;

        if i < 1 then
        begin //--------------------------------------------- ÓÚÍ‡Á ÔÓ ÔÂ‚˚¯ÂÌË˛ Ò˜ÂÚ˜ËÍ‡
          InsArcNewMsg(MarhTracert[1].ObjStart,231,1);
          RestorePrevTrace;
          result := false;
          ShowShortMsg(231, LastX, LastY, '');
          exit;
        end;
        tm := MarhTracert[1].TailMsg; //------------ ÒÓı‡ÌËÚ¸ ÒÓÓ·˘ÂÌËÂ ‚ ı‚ÓÒÚÂ Ï‡¯ÛÚ‡

        if MarhTracert[1].MsgCount > 0 then
        begin  //--------------------------------------------------- ÓÚÍ‡Á ÔÓ ‚‡Ê‰Â·ÌÓÒÚË
          MarhTracert[1].MsgCount := 1; //------------------------ ÓÒÚ‡‚ËÚ¸ Ó‰ÌÓ ÒÓÓ·˘ÂÌËÂ
          //--------------- «‡ÍÓÌ˜ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ Ë Ò·ÓÒËÚ¸ Ú‡ÒÒÛ ÂÒÎË ÂÒÚ¸ ‚‡Ê‰Â·ÌÓÒÚË
          CreateDspMenu(KeyMenu_ReadyResetTrace,LastX,LastY);
          result := false;
          exit;
        end else
        begin
          if MarhTracert[1].PutPO then //---------------- «‡‚Â¯ËÚ¸ Ì‡·Ó ÂÒÎË ÛÍ‡Á‡Ì ÔÛÚ¸
           MarhTracert[1].ObjEnd := MarhTracert[1].ObjTrace[MarhTracert[1].Counter];

          if (MarhTracert[1].WarCount > 0) and
          MarhTracert[1].FullTail then //--------  œË Ì‡ÎË˜ËË ÒÓÓ·˘ÂÌËÈ Ë ı‚ÓÒÚÂ Ï‡¯ÛÚ‡
          MarhTracert[1].ObjEnd := MarhTracert[1].ObjTrace[MarhTracert[1].Counter];

          //------------------------------ œÓ‚ÂÍ‡ ‚ÓÁÏÓÊÌÓÒÚË Ì‡·Ó‡ ÒÎÂ‰Û˛˘Â„Ó Ï‡¯ÛÚ‡
          c := MarhTracert[1].Counter; //-------- ÒÓı‡ÌËÚ¸ ÚÂÍÛ˘ÂÂ ˜ËÒÎÓ ˝ÎÂÏÂÌÚÓ‚ Ú‡ÒÒ˚
          wc := MarhTracert[1].WarCount;  //--------------- ÒÓı‡ÌËÚ¸ ˜ËÒÎÓ ÔÂ‰ÛÔÂÊ‰ÂÌËÈ
          oe := MarhTracert[1].ObjEnd; //--------------------------------- ÍÓÌÂ˜Ì˚È Ó·˙ÂÍÚ

          MarhTracert[1].VP := 0;
          MarhTracert[1].LvlFNext := true;

          if (MarhTracert[1].ObjEnd = 0) and (MarhTracert[1].FindNext) then
          begin //------------------------ œÓ‚ÂÍ‡ ‚ÓÁÏÓÊÌÓÒÚË Ì‡·Ó‡ ÒÎÂ‰Û˛˘Â„Ó Ï‡¯ÛÚ‡
            i := TryMarhLimit * 2;
            jmp := ObjZav[MarhTracert[1].ObjLast].Neighbour[MarhTracert[1].PinLast];

            //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            MarhTracert[1].Level := tlFindTrace;
            //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

            while i > 0 do
            begin //------------------------------------------------ Ú‡ÒÒËÓ‚‡Ú¸ ÔÓ ¯‡„‡Ï

              case StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1) of

                trRepeat :  //--------------------- ÂÒÎË ÌÛÊÂÌ ‚ÓÁ‚‡Ú Í ÔÓÒÎÂ‰ÌÂÈ ÒÚÂÎÍÂ
                begin

                  if MarhTracert[1].Counter > c then //-- ÂÒÎË ·˚Î ıÓÚˇ ·˚ Ó‰ËÌ ¯‡„ ‚ÔÂÂ‰
                  begin   //------------------- ¬ÓÁ‚‡Ú Í ÔÓÒÎÂ‰ÌÂÈ ÌÂÔÂÂ‚Â‰ÂÌÌÓÈ ÒÚÂÎÍÂ
                    j := MarhTracert[1].Counter; // Ì‡˜ËÌ‡ÂÏ Ò ÍÓÌˆ‡ (ÒÌ‡˜‡Î‡ Á‰ÂÒ¸ j > c)
                    while j > 0 do
                    begin

                      case ObjZav[MarhTracert[1].ObjTrace[j]].TypeObj of

                        2 :
                        begin //-------------------------------------------------- ÒÚÂÎÍ‡
                          strelka := MarhTracert[1].ObjTrace[j];

                          if ObjZav[strelka].ObjConstB[3] then//„Î‡‚Ì˚Â Ï‡¯ÛÚ˚ ÔÓ ÏËÌÛÒÛ
                          begin
                            if (ObjZav[strelka].bParam[10] and  //-- ·˚Î 1-˚È ÔÓıÓ‰ Ë ...
                            not ObjZav[strelka].bParam[11]) or //- ·˚Î 2-ÓÈ ÔÓıÓ‰ ËÎË ...
                            ObjZav[strelka].bParam[12] or //  ÔÓ¯ÂÒÚÌ‡ˇ ÌÛÊÌ‡ ‚ ÔÎ˛ÒÂ ËÎË
                            ObjZav[strelka].bParam[13] then //-- ÔÓ¯ÂÒÚÌ‡ˇ ÌÛÊÌ‡ ‚ ÏËÌÛÒÂ
                            begin
                              ObjZav[strelka].bParam[10] := false;//Ò·ÓÒËÚ¸ ÔÂ‚˚È ÔÓıÓ‰
                              ObjZav[strelka].bParam[11] := false;//Ò·ÓÒËÚ¸ ‚ÚÓÓÈ ÔÓıÓ‰
                              ObjZav[strelka].bParam[12] := false; // Ò·ÓÒ ÔÓ¯ÂÒÚÌ‡ˇ ‚ +
                              ObjZav[strelka].bParam[13] := false; // Ò·ÓÒ ÔÓ¯ÂÒÚÌ‡ˇ ‚ -
                              MarhTracert[1].ObjTrace[j] := 0; // Û·‡Ú¸ ÒÚÂÎÍÛ ËÁ Ú‡ÒÒ˚
                              dec(MarhTracert[1].Counter); //------------ ÒÓÍ‡ÚËÚ¸ Ú‡ÒÒÛ
                            end else
                            begin
                              ObjZav[strelka].bParam[11] := false;//ÛÒÚ‡ÌÓ‚ËÚ¸ 2-ÓÈ ÔÓıÓ‰
                              jmp := ObjZav[strelka].Neighbour[2]; //œÂÂıÓ‰ Ì‡ ÔÎ˛Ò-‚ÂÚ‚¸
                              break;
                            end;
                          end else
                          begin //----------------------------- ÓÒÌÓ‚Ì˚Â Ï‡¯ÛÚ˚ ÔÓ ÔÎ˛ÒÛ
                            if ObjZav[strelka].bParam[11] or//ÂÒÎË ·˚Î 2-ÓÈ ÔÓıÓ‰ ËÎË ...
                            ObjZav[strelka].bParam[12] or //--- ÔÓ¯ÂÒÚÌ‡ˇ ‚ ÔÎ˛ÒÂ ËÎË ...
                            ObjZav[strelka].bParam[13] then //-------- ÔÓ¯ÂÒÚÌ‡ˇ ‚ ÏËÌÛÒÂ
                            begin
                              ObjZav[strelka].bParam[10] := false;
                              ObjZav[strelka].bParam[11] := false;
                              ObjZav[strelka].bParam[12] := false;
                              ObjZav[strelka].bParam[13] := false;
                              MarhTracert[1].ObjTrace[j] := 0;
                              dec(MarhTracert[1].Counter);
                            end else
                            begin
                              ObjZav[MarhTracert[1].ObjTrace[j]].bParam[11] := true;//2-ÓÈ
                              jmp:= ObjZav[MarhTracert[1].ObjTrace[j]].Neighbour[3];//Ì‡ -
                              break;
                            end;
                          end;
                        end;

                        else //---------------- Î˛·ÓÈ ‰Û„ÓÈ Ó·˙ÂÍÚ (ÌÂ ˇ‚ÎˇÂÚÒˇ ÒÚÂÎÍÓÈ)
                          if MarhTracert[1].ObjTrace[j] = MarhTracert[1].ObjLast then
                          begin  //- ÍÓÌÂˆ, Á‡‰‡ÌÌ˚È ÓÔÂ‡ÚÓÓÏ Ì‡ ˝Í‡ÌÂ ‰Îˇ Ú‡ÒÒËÓ‚ÍË
                            j := 0; break;
                          end else
                          begin //---------------- ÓÚÍ‡ÚËÚ¸ Ì‡ Ó‰ËÌ Ó·˙ÂÍÚ Í Ì‡˜‡ÎÛ Ú‡ÒÒ˚
                            MarhTracert[1].ObjTrace[j] := 0;
                            dec(MarhTracert[1].Counter);
                          end;

                      end; //-------------------------------- ÍÓÌÂˆ case ÔÓ ÚËÔ‡Ï Ó·˙ÂÍÚÓ‚
                      dec(j);
                    end; //--------- ÍÓÌÂˆ while j > 0 ÔÓ ˜ËÒÎÛ Ó·˙ÂÍÚÓ‚ ‚Ó¯Â‰¯Ëı ‚ Ú‡ÒÒÛ

                    if j <= c then //------------------------- ÂÒÎË ‚˚ÔÓÎÌÂÌ ‚ÓÁ‚‡Ú Ì‡Á‡‰
                    begin //--------------------------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË
                      oe := MarhTracert[1].ObjLast;
                      break;
                    end;
                  end else //------------ ÂÒÎË Ì‡ Ó˜ÂÂ‰ÌÓÏ Ó·˙ÂÍÚÂ ÌÂÚ ÔÓ‰‚ËÊÂÌËˇ ‚ÔÂÂ‰
                  begin //----------------------------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË
                    MarhTracert[1].ObjEnd := MarhTracert[1].ObjLast;
                    break;
                  end;
                end; //-------------------------- ÍÓÌÂˆ case ÔÓ ÂÁÛÎ¸Ú‡ÚÛ ¯‡„‡ = trRepeat

                trStop, trEnd : break; //-------------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË
              end; //------------------------------------------------------ case steptrace

              //-------------------------------------- œÓ‚ÂËÚ¸ ‰ÓÒÚËÊÂÌËÂ ÍÓÌÂ˜ÌÓÈ ÚÓ˜ÍË
              b := false;

              if ObjZav[jmp.Obj].TypeObj = 5 then //-------------------------- ÂÒÎË ÒË„Ì‡Î
              begin //------------ ƒÎˇ Ò‚ÂÚÓÙÓ‡ ÔÓ‚ÂËÚ¸ ÛÒÎÓ‚Ëˇ ÔÓ‰ÓÎÊÂÌËˇ Ú‡ÒÒËÓ‚ÍË
                if ObjZav[jmp.Obj].ObjConstB[1] then b := true //- “Ó˜Í‡ ‡Á˚‚‡ Ï‡¯ÛÚÓ‚
                else
                case jmp.Pin of
                  2 :
                  begin //--------------------------- ÔÓ‰Ó¯ÎË Í ÚÓ˜ÍÂ 2 (ÒË„Ì‡Î ‚ÒÚÂ˜Ì˚È)
                    case MarhTracert[1].Rod of
                      MarshP : if ObjZav[jmp.Obj].ObjConstB[6] then b := true;//œ ÍÓÌÂˆ Ú2

                      MarshM : if ObjZav[jmp.Obj].ObjConstB[8] then b := true;//Ã ÍÓÌÂˆ Ú2

                      else  b := false;
                    end;
                  end;
                  else //---------------------------- ÔÓ‰Ó¯ÎË Í ÚÓ˜ÍÂ 1, (ÒË„Ì‡Î ÔÓÔÛÚÌ˚È)
                    if ObjZav[jmp.Obj].bParam[1] or ObjZav[jmp.Obj].bParam[2]//Ã—1 ËÎË Ã—2
                    or //------------------------------------------------------------- ËÎË
                    ObjZav[jmp.Obj].bParam[3] or ObjZav[jmp.Obj].bParam[4] //--- —1 ËÎË —2
                    or //------------------------------------------------------------- ËÎË
                    ObjZav[jmp.Obj].bParam[6] or ObjZav[jmp.Obj].bParam[7]//ÕÃ_FR3 ËÎË Ãœ–
                    or //------------------------------------------------------------- ËÎË
                    ObjZav[jmp.Obj].bParam[8] or ObjZav[jmp.Obj].bParam[9] //Õ_FR3 ËÎË œœ–
                    or //------------------------------------------------------------- ËÎË
                    ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13]//·ÎÓÍSTAN_DSP
                    or //------------------------------------------------------------- ËÎË
                    ObjZav[jmp.Obj].bParam[18] or ObjZav[jmp.Obj].bParam[21] //- –Ã_Ã»_Ã”—
                    then b := true //ÔÓÔÛÚÌ˚È ÛÊÂ ÓÚÍ˚Ú, Ì‡ ‚˚‰ÂÊÍÂ, ‚ Ú‡ÒÒÂ,·ÎÓÍËÓ‚‡Ì
                    else
                    begin
                      case MarhTracert[1].Rod of
                        MarshP :
                        begin
                          if ObjZav[jmp.Obj].ObjConstB[16] and // ÕÂÚ ÒÍ‚ÓÁÌÓ„Ó ÔÓÔÛÒÍ‡ Ë
                          ObjZav[jmp.Obj].ObjConstB[2] then b := true // ÂÒÚ¸ Ì‡˜‡ÎÓ ‰Îˇ œ
                          else
                          begin
                            b := ObjZav[jmp.Obj].ObjConstB[5]; //Ì‡ÎË˜ËÂ œ ÍÓÌˆ‡ ‚ ÚÓ˜ÍÂ 1
                          end;
                        end;

                        MarshM : b := ObjZav[jmp.Obj].ObjConstB[7];   // Ã ÍÓÌÂˆ ‚ ÚÓ˜ÍÂ 1

                        else  b := true;  //------------------- ÌÂˇÒÌ˚È Ï‡¯ÛÚ ÓÒÚ‡ÌÓ‚ËÚ¸
                      end;
                    end;
                end;
              end else
              if ObjZav[jmp.Obj].TypeObj = 15 then
              begin //-------------------- ƒÎˇ Û‚ˇÁÍË Ò ÔÂÂ„ÓÌÓÏ Á‡‚Â¯ËÚ¸ Ì‡·Ó Ï‡¯ÛÚ‡
                inc(MarhTracert[1].Counter);
                MarhTracert[1].ObjTrace[MarhTracert[1].Counter] := jmp.Obj;
                b := true;
              end else
              if ObjZav[jmp.Obj].TypeObj = 24 then
              begin //-------------------- ƒÎˇ ÏÂÊÔÓÒÚÓ‚ÓÈ Û‚ˇÁÍË Á‡‚Â¯ËÚ¸ Ì‡·Ó Ï‡¯ÛÚ‡
                b := true;
              end else
              if ObjZav[jmp.Obj].TypeObj = 26 then
              begin //-------------------------- ƒÎˇ Û‚ˇÁÍË Ò œ¿¡ Á‡‚Â¯ËÚ¸ Ì‡·Ó Ï‡¯ÛÚ‡
                inc(MarhTracert[1].Counter);
                MarhTracert[1].ObjTrace[MarhTracert[1].Counter] := jmp.Obj;
                b := true;
              end else
              if ObjZav[jmp.Obj].TypeObj = 32 then
              begin //------------------------------- ƒÎˇ Ì‡‰‚Ë„‡ Á‡‚Â¯ËÚ¸ Ì‡·Ó Ï‡¯ÛÚ‡
                b := true;
              end;

              if b then //- Ï‡¯ÛÚ Á‡‚Â¯ÂÌ Ì‡ ˝Ú‡ÔÂ Ú‡ÒÒËÓ‚ÍË, ÚÓ ÔÓ‚ÂËÚ¸ Óı‡ÌÌÓÒÚË
              begin
                k := 15000;
                jmp.Obj := MarhTracert[1].ObjLast;
                if MarhTracert[1].PinLast = 1 then jmp.Pin := 2 else
                jmp.Pin := 1;

                //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                MarhTracert[1].Level := tlVZavTrace;//ÂÊËÏ ÔÓ‚ÂÍ‡ Á‡‚ËÒËÏÓÒÚÂÈ ‚ Ú‡ÒÒÂ
                //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                j := MarhTracert[1].ObjTrace[MarhTracert[1].Counter];
                MarhTracert[1].CIndex := c;
                b := true;

                while k > 0 do
                begin
                  if jmp.Obj = j then break; //------------- Œ·Ì‡ÛÊÂÌ Ó·˙ÂÍÚ ÍÓÌˆ‡ Ú‡ÒÒ˚
                  case StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1) of
                    trStop :         begin  b := false; break; end;
                    trBreak, trEnd : begin   break;            end;
                  end;
                  dec(k);
                  inc(MarhTracert[1].CIndex);
                end;

                if (k > 1000) and b then
                begin
                  //----------------------------------------------- œÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË
                  jmp.Obj := MarhTracert[1].ObjLast;
                  if MarhTracert[1].PinLast = 1 then jmp.Pin := 2
                  else jmp.Pin := 1;

                  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                  MarhTracert[1].Level := tlCheckTrace;//- ÂÊËÏ ÔÓ‚ÂÍ‡ ‚‡Ê‰. ÔÓ Ú‡ÒÒÂ
                  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                  MarhTracert[1].Dobor := true;
                  MarhTracert[1].MsgCount := 0;
                  j := MarhTracert[1].ObjTrace[MarhTracert[1].Counter];
                  MarhTracert[1].CIndex := c;
                  while k > 0 do
                  begin
                    if jmp.Obj = j then
                    begin //-------------------------------- Œ·Ì‡ÛÊÂÌ Ó·˙ÂÍÚ ÍÓÌˆ‡ Ú‡ÒÒ˚
                      // ¬‡Ê‰Â·ÌÓÒÚË ‚ ı‚ÓÒÚÂ
                      StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1); break;
                    end;

                    case StepTrace(jmp,MarhTracert[1].Level,MarhTracert[1].Rod,1) of
                      trStop,trBreak :  break;
                    end;

                    dec(i);
                    inc(MarhTracert[1].CIndex);
                  end;
                end;

                if MarhTracert[1].MsgCount > 0 then b := false;

                if (k < 1) or not b then
                begin //--------------------------- ÓÚÍ‡Á ÔÓ Óı‡ÌÌÓÒÚˇÏ ËÎË ‚‡Ê‰Â·ÌÓÒÚˇÏ
                  if MarhTracert[1].Counter > c then
                  begin
                    //------------------------- ¬ÓÁ‚‡Ú Í ÔÓÒÎÂ‰ÌÂÈ ÌÂÔÂÂ‚Â‰ÂÌÌÓÈ ÒÚÂÎÍÂ
                    j := MarhTracert[1].Counter;
                    while j > 0 do
                    begin
                      case ObjZav[MarhTracert[1].ObjTrace[j]].TypeObj of
                        2 :
                        begin //-------------------------------------------------- ÒÚÂÎÍ‡
                          strelka := MarhTracert[1].ObjTrace[j];
                          if ObjZav[strelka].ObjConstB[3] then
                          begin //---------------------------- ÓÒÌÓ‚Ì˚Â Ï‡¯ÛÚ˚ ÔÓ ÏËÌÛÒÛ
                            if (ObjZav[strelka].bParam[10] and
                            not ObjZav[strelka].bParam[11]) or
                            ObjZav[strelka].bParam[12] or
                            ObjZav[strelka].bParam[13] then
                            begin
                              ObjZav[strelka].bParam[10] := false;
                              ObjZav[strelka].bParam[11] := false;
                              ObjZav[strelka].bParam[12] := false;
                              ObjZav[strelka].bParam[13] := false;
                              MarhTracert[1].ObjTrace[j] := 0;
                              dec(MarhTracert[1].Counter);
                            end else
                            begin
                              ObjZav[strelka].bParam[11] := false;
                              jmp := ObjZav[strelka].Neighbour[2]; //œÂÂıÓ‰ Ì‡ ÔÎ˛Ò-‚ÂÚ‚¸
                              break;
                            end;
                          end else
                          begin //----------------------------- ÓÒÌÓ‚Ì˚Â Ï‡¯ÛÚ˚ ÔÓ ÔÎ˛ÒÛ
                            if ObjZav[strelka].bParam[11] or
                            ObjZav[strelka].bParam[12] or
                            ObjZav[strelka].bParam[13] then
                            begin
                              ObjZav[strelka].bParam[10] := false;
                              ObjZav[strelka].bParam[11] := false;
                              ObjZav[strelka].bParam[12] := false;
                              ObjZav[strelka].bParam[13] := false;
                              MarhTracert[1].ObjTrace[j] := 0;
                              dec(MarhTracert[1].Counter);
                            end else
                            begin
                              ObjZav[strelka].bParam[11] := true;
                              jmp := ObjZav[strelka].Neighbour[3];//œÂÂıÓ‰ Ì‡ ÏËÌÛÒ-‚ÂÚ‚¸
                              break;
                            end;
                          end;
                        end;
                        else
                          if MarhTracert[1].ObjTrace[j] = MarhTracert[1].ObjLast then
                          begin
                            oe := MarhTracert[1].ObjLast;
                            break;
                          end else
                          begin //----------------------- ÓÚÍ‡ÚËÚ¸ Ì‡ Ó‰ËÌ Ó·˙ÂÍÚ Í Ì‡˜‡ÎÛ
                            MarhTracert[1].ObjTrace[j] := 0;
                            dec(MarhTracert[1].Counter);
                          end;
                      end;
                      dec(j);
                    end;
                    if j <= c then
                    begin //--------------------------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË
                      oe := MarhTracert[1].ObjLast;
                      break;
                    end;
                  end else
                  begin //----------------------------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË
                    oe := MarhTracert[1].ObjLast;
                    break;
                  end;
                end
                else break;
              end;

              //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
              MarhTracert[1].Level := tlFindTrace; //
              //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

              dec(i);
            end;

            if i < 1 then oe := MarhTracert[1].ObjLast; //------- ÔÂ‚˚¯ÂÌ Ò˜ÂÚ˜ËÍ ÔÓÔ˚ÚÓÍ

          end;

          while MarhTracert[1].Counter > c do
          begin //------------------ Û·‡Ú¸ ÔËÁÌ‡ÍË Ú‡ÒÒËÓ‚ÍË ÔÂÂ‰ ÔÓ‰ÓÎÊÂÌËÂÏ Ì‡·Ó‡
            if ObjZav[MarhTracert[1].ObjTrace[MarhTracert[1].Counter]].TypeObj = 2 then // ÒÚÂÎÍ‡
            begin
              ObjZav[MarhTracert[1].ObjTrace[MarhTracert[1].Counter]].bParam[10] := false;
              ObjZav[MarhTracert[1].ObjTrace[MarhTracert[1].Counter]].bParam[11] := false;
              ObjZav[MarhTracert[1].ObjTrace[MarhTracert[1].Counter]].bParam[12] := false;
              ObjZav[MarhTracert[1].ObjTrace[MarhTracert[1].Counter]].bParam[13] := false;
            end;
            MarhTracert[1].ObjTrace[MarhTracert[1].Counter] := 0;
            dec(MarhTracert[1].Counter);
          end;
          MarhTracert[1].MsgCount := 0;
          MarhTracert[1].WarCount := wc;
          MarhTracert[1].ObjEnd   := oe;

          if MarhTracert[1].ObjEnd > 0 then
          begin //-------------------------- «‡‚Â¯ËÚ¸ Ì‡·Ó ÂÒÎË ÌÂÎ¸Áˇ ÔÓ‰ÓÎÊËÚ¸ Ú‡ÒÒÛ
            if (ObjZav[MarhTracert[1].ObjLast].TypeObj = 5) and  //- ÂÒÎË ˝ÚÓ ÒË„Ì‡Î Ë ...
            (MarhTracert[1].PinLast = 2) and  //------------ Ú‡ÒÒËÛÂÚÒˇ ËÁ ÚÓ˜ÍË 2 Ë ...
            not (ObjZav[MarhTracert[1].ObjLast].bParam[1] or // ÌÂÚ ÌË Ï‡ÌÂ‚Ó‚Ó„Ó ¬—, ...
            ObjZav[MarhTracert[1].ObjLast].bParam[2] or //ÌË ÓÚÍ˚ÚÓ„Ó Ï‡ÌÂ‚Ó‚Ó„Ó ÒË„Ì‡Î‡
            ObjZav[MarhTracert[1].ObjLast].bParam[3] or //------------ ÌË ÔÓÂÁ‰ÌÓ„Ó ¬— ...
            ObjZav[MarhTracert[1].ObjLast].bParam[4]) then  //---- ÌÂÚ ÓÚÍ˚ÚÓ„Ó ÔÓÂÁ‰ÌÓ„Ó
            begin
              if ObjZav[MarhTracert[1].ObjLast].bParam[5] then //----------------------- Ó
              begin //--------------------- Ã‡¯ÛÚ ÌÂ ÔËÍ˚Ú Á‡ÔÂ˘‡˛˘ËÏ Ó„ÌÂÏ ÔÓÔÛÚÌÓ„Ó
                inc(MarhTracert[1].WarCount);
                MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
                GetShortMsg(1,115, ObjZav[MarhTracert[1].ObjLast].Liter,1);
                InsWar(1,MarhTracert[1].ObjLast,115);
              end;

              case MarhTracert[1].Rod of // ÔÓ‚ÂÍ‡ ÓÚÍ˚ÚËˇ ‚ÔÂÂ‰Ë ÒÚÓˇ˘Â„Ó ÒË„Ì‡Î‡ ÂÒÎË ÍÓÓÚÍËÈ ·ÎÓÍ-Û˜‡ÒÚÓÍ
                MarshP :
                begin
                  if ObjZav[MarhTracert[1].ObjLast].ObjConstB[19] and
                  not ObjZav[MarhTracert[1].ObjLast].bParam[4] then
                  begin
                    InsArcNewMsg(MarhTracert[1].ObjLast,391,1);
                    ShowShortMsg(391,LastX,LastY,ObjZav[MarhTracert[1].ObjLast].Liter);
                    exit;
                  end;
                end;

                MarshM :
                begin
                  if ObjZav[MarhTracert[1].ObjLast].ObjConstB[20] and
                  not ObjZav[MarhTracert[1].ObjLast].bParam[2] then
                  begin
                    InsArcNewMsg(MarhTracert[1].ObjLast,391,1);
                    ShowShortMsg(391,LastX,LastY,ObjZav[MarhTracert[1].ObjLast].Liter);
                    exit;
                  end;
                end;
                else result := false; exit;
              end;
            end;

            // œÓ‚ÂËÚ¸ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ Ì‡ ÓÚÒÛÚÒÚ‚ËÂ ÔÓÂÁ‰‡ Ì‡ ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı
            if FindIzvStrelki(MarhTracert[1].ObjStart, MarhTracert[1].Rod) then
            begin
              inc(MarhTracert[1].WarCount);
              MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
              GetShortMsg(1,333, ObjZav[MarhTracert[1].ObjStart].Liter,7);
              InsWar(1,MarhTracert[1].ObjStart,333);
            end;

            MarhTracert[1].TailMsg := tm; //----- ‚ÓÒÒÚ‡ÌÓ‚ËÚ¸ ÒÓÓ·˘ÂÌËÂ ‚ ı‚ÓÒÚÂ Ï‡¯ÛÚ‡

            if MarhTracert[1].WarCount > 0 then
            begin //------------------------------------------------- ¬˚‚Ó‰ ÔÂ‰ÛÔÂÊ‰ÂÌËÈ
             SingleBeep := true;
{$IFNDEF TABLO}
              TimeLockCmdDsp := LastTime;
{$ENDIF}
              LockCommandDsp := true;
              CreateDspMenu(KeyMenu_ReadyWarningTrace,LastX,LastY);
            end
            else CreateDspMenu(CmdMarsh_Ready,LastX,LastY);

            MarhTracert[1].Finish := true;
          end else
          begin
            MarhTracert[1].TailMsg := tm; // ‚ÓÒÒÚ‡ÌÓ‚ËÚ¸ ÒÓÓ·˘ÂÌËÂ ‚ ı‚ÓÒÚÂ Ï‡¯ÛÚ‡
            InsArcNewMsg(MarhTracert[1].ObjStart,1,7); //- "ÔÓ‰ÓÎÊ‡ÈÚÂ Ì‡·Ó Ï‡¯ÛÚ‡ ÓÚ"
            ShowShortMsg(1, LastX, LastY, ObjZav[MarhTracert[1].ObjStart].Liter);
          end;
        end;
      end else
      begin
        InsArcNewMsg(MarhTracert[1].ObjStart,180,7);
        RestorePrevTrace;
        result := false;
        ShowShortMsg(180, LastX, LastY, ObjZav[MarhTracert[1].ObjStart].Liter);
      end;
    end
    else result := false;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.NextToTracertMarshrut]'); result := false;
  end;
end;
{$ENDIF}
//========================================================================================
function StepTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte) : TTracertResult;
//----------------------------------------------------------------- Œ·‡·ÓÚÍ‡ ¯‡„‡ ÔÓ ·‡ÁÂ
//-------------------------------- Con:TOZNeighbour -  Ò‚ˇÁ¸ Ò ÒÓÒÂ‰ÓÏ, ÓÚ ÍÓÚÓÓ„Ó ÔË¯ÎË
//--------------------------------------- Lvl:TTracertLevel ---- ˝Ú‡Ô Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡
//------------------------------------------------------------ Rod:Byte ----- ÚËÔ Ï‡¯ÛÚ‡
//------------------------------------------ Group:Byte ÌÓÏÂ Ï‡¯ÛÚ‡ ‚ ÒÔËÒÍÂ Á‡‰‡‚‡ÂÏ˚ı

var
  //o,j,k,m : integer;
  //tr,p : boolean;
  jmp : TOZNeighbour;
begin
try
  result := trStop;
  case Lvl of
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    tlVZavTrace, //----------- œÓ‚ÂÍ‡ ‚Á‡ËÏÓÁ‡‚ËÒËÏÓÒÚÂÈ ÔÓ Ú‡ÒÒÂ (Óı‡ÌÌÓÒÚË Ë ÔÓ˜ÂÂ)
    tlCheckTrace,//----------------------------- ÔÓ‚ÂÍ‡ ‚‡Ê‰Â·ÌÓÒÚÂÈ ÔÓ Ú‡ÒÒÂ Ï‡¯ÛÚ‡
    tlZamykTrace : // Á‡Ï˚Í‡ÌËÂ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡, Ò·Ó ÔÓÎÓÊÂÌËˇ ÓÚÍÎÓÌˇ˛˘Ëı ÒÚÂÎÓÍ Ú‡ÒÒ˚
    begin //-------------------------------------------------- ÔÓ‚ÂÍ‡ ˆÂÎÓÒÚÌÓÒÚË Ú‡ÒÒ˚
      if MarhTracert[Group].CIndex <= MarhTracert[Group].Counter then  //--- ÂÒÎË ÌÂ ÍÓÌÂˆ
      begin
         //-------------------- Ó·˙ÂÍÚ ÌÂ ÓÚÌÓÒËÚÒˇ Í Ú‡ÒÒÂ
        if Con.Obj <> MarhTracert[Group].ObjTrace[MarhTracert[Group].CIndex]
        then exit; //---------------------------------------------- ÓÒÚ‡ÌÓ‚ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ
      end else
      if MarhTracert[Group].CIndex = MarhTracert[Group].Counter+1 then //--- ÂÒÎË Á‡ ÍÓÌÂˆ
      if Con.Obj <> MarhTracert[Group].ObjEnd //------------------- Ó·˙ÂÍÚ ÌÂ ı‚ÓÒÚ Ú‡ÒÒ˚
      then exit; //------------------------------------------------ ÓÒÚ‡ÌÓ‚ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ
    end;
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    tlStepBack : //------------------------------------------------- ÓÚÍ‡Ú Ì‡Á‡‰ ÔÓ Ú‡ÒÒÂ
    begin
      jmp := Con; //------------------------------------ œË ÓÚÍ‡ÚÂ ÔÂÂ¯‡„ÌÛÚ¸ Ó·˙ÂÍÚ˚ ƒÁ
      case ObjZav[jmp.Obj].TypeObj of
        27,29 :
        begin
          if jmp.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trStop; //---------------------------------- ÍÓÌÂˆ ‡ÈÓÌ‡
              LnkEnd : result := trStop; //---------------------------------- ÍÓÌÂˆ ÒÚÓÍË
              else  result := trNextStep;  //------------------------- ËÌ‡˜Â ¯‡„‡Ú¸ ‰‡Î¸¯Â
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
              else  result := trNextStep;
            end;
          end;
        end;
        else result := trStop; exit; //---------- ‰Îˇ ‰Û„Ëı Ó·˙ÂÍÚÓ‚ ÓÒÚ‡ÌÓ‚ËÚ¸Òˇ Ë ‚˚ÈÚË
      end;

      if MarhTracert[Group].Counter > 0 then
      begin
        MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter]:=0;//Ó·ÌÛÎËÚ¸ Ú‡ÒÒ-ˇ˜ÂÈÍÛ
        dec(MarhTracert[Group].Counter); //-------------- ÛÏÂÌ¸¯ËÚ¸ ˜ËÒÎÓ ˝ÎÂÏÂÌÚÓ‚ Ú‡ÒÒ˚
      end
      else result := trStop;
      exit;
    end;
  end;
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  jmp := Con; //------------------------- ‚ ÔÓÒÎÂ‰Û˛˘ËÂ ÙÛÌÍˆËË ÔÂÂ‰‡ÂÚÒˇ ÍÓÌÌÂÍÚÓ ‚ıÓ‰‡

  case ObjZav[jmp.Obj].TypeObj of
  //////////////////////////////////////////////////////////////////////////////////////
    2 : result := StepTraceStrelka(Con,Lvl,Rod,Group,jmp);
    3 : result := StepTraceSP(Con,Lvl,Rod,Group,jmp);
    4 : result := StepTracePut(Con,Lvl,Rod,Group,jmp);
    5 : result := StepTraceSvetofor(Con,Lvl,Rod,Group,jmp);
    7 : result := StepTracePriglas(Con,Lvl,Rod,Group,jmp);
   14 : result := StepTraceUKSPS(Con,Lvl,Rod,Group,jmp);
   15 : result := StepTraceAB(Con,Lvl,Rod,Group,jmp);
   16 : result := StepTraceVSN(Con,Lvl,Rod,Group,jmp);
   23 : result := StepTraceUvazManRn(Con,Lvl,Rod,Group,jmp);
   24 : result := StepTraceZaprosPoezdOtpr(Con,Lvl,Rod,Group,jmp);
   26 : result := StepTracePAB(Con,Lvl,Rod,Group,jmp);
   27 : result := StepTraceDZOhr(Con,Lvl,Rod,Group,jmp);
   28 : result := StepTraceIzvPer(Con,Lvl,Rod,Group,jmp);
   29 : result := StepTraceDZSP(Con,Lvl,Rod,Group,jmp);
   30 : result := StepTracePoezdSogl(Con,Lvl,Rod,Group,jmp);
   32 : result := StepTraceUvazGor(Con,Lvl,Rod,Group,jmp);
   38 : result := StepTraceMarNadvig(Con,Lvl,Rod,Group,jmp);
   41 : result := StepTraceMarshOtpr(Con,Lvl,Rod,Group,jmp);
   42 : result := StepTracePerezamStrInPut(Con,Lvl,Rod,Group,jmp);
   43 : result := StepTraceOPI(Con,Lvl,Rod,Group,jmp);
   45 : result := StepTraceZonaOpov(Con,Lvl,Rod,Group,jmp);
   else result := StepTraceProchee(Con,Lvl,Rod,Group,jmp);
  end;

  if (result = trBreak) or (lvl = tlVZavTrace) or (lvl = tlCheckTrace) or
  (lvl = tlFindIzvest) or (lvl = tlFindIzvStrel) or (lvl = tlZamykTrace)
  or (lvl = tlOtmenaMarh) then exit;

  //-- œÓ‰‚ËÌÛÚ¸ ÚÂÍÛ˘ËÈ Ó·˙ÂÍÚ ÔË ÔÓËÒÍÂ Ú‡ÒÒ˚, Â∏ ÔÓ‰ÎÂÌËË, ÓÚÍ‡ÚÂ,ÔÓ‚ÚÓÂ Ï‡¯ÛÚ‡,
  //-------------------------------------------- ‡Á‰ÂÎ¸ÌÓÏ ÓÚÍ˚ÚËË,  ÔÓ‚ÚÓÂ ‡Á‰ÂÎ¸ÌÓ„Ó
  if MarhTracert[Group].Counter < High(MarhTracert[Group].ObjTrace) then
  begin
    inc(MarhTracert[Group].Counter);
    MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter] := jmp.Obj;
  end
  else result := trStop;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.TraceStep]');
  result := trStop;
end;
end;
//========================================================================================
function SoglasieOG(Index : SmallInt) : Boolean;
//------------------------------- œÓ‚ÂËÚ¸ ‚ÓÁÏÓÊÌÓÒÚ¸ ‚˚‰‡˜Ë ÒÓ„Î‡ÒËˇ Ì‡ Ó„‡Ê‰ÂÌËÂ ÔÛÚË
var
  i,o,p,j : integer;
begin
try
  j := ObjZav[Index].UpdateObject; // ËÌ‰ÂÍÒ Ó·˙ÂÍÚ‡ Ó„‡Ê‰ÂÌËˇ ÔÛÚË
  if j > 0 then
  begin
    result := ObjZav[j].bParam[1]; // ≈ÒÚ¸ Á‡ÔÓÒ Ì‡ Ó„‡Ê‰ÂÌËÂ
    // ÔÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÓ 1-ÓÈ ÚÓ˜ÍÂ
    o := ObjZav[Index].Neighbour[1].Obj; p := ObjZav[Index].Neighbour[1].Pin; i := 100;
    while i > 0 do
    begin
      case ObjZav[o].TypeObj of
        2 : begin // ÒÚÂÎÍ‡
          case p of
            2 : begin // ¬ıÓ‰ ÔÓ ÔÎ˛ÒÛ
              if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then break; // ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÏËÌÛÒÛ
            end;
            3 : begin // ¬ıÓ‰ ÔÓ ÏËÌÛÒÛ
              if ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then break; // ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÔÎ˛ÒÛ
            end;
          else
            result := false; break; // Ó¯Ë·Í‡ ‚ ÓÔËÒ‡ÌËË Á‡‚ËÒËÏÓÒÚÂÈ - ÓÚÒÛÚÒÚ‚ÛÂÚ —œ ‚ Ó·˘ÂÈ ÚÓ˜ÍÂ
          end;
          p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
        end;

        3 : begin // Û˜‡ÒÚÓÍ
          result := ObjZav[o].bParam[2]; // Á‡Ï˚Í‡ÌËÂ Û˜‡ÒÚÍ‡
          break;
        end;
      else
        if p = 1 then begin p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj; end
        else begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end;
      end;
      if (o = 0) or (p < 1) then break;
      dec(i);
    end;
    if not result then exit;
    // ÔÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÓ 2-ÓÈ ÚÓ˜ÍÂ
    o := ObjZav[Index].Neighbour[2].Obj; p := ObjZav[Index].Neighbour[2].Pin; i := 100;
    while i > 0 do
    begin
      case ObjZav[o].TypeObj of
        2 : begin // ÒÚÂÎÍ‡
          case p of
            2 : begin // ¬ıÓ‰ ÔÓ ÔÎ˛ÒÛ
              if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then break; // ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÏËÌÛÒÛ
            end;
            3 : begin // ¬ıÓ‰ ÔÓ ÏËÌÛÒÛ
              if ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then break; // ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÔÎ˛ÒÛ
            end;
          else
            result := false; break; // Ó¯Ë·Í‡ ‚ ÓÔËÒ‡ÌËË Á‡‚ËÒËÏÓÒÚÂÈ - ÓÚÒÛÚÒÚ‚ÛÂÚ —œ ‚ Ó·˘ÂÈ ÚÓ˜ÍÂ
          end;
          p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
        end;

        3 : begin // Û˜‡ÒÚÓÍ
          result := ObjZav[o].bParam[2]; // Á‡Ï˚Í‡ÌËÂ Û˜‡ÒÚÍ‡
          break;
        end;
      else
        if p = 1 then begin p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj; end
        else begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end;
      end;
      if (o = 0) or (p < 1) then break;
      dec(i);
    end;

    // Á‡ÔÂÚËÚ¸ ‚˚‰‡˜Û Ó„‡Ê‰ÂÌËˇ ÔË ÏÂÒÚÌÓÏ ÛÔ‡‚ÎÂÌËË
    o := ObjZav[j].ObjConstI[18];
    if result and (o > 0) then
    begin
      if not ObjZav[ObjZav[o].BaseObject].bParam[3] then
      begin
        result := false;
      end;
    end;
    o := ObjZav[j].ObjConstI[19];
    if result and (o > 0) then
    begin
      if not ObjZav[ObjZav[o].BaseObject].bParam[3] then
      begin
        result := false;
      end;
    end;
  end else
  begin
    result := false;
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.SoglasieOG]');
  result := false;
end;
end;
//========================================================================================
function CheckOgrad(ptr : SmallInt; Group : Byte) : Boolean;
//------ ÔÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÛÚË ˜ÂÂÁ ¬Á ÒÚÂÎÍË ÔË ÔÓ‚ÂÍÂ ‚‡Ê‰Â·ÌÓÒÚÂÈ Ú‡ÒÒËÓ‚ÍË
var
  i,o,p : integer;
begin
try
  result := true;
  for i := 1 to 10 do
    if ObjZav[Ptr].ObjConstI[i] > 0 then
    begin
      case ObjZav[ObjZav[Ptr].ObjConstI[i]].TypeObj of
        6 : begin // Œ„‡Ê‰ÂÌËÂ ÔÛÚË
          for p := 14 to 17 do
          begin
            if ObjZav[ObjZav[Ptr].ObjConstI[i]].ObjConstI[p] = Ptr then
            begin
              o := ObjZav[Ptr].ObjConstI[i];
              if ObjZav[o].bParam[2] then
              begin // ”ÒÚ‡ÌÓ‚ÎÂÌÓ Ó„‡Ê‰ÂÌËÂ ÔÛÚË
                if (not MarhTracert[Group].Povtor and (ObjZav[Ptr].bParam[10] and not ObjZav[Ptr].bParam[11]) or ObjZav[Ptr].bParam[12]) or
                   (MarhTracert[Group].Povtor and (ObjZav[Ptr].bParam[6] and not ObjZav[Ptr].bParam[7])) then
                begin // —ÚÂÎÍ‡ ÌÛÊÌ‡ ‚ ÔÎ˛ÒÂ
                  if not ObjZav[o].ObjConstB[p*2-27] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,145, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,145);
                    result := false;
                  end;
                end else
                if (not MarhTracert[Group].Povtor and (ObjZav[Ptr].bParam[10] and ObjZav[Ptr].bParam[11]) or ObjZav[Ptr].bParam[13]) or
                   (MarhTracert[Group].Povtor and (not ObjZav[Ptr].bParam[6] and ObjZav[Ptr].bParam[7])) then
                begin // —ÚÂÎÍ‡ ÌÛÊÌ‡ ‚ ÏËÌÛÒÂ
                  if not ObjZav[o].ObjConstB[p*2-26] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,145, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,145);
                    result := false;
                  end;
                end;
              end;
            end;
          end;
        end; //6
      end; //case
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.CheckOgrad]');
  result := false;
end;
end;
//========================================================================================
function CheckOtpravlVP(ptr : SmallInt; Group : Byte) : Boolean;
//----------------- ÔÓ‚ÂËÚ¸ ÛÒÚ‡ÌÓ‚ÍÛ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ Ò ÔÛÚË Ò ÔËÏ˚Í‡˛˘ÂÈ ÒÚÂÎÍÓÈ
//-------------------- ˜ÂÂÁ ı‚ÓÒÚ ÒÚÂÎÍË ÔË ÔÓ‚ÂÍÂ ‚‡Ê‰Â·ÌÓÒÚÂÈ Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡
var
  i,j,o,p : integer;
begin
try
  result := true;
  for i := 14 to 19 do
  begin
    p := ObjZav[ObjZav[Ptr].BaseObject].ObjConstI[i];
    if p > 0 then
    begin
      case ObjZav[p].TypeObj of
        41 : begin //----------------------  ÓÌÚÓÎ¸ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ Ò ÔÛÚË
          if ObjZav[p].bParam[20] then
          begin
            for j := 1 to 4 do
            begin
              o := ObjZav[p].ObjConstI[j];
              if o = ptr then
              begin //---------- ÔÓ‚ÂËÚ¸ ÚÂ·ÛÂÏÓÂ ÔÓÎÓÊÂÌËÂ ÒÚÂÎÍË ‰Îˇ Ó·ÓËı Ï‡¯ÛÚÓ‚
                if (not MarhTracert[Group].Povtor and
                (ObjZav[Ptr].bParam[10] and not ObjZav[Ptr].bParam[11])
                or ObjZav[Ptr].bParam[12]) or
                (MarhTracert[Group].Povtor and (ObjZav[Ptr].bParam[6]
                and not ObjZav[Ptr].bParam[7])) then
                begin //-------------------------------------------- —ÚÂÎÍ‡ ÌÛÊÌ‡ ‚ ÔÎ˛ÒÂ
                  if not ObjZav[p].ObjConstB[(j-1)*3+3] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,478, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,478);
                    result := false;
                  end;
                end else
                if (not MarhTracert[Group].Povtor and
                (ObjZav[Ptr].bParam[10] and ObjZav[Ptr].bParam[11])
                or ObjZav[Ptr].bParam[13]) or
                (MarhTracert[Group].Povtor and (not ObjZav[Ptr].bParam[6]
                and ObjZav[Ptr].bParam[7])) then
                begin //------------------------------------------- —ÚÂÎÍ‡ ÌÛÊÌ‡ ‚ ÏËÌÛÒÂ
                  if not ObjZav[p].ObjConstB[(j-1)*3+4] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,478, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,478);
                    result := false;
                  end;
                end;
              end;
            end;
          end;
        end; //41
      end; //case
    end; // for
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.CheckOtpravlVP]');
  result := false;
end;
end;
//========================================================================================
function SignCircOgrad(ptr : SmallInt; Group : Byte) : Boolean;
// ÔÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÛÚË ˜ÂÂÁ ¬Á ÒÚÂÎÍË ÔË ÔÓ‚ÂÍÂ ‚‡Ê‰Â·ÌÓÒÚÂÈ ÒË„Ì‡Î¸ÌÓÈ ÒÚÛÌ˚
var
  i,o,p : integer;
begin
try
  result := true;
  for i := 1 to 10 do
    if ObjZav[Ptr].ObjConstI[i] > 0 then
    begin
      case ObjZav[ObjZav[Ptr].ObjConstI[i]].TypeObj of
        6 : begin //------------------------------------------------------ Œ„‡Ê‰ÂÌËÂ ÔÛÚË
          for p := 14 to 17 do
          begin
            if ObjZav[ObjZav[Ptr].ObjConstI[i]].ObjConstI[p] = Ptr then
            begin
              o := ObjZav[Ptr].ObjConstI[i];
              if ObjZav[o].bParam[2] then
              begin //---------------------------------------- ”ÒÚ‡ÌÓ‚ÎÂÌÓ Ó„‡Ê‰ÂÌËÂ ÔÛÚË
                if ObjZav[ObjZav[Ptr].BaseObject].bParam[1] then
                begin //-------------------------------------------- —ÚÂÎÍ‡ ÌÛÊÌ‡ ‚ ÔÎ˛ÒÂ
                  if not ObjZav[o].ObjConstB[p*2-27] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,145, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,145);
                    result := false;
                  end;
                end else
                if ObjZav[ObjZav[Ptr].BaseObject].bParam[2] then
                begin // —ÚÂÎÍ‡ ÌÛÊÌ‡ ‚ ÏËÌÛÒÂ
                  if not ObjZav[o].ObjConstB[p*2-26] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,145, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,145);
                    result := false;
                  end;
                end;
              end;
            end;
          end;
        end; //6
      end; //case
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.SignCircOgrad]');
  result := false;
end;
end;
//========================================================================================
function SignCircOtpravlVP(ptr : SmallInt; Group : Byte) : Boolean;
//----------------- ÔÓ‚ÂËÚ¸ ÛÒÚ‡ÌÓ‚ÍÛ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ Ò ÔÛÚË Ò ÔËÏ˚Í‡˛˘ÂÈ ÒÚÂÎÍÓÈ
//----------------------- ˜ÂÂÁ ı‚ÓÒÚ ÒÚÂÎÍË ÔË ÔÓ‚ÂÍÂ ‚‡Ê‰Â·ÌÓÒÚÂÈ ÒË„Ì‡Î¸ÌÓÈ ÒÚÛÌ˚
var
  i,j,o,p : integer;
begin
try
  result := true;
  for i := 14 to 19 do
  begin
    p := ObjZav[ObjZav[Ptr].BaseObject].ObjConstI[i];
    if p > 0 then
    begin
      case ObjZav[p].TypeObj of
        41 :
        begin //---------------------------  ÓÌÚÓÎ¸ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ Ò ÔÛÚË
          if ObjZav[p].bParam[20] then
          begin
            for j := 1 to 4 do
            begin
              o := ObjZav[p].ObjConstI[j];
              if o = ptr then
              begin //---------- ÔÓ‚ÂËÚ¸ ÚÂ·ÛÂÏÓÂ ÔÓÎÓÊÂÌËÂ ÒÚÂÎÍË ‰Îˇ Ó·ÓËı Ï‡¯ÛÚÓ‚
                if ObjZav[ObjZav[Ptr].BaseObject].bParam[1] then
                begin //-------------------------------------------- —ÚÂÎÍ‡ ÌÛÊÌ‡ ‚ ÔÎ˛ÒÂ
                  if not ObjZav[p].ObjConstB[(j-1)*3+3] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,478, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,478);
                    result := false;
                  end;
                end else
                if ObjZav[ObjZav[Ptr].BaseObject].bParam[2] then
                begin //------------------------------------------- —ÚÂÎÍ‡ ÌÛÊÌ‡ ‚ ÏËÌÛÒÂ
                  if not ObjZav[p].ObjConstB[(j-1)*3+4] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,478, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,478);
                    result := false;
                  end;
                end;
              end;
            end;
          end;
        end; //41
      end; //case
    end; // for
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.SignCircOtpravlVP]');
  result := false;
end;
end;
//========================================================================================
function NegStrelki(ptr : SmallInt; pk : Boolean; Group : Byte) : Boolean;
//---------------------------------------------------------------- œÓ‚ÂÍ‡ ÌÂ„‡·‡ËÚÌÓÒÚË
//-------------------------------------------------------------------------  ptr - ÒÚÂÎÍ‡
//------------------------------------------------------- pk - ÁÌ‡˜ÂÌËÂ ‰‡Ú˜ËÍ‡ œ  ÒÚÂÎÍË
//----------------------------------------- Group - ÍÓÏÔÎÂÍÚ ÛÔ‡‚ÎÂÌËˇ ‰Îˇ ‰‡ÌÌÓÈ ÒÚÂÎÍË
var
  i,o,p : integer;
begin
  try
    result := true;
    //-------------------- »ÒÍ‡Ú¸ ÌÂ„‡·‡ËÚÌÓÒÚ¸ ˜ÂÂÁ ÒÚ˚Í Ë ÓÚ‚Â‰ÂÌÌÓÂ ÔÓÎÓÊÂÌËÂ ÒÚÂÎÓÍ
    if pk then
    begin //-------------------------------------------------------------- ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
      if (ObjZav[Ptr].Neighbour[3].TypeJmp = LnkNeg) or //-------------- ÌÂ„‡·‡ËÚÌ˚È ÒÚ˚Í
      (ObjZav[Ptr].ObjConstB[8]) then //-------- ËÎË ÔÓ‚ÂÍ‡ ÓÚ‚Ó‰ˇ˘Â„Ó ÔÓÎÓÊÂÌËˇ ÒÚÂÎÓÍ
      begin //--------------------------------------------------- ÔÓ ÏËÌÛÒÓ‚ÓÏÛ ÔËÏ˚Í‡ÌË˛
        o := ObjZav[Ptr].Neighbour[3].Obj; //----------------------- Ó·˙ÂÍÚ Á‡ ÓÚÍÎÓÌÂÌËÂÏ
        p := ObjZav[Ptr].Neighbour[3].Pin; //--------------------------- ÚÓ˜Í‡ ÔÓ‰ÍÎ˛˜ÂÌËˇ
        i := 100;
        while i > 0 do
        begin
          case ObjZav[o].TypeObj of
            2 :   //-------------------------------------------------------------- ÒÚÂÎÍ‡
            begin
              case p of
                2 :   //--------------------------------------------------- ¬ıÓ‰ ÔÓ ÔˇÏÓÈ
                if ObjZav[o].bParam[2] then break; //---------- ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÏËÌÛÒÛ

                3 : //------------------------------------------------  ¬ıÓ‰ ÔÓ ÓÚÍÎÓÌÂÌË˛
                if ObjZav[o].bParam[1] then break; //----------- ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÔÎ˛ÒÛ

                else  ObjZav[Ptr].bParam[3] := false; break; //------ Ó¯Ë·Í‡ ‚ ·‡ÁÂ ‰‡ÌÌ˚ı
              end;
              p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
            end;

            3,4 :  //-------------------------------------------------------- Û˜‡ÒÚÓÍ,ÔÛÚ¸
            begin
              if not ObjZav[o].bParam[1] then //--------------- Á‡ÌˇÚÓÒÚ¸ ÔÛÚÂ‚Ó„Ó ‰‡Ú˜ËÍ‡
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,146, ObjZav[o].Liter,1);
                InsMsg(Group,o,146);
                result := false;
              end;
              break;
            end;

            else
            if p = 1 then
            begin
              p := ObjZav[o].Neighbour[2].Pin;
              o := ObjZav[o].Neighbour[2].Obj;
            end else
            begin
              p := ObjZav[o].Neighbour[1].Pin;
              o := ObjZav[o].Neighbour[1].Obj;
            end;
        end;
        if (o = 0) or (p < 1) then break;
        dec(i);
      end;
    end;
  end else
  begin  //-------------------------------------------------------------- ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
    if (ObjZav[Ptr].Neighbour[2].TypeJmp = LnkNeg) or //---------------- ÌÂ„‡·‡ËÚÌ˚È ÒÚ˚Í
    (ObjZav[Ptr].ObjConstB[7]) then    //------- ËÎË ÔÓ‚ÂÍ‡ ÓÚ‚Ó‰ˇ˘Â„Ó ÔÓÎÓÊÂÌËˇ ÒÚÂÎÓÍ
    begin //------------------------------------------------------ ÔÓ ÔÎ˛ÒÓ‚ÓÏÛ ÔËÏ˚Í‡ÌË˛
      o := ObjZav[Ptr].Neighbour[2].Obj;
      p := ObjZav[Ptr].Neighbour[2].Pin;
      i := 100;
      while i > 0 do
      begin
        case ObjZav[o].TypeObj of
          2 :
          begin //---------------------------------------------------------------- ÒÚÂÎÍ‡
            case p of
              2 :
              begin //------------------------------------------------------ ¬ıÓ‰ ÔÓ ÔÎ˛ÒÛ
                if ObjZav[o].bParam[2] then break; //---------- ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÏËÌÛÒÛ
              end;
              3 :
              begin //----------------------------------------------------- ¬ıÓ‰ ÔÓ ÏËÌÛÒÛ
                if ObjZav[o].bParam[1] then break; //----------- ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÔÎ˛ÒÛ
              end;
              else ObjZav[Ptr].bParam[3] := false; break; //--------- Ó¯Ë·Í‡ ‚ ·‡ÁÂ ‰‡ÌÌ˚ı
            end;
            p := ObjZav[o].Neighbour[1].Pin;
            o := ObjZav[o].Neighbour[1].Obj;
          end;

          3,4 :
          begin //----------------------------------------------------------- Û˜‡ÒÚÓÍ,ÔÛÚ¸
            if not ObjZav[o].bParam[1] then //----------------- Á‡ÌˇÚÓÒÚ¸ ÔÛÚÂ‚Ó„Ó ‰‡Ú˜ËÍ‡
            begin
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,146, ObjZav[o].Liter,1);
              InsMsg(Group,o,146);
              result := false;
            end;
            break;
          end;

          else
          if p = 1 then
          begin
            p := ObjZav[o].Neighbour[2].Pin;
            o := ObjZav[o].Neighbour[2].Obj;
          end else
          begin
            p := ObjZav[o].Neighbour[1].Pin;
            o := ObjZav[o].Neighbour[1].Obj;
          end;
        end;
        if (o = 0) or (p < 1) then break;
        dec(i);
      end;
    end;
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.NegStrelki]');
  result := false;
end;
end;
//========================================================================================
function SigCircNegStrelki(ptr : SmallInt; pk : Boolean; Group : Byte) : Boolean;
//------------------------------------------ œÓ‚ÂÍ‡ ÌÂ„‡·‡ËÚÌÓÒÚË ‰Îˇ ÒË„Ì‡Î¸ÌÓÈ ÒÚÛÌ˚
var
  i,o,p : integer;
begin
  try
    result := true;
    //-------------------- »ÒÍ‡Ú¸ ÌÂ„‡·‡ËÚÌÓÒÚ¸ ˜ÂÂÁ ÒÚ˚Í Ë ÓÚ‚Â‰ÂÌÌÓÂ ÔÓÎÓÊÂÌËÂ ÒÚÂÎÓÍ
    if pk then
    begin //---------------------------------------------------------------- ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
      if (ObjZav[Ptr].Neighbour[3].TypeJmp = LnkNeg) or //---------------- ÌÂ„‡·‡ËÚÌ˚È ÒÚ˚Í
      (ObjZav[Ptr].ObjConstB[8]) then //---------- ËÎË ÔÓ‚ÂÍ‡ ÓÚ‚Ó‰ˇ˘Â„Ó ÔÓÎÓÊÂÌËˇ ÒÚÂÎÓÍ
      begin //ÔÓ ÏËÌÛÒÓ‚ÓÏÛ ÔËÏ˚Í‡ÌË˛
        o := ObjZav[Ptr].Neighbour[3].Obj;
        p := ObjZav[Ptr].Neighbour[3].Pin;
        i := 100;
        while i > 0 do
        begin
          case ObjZav[o].TypeObj of
            2 :
            begin // ÒÚÂÎÍ‡
              case p of
                2 :
                begin // ¬ıÓ‰ ÔÓ ÔÎ˛ÒÛ
                  if ObjZav[o].bParam[2] then break; // ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÏËÌÛÒÛ
                end;

                3 :
                begin // ¬ıÓ‰ ÔÓ ÏËÌÛÒÛ
                  if ObjZav[o].bParam[1] then break; // ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÔÎ˛ÒÛ
                end;

                else  ObjZav[Ptr].bParam[3] := false; break; // Ó¯Ë·Í‡ ‚ ·‡ÁÂ ‰‡ÌÌ˚ı
              end;
              p := ObjZav[o].Neighbour[1].Pin;
              o := ObjZav[o].Neighbour[1].Obj;
            end;

            3,4 :
            begin // Û˜‡ÒÚÓÍ,ÔÛÚ¸
              if not ObjZav[o].bParam[1] then // Á‡ÌˇÚÓÒÚ¸ ÔÛÚÂ‚Ó„Ó ‰‡Ú˜ËÍ‡
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,146, ObjZav[o].Liter,1); InsMsg(Group,o,146);
                result := false;
              end;
              break;
            end;
            else
              if p = 1 then
              begin
                p := ObjZav[o].Neighbour[2].Pin;
                o := ObjZav[o].Neighbour[2].Obj;
              end else
              begin
                p := ObjZav[o].Neighbour[1].Pin;
                o := ObjZav[o].Neighbour[1].Obj;
              end;
          end;
          if (o = 0) or (p < 1) then break;
          dec(i);
        end;
      end;
    end else
    begin // ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
      if (ObjZav[Ptr].Neighbour[2].TypeJmp = LnkNeg) or // ÌÂ„‡·‡ËÚÌ˚È ÒÚ˚Í
      (ObjZav[Ptr].ObjConstB[7]) then         // ËÎË ÔÓ‚ÂÍ‡ ÓÚ‚Ó‰ˇ˘Â„Ó ÔÓÎÓÊÂÌËˇ ÒÚÂÎÓÍ
      begin //ÔÓ ÔÎ˛ÒÓ‚ÓÏÛ ÔËÏ˚Í‡ÌË˛
        o := ObjZav[Ptr].Neighbour[2].Obj;
        p := ObjZav[Ptr].Neighbour[2].Pin;
        i := 100;
        while i > 0 do
        begin
          case ObjZav[o].TypeObj of
            2 :
            begin // ÒÚÂÎÍ‡
              case p of
                2 :
                begin // ¬ıÓ‰ ÔÓ ÔÎ˛ÒÛ
                  if ObjZav[o].bParam[2] then break; // ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÏËÌÛÒÛ
                end;
                3 :
                begin // ¬ıÓ‰ ÔÓ ÏËÌÛÒÛ
                  if ObjZav[o].bParam[1] then break; // ÒÚÂÎÍ‡ ‚ ÓÚ‚Ó‰Â ÔÓ ÔÎ˛ÒÛ
                end;
                else ObjZav[Ptr].bParam[3] := false; break; // Ó¯Ë·Í‡ ‚ ·‡ÁÂ ‰‡ÌÌ˚ı
              end;
              p := ObjZav[o].Neighbour[1].Pin;
              o := ObjZav[o].Neighbour[1].Obj;
            end;

            3,4 :
            begin // Û˜‡ÒÚÓÍ,ÔÛÚ¸
              if not ObjZav[o].bParam[1] then // Á‡ÌˇÚÓÒÚ¸ ÔÛÚÂ‚Ó„Ó ‰‡Ú˜ËÍ‡
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,146, ObjZav[o].Liter,1);
                InsMsg(Group,o,146);
                result := false;
              end;
              break;
            end;

            else
            if p = 1 then
            begin
              p := ObjZav[o].Neighbour[2].Pin;
              o := ObjZav[o].Neighbour[2].Obj;
            end else
            begin
              p := ObjZav[o].Neighbour[1].Pin;
              o := ObjZav[o].Neighbour[1].Obj;
            end;
          end;
          if (o = 0) or (p < 1) then break;
          dec(i);
        end;
      end;
    end;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.SigCircNegStrelki]');
    result := false;
  end;
end;
//========================================================================================
function VytajkaRM(ptr : SmallInt) : Boolean;
//------------------------------------------ œÓ‚ÂÍ‡ ÛÒÎÓ‚ËÈ ÔÂÂ‰‡˜Ë Ì‡ Ï‡ÌÂ‚Ó‚˚È ‡ÈÓÌ
var
  i,j,g,o,p,q : Integer;
  b,opi : boolean;
begin
try
  result := false;
  MarhTracert[1].MsgCount := 0; MarhTracert[1].WarCount := 0;
  if ptr < 1 then exit;

  // ÔÓ‰Ò‚ÂÚËÚ¸ ÔÛÚË
  g := ObjZav[ptr].ObjConstI[15];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          4  : ObjZav[o].bParam[8] := false;
          43 : begin // Ó·˙ÂÍÚ Óœ»
            if not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
            begin // ÔÛÚ¸ ‡ÁÂ¯ÂÌ ‰Îˇ Ï‡ÌÂ‚Ó‚
              ObjZav[ObjZav[o].UpdateObject].bParam[8] := false;
            end;
          end;
        end;
      end;
    end;
  end;
  // ÔÓ‰Ò‚ÂÚËÚ¸ ÒÂÍˆËË
  g := ObjZav[ptr].ObjConstI[18];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          3 : ObjZav[o].bParam[8] := false;
          44 : begin // Ó·˙ÂÍÚ —Ã»
            if ObjZav[o].bParam[1] or ObjZav[o].bParam[2] then ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[8] := false;
          end;
        end;
      end;
    end;
  end;
  // ÔÓ‰Ò‚ÂÚËÚ¸ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÏËÌÛÒÂ
  g := ObjZav[ptr].ObjConstI[23];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 :
            if ObjZav[ObjZav[o].UpdateObject].bParam[7] and not ObjZav[ObjZav[o].UpdateObject].bParam[8] then
            begin
              ObjZav[o].bParam[6] := false; ObjZav[o].bParam[7] := false;
              ObjZav[o].bParam[12] := false; ObjZav[o].bParam[13] := true;
            end;
          44 : begin // —Ã»
            if ObjZav[o].bParam[2] and
               ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[7] and
               not ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[8] then
            begin
              ObjZav[ObjZav[o].UpdateObject].bParam[6] := false; ObjZav[ObjZav[o].UpdateObject].bParam[7] := false;
              ObjZav[ObjZav[o].UpdateObject].bParam[12] := false; ObjZav[ObjZav[o].UpdateObject].bParam[13] := true;
            end;
          end;
        end;
      end;
    end;
  end;
  // ÔÓ‰Ò‚ÂÚËÚ¸ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÔÎ˛ÒÂ
  g := ObjZav[ptr].ObjConstI[24];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 :
            if ObjZav[ObjZav[o].UpdateObject].bParam[7] and not ObjZav[ObjZav[o].UpdateObject].bParam[8] then
            begin
              ObjZav[o].bParam[6] := false; ObjZav[o].bParam[7] := false;
              ObjZav[o].bParam[12] := true; ObjZav[o].bParam[13] := false;
            end;
          44 : begin // —Ã»
            if ObjZav[o].bParam[1] and
               ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[7] and
               not ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[8] then
            begin
              ObjZav[ObjZav[o].UpdateObject].bParam[6] := false; ObjZav[ObjZav[o].UpdateObject].bParam[7] := false;
              ObjZav[ObjZav[o].UpdateObject].bParam[12] := true; ObjZav[ObjZav[o].UpdateObject].bParam[13] := false;
            end;
          end;
        end;
      end;
    end;
  end;
  // ÔÓ‰Ò‚ÂÚËÚ¸ ıÓ‰Ó‚˚Â ÒÚÂÎÍË Ì‡ ÛÔ‡‚ÎÂÌËË
  g := ObjZav[ptr].ObjConstI[16];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 : begin
            if ObjZav[ObjZav[o].UpdateObject].bParam[7] and not ObjZav[ObjZav[o].UpdateObject].bParam[8] then
            begin
              ObjZav[o].bParam[12] := true; ObjZav[o].bParam[13] := true;
            end;
          end;
        end;
      end;
    end;
  end;
  // ÔÓ‚ÂËÚ¸ Ó·˙ÂÍÚ˚ —Ã» ‰Îˇ ‰‡ÌÌÓÈ ÍÓÎÓÌÍË
  for i := 1 to WorkMode.LimitObjZav do
  begin
    if (ObjZav[i].TypeObj = 44) and (ObjZav[i].BaseObject = ptr) then
    begin
      if ObjZav[ObjZav[ObjZav[i].UpdateObject].UpdateObject].bParam[7] and
         not ObjZav[ObjZav[ObjZav[i].UpdateObject].UpdateObject].bParam[8] then
      begin
        ObjZav[ObjZav[i].UpdateObject].bParam[12] := ObjZav[i].bParam[1];
        ObjZav[ObjZav[i].UpdateObject].bParam[13] := ObjZav[i].bParam[2];
      end;
    end;
  end;

  // ÔÓ‚ÂËÚ¸ ÛÒÎÓ‚Ëˇ Ì‡ ÍÓÎÓÌÍÂ
  if ObjZav[ptr].bParam[6] then
  begin // ›√—
    inc(MarhTracert[1].MsgCount);
    MarhTracert[1].Msg[MarhTracert[1].MsgCount] :=
    GetShortMsg(1,105,ObjZav[ptr].Liter,1);
    InsMsg(1,ptr,105);
    exit;
  end;
  if ObjZav[ptr].bParam[1] then
  begin // –Ã
    inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,258,ObjZav[ptr].Liter,1); InsMsg(1,ptr,258); exit;
  end;
  if ObjZav[Ptr].bParam[4] then
  begin // ÂÒÎË ÔÂ‚Ë˜Ì‡ˇ ÔÂÂ‰‡˜‡ Ì‡ Ï‡ÌÂ‚˚ - ÔÓ‚ÂËÚ¸:
  // ÔÓ‚ÂËÚ¸ ‚ÓÒÔËˇÚËÂ Ï‡ÌÂ‚Ó‚ Ì‡ ÍÓÎÓÌÍÂ
    if not ObjZav[Ptr].bParam[5] then
    begin
      if ObjZav[ptr].bParam[3] then
      begin // Ï‡ÌÂ‚˚ Â˘Â ÌÂ Á‡ÏÍÌÛÚ˚
        inc(MarhTracert[1].WarCount); MarhTracert[1].Warning[MarhTracert[1].WarCount] := GetShortMsg(1,445,ObjZav[Ptr].Liter,1); InsWar(1,ptr,445);
      end;
    end;
  // ËÒÍÎ˛˜ÂÌËˇ ÔÛÚÂÈ ËÁ Ï‡ÌÂ‚Ó‚ (‡ÁÂ¯ÂÌËÂ ÔËÂÏ‡ ËÎË Ó„‡Ê‰ÂÌËˇ)
    b := false; opi := false;
    for i := 1 to WorkMode.LimitObjZav do
    begin
      if (ObjZav[i].TypeObj = 48) and (ObjZav[i].BaseObject = ptr) then
      begin
        if not ObjZav[i].ObjConstB[3] then
        begin // ÍÓÌÚÓÎËÓ‚‡Ú¸ ‚ÓÁÏÓÊÌÓÒÚ¸ ‚˚ıÓ‰‡ Ì‡ ÔÛÚË ÔËÂÏ‡ ËÁ Ï‡ÌÂ‚Ó‚Ó„Ó ‡ÈÓÌ‡
          opi := true;
          if ObjZav[i].bParam[1] then b := true;
        end;
      end;
    end;
    if opi and not b then
    begin // ‚ÒÂ ÔÛÚË ËÒÍÎ˛˜ÂÌ˚ ËÁ Ï‡ÌÂ‚Ó‚Ó„Ó ‡ÈÓÌ‡
      inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,427,ObjZav[Ptr].Liter,1); InsMsg(1,ptr,427); exit;
    end;
  end;

  // ÔÓ‚ÂËÚ¸ ‰ÓÔÓÎÌËÚÂÎ¸Ì˚Â ÛÒÎÓ‚Ëˇ ÔÂÂ‰‡˜Ë Ì‡ Ï‡ÌÂ‚˚
  g := ObjZav[ptr].ObjConstI[17];
  if g > 0 then
  begin
    for i := 1 to 5 do
    begin // ÔÓ‚ÂÍ‡ ‰ÓÔÓÎÌËÚÂÎ¸Ì˚ı ÛÒÎÓ‚ËÈ ÔÓ ÒÔËÒÍÛ
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          4 : begin // ÔÛÚ¸
            if not ObjZav[o].bParam[2] or not ObjZav[o].bParam[3] then
            begin // ÛÒÚ‡ÌÓ‚ÎÂÌ Ï‡¯ÛÚ Ì‡ ÔÛÚ¸ (ËÒÍÎ˛˜‡˛ÚÒˇ Î˛·˚Â Ï‡¯ÛÚ˚ Ì‡ ÔÛÚ¸)
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,341,ObjZav[o].Liter,1); InsMsg(1,o,341); exit;
            end;
          end;

          6 : begin // Ó„‡Ê‰ÂÌËÂ ÔÛÚË
            if ObjZav[o].bParam[2] then
            begin // Ó„‡Ê‰ÂÌËÂ ÛÒÚ‡ÌÓ‚ÎÂÌÓ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,145,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,145); exit;
            end;
          end;

          23 : begin // Û‚ˇÁÍ‡ Ò Ï‡ÌÂ‚Ó‚˚Ï ‡ÈÓÌÓÏ
            if ObjZav[o].bParam[1] then
            begin // ÂÒÚ¸ ”Ãœ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,256,ObjZav[o].Liter,1); InsMsg(1,o,256); exit;
            end else
            if ObjZav[o].bParam[2] then
            begin // ÂÒÚ¸ ”ÃŒ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,257,ObjZav[o].Liter,1); InsMsg(1,o,257); exit;
            end;
          end;

          25 : begin // Ï‡ÌÂ‚Ó‚‡ˇ ÍÓÎÓÌÍ‡
            if not ObjZav[o].bParam[1] then
            begin // ÌÂÚ ‡ÁÂ¯ÂÌËˇ Ï‡ÌÂ‚Ó‚ Ì‡ ÔÓ‚ÂˇÂÏÓÈ ÍÓÎÓÌÍÂ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,426,ObjZav[o].Liter,1); InsMsg(1,o,426); exit;
            end;
          end;

          33 : begin // ‰ËÒÍÂÚÌ˚È ‰‡Ú˜ËÍ
            if ObjZav[o].bParam[1] then
            begin
              inc(MarhTracert[1].MsgCount);
              if ObjZav[o].ObjConstB[1] then
              begin
                MarhTracert[1].Msg[MarhTracert[1].MsgCount] := MsgList[ObjZav[o].ObjConstI[3]]; InsMsg(1,o,3);
              end else
              begin
                MarhTracert[1].Msg[MarhTracert[1].MsgCount] := MsgList[ObjZav[o].ObjConstI[2]]; InsMsg(1,o,2);
              end;
              exit;
            end;
          end;

          45 :
          begin //-------------------------------------------------------- ÁÓÌ‡ ÓÔÓ‚Â˘ÂÌËˇ
            if ObjZav[o].bParam[1] then
            begin //----------------------- ¬ÍÎ˛˜ÂÌÓ ÓÔÓ‚Â˘ÂÌËÂ ‚ ÁÓÌÂ ÏÂÒÚÌÓ„Ó ÛÔ‡‚ÎÂÌËˇ
              inc(MarhTracert[1].MsgCount);
              MarhTracert[1].Msg[MarhTracert[1].MsgCount] :=
              GetShortMsg(1,444,ObjZav[o].Liter,1);
              InsMsg(1,o,444);
              exit;
            end;
          end;

        end;
      end;
    end;
  end;

  // ÔÓ‚ÂËÚ¸ ÒÂÍˆËË ‚˚ÚˇÊÍË
  g := ObjZav[ptr].ObjConstI[18];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          3 : begin
            if not ObjZav[o].bParam[2] then
            begin // ”˜‡ÒÚÓÍ Á‡ÏÍÌÛÚ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,82,ObjZav[o].Liter,1); InsMsg(1,o,82); exit;
            end;
            if not ObjZav[o].bParam[5] then
            begin // ”˜‡ÒÚÓÍ Ì‡ Ï‡ÌÂ‚‡ı
              for p := 20 to 24 do // Ì‡ÈÚË ÍÓÎÓÌÍÛ Ò Á‡ÏÍÌÛÚ˚ÏË Ï‡ÌÂ‚‡ÏË
                if (ObjZav[o].ObjConstI[p] > 0) and (ObjZav[o].ObjConstI[p] <> ptr) then
                begin
                  if not ObjZav[ObjZav[o].ObjConstI[p]].bParam[3] then
                  begin
                    inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,258,ObjZav[ObjZav[o].ObjConstI[p]].Liter,1); InsMsg(1,ObjZav[o].ObjConstI[p],258); exit;
                  end;
                end;
            end;
            if not ObjZav[o].bParam[7] then
            begin // ”˜‡ÒÚÓÍ Á‡ÏÍÌÛÚ Ì‡ ÒÂ‚ÂÂ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,110,ObjZav[o].Liter,1); InsMsg(1,o,110); exit;
            end;
          end;
          44 : begin // —Ã»
            if not ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[2] then
            begin // ”˜‡ÒÚÓÍ Á‡ÏÍÌÛÚ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,82,ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].UpdateObject,82); exit;
            end;
            if not ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[5] then
            begin // ”˜‡ÒÚÓÍ Ì‡ Ï‡ÌÂ‚‡ı
              for p := 20 to 24 do // Ì‡ÈÚË ÍÓÎÓÌÍÛ Ò Á‡ÏÍÌÛÚ˚ÏË Ï‡ÌÂ‚‡ÏË
                if (ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].ObjConstI[p] > 0) and (ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].ObjConstI[p] <> ptr) then
                begin
                  if not ObjZav[ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].ObjConstI[p]].bParam[3] then
                  begin
                    inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,258,ObjZav[ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].ObjConstI[p]].Liter,1); InsMsg(1,ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].ObjConstI[p],258); exit;
                  end;
                end;
            end;
            if not ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[7] then
            begin // ”˜‡ÒÚÓÍ Á‡ÏÍÌÛÚ Ì‡ ÒÂ‚ÂÂ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,110,ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].UpdateObject,110); exit;
            end;
          end;
        end;
      end;
    end;
  end;

  // ÔÓ‚ÂËÚ¸ Ò‚ÂÚÓÙÓ˚ ‚˚ÚˇÊÍË
  g := ObjZav[ptr].ObjConstI[20];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        if ObjZav[o].bParam[1] or ObjZav[o].bParam[2] or ObjZav[o].bParam[3] or ObjZav[o].bParam[4] then
        begin // ÒË„Ì‡Î ÓÚÍ˚Ú
          inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,114,ObjZav[o].Liter,1); InsMsg(1,o,114); exit;
        end;
      end;
    end;
  end;

  // ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ ÍÓÌÚÓÎˇ Óı‡ÌÌ˚ı ÒÚÂÎÓÍ ‚ ÏËÌÛÒÂ
  g := ObjZav[ptr].ObjConstI[21];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        if not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
        begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
          inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,81,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,81); exit;
        end;
      end;
    end;
  end;
  // ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ ÍÓÌÚÓÎˇ Óı‡ÌÌ˚ı ÒÚÂÎÓÍ ‚ ÔÎ˛ÒÂ
  g := ObjZav[ptr].ObjConstI[22];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        if not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
        begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
          inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,81,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,81); exit;
        end;
      end;
    end;
  end;
  // ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ ÍÓÌÚÓÎˇ ıÓ‰Ó‚˚ı ÒÚÂÎÓÍ ‚ ÏËÌÛÒÂ
  g := ObjZav[ptr].ObjConstI[23];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 : begin
            if not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
            begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,81,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,81); exit;
            end;
          end;
          44 : begin
            if not ObjZav[ObjZav[o].UpdateObject].bParam[1] and not ObjZav[ObjZav[o].UpdateObject].bParam[2] then
            begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,81,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,81); exit;
            end;
          end;
        end;
      end;
    end;
  end;
  // ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ ÍÓÌÚÓÎˇ ıÓ‰Ó‚˚ı ÒÚÂÎÓÍ ‚ ÔÎ˛ÒÂ
  g := ObjZav[ptr].ObjConstI[24];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 : begin
            if not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
            begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,81,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,81); exit;
            end;
          end;
          44 : begin
            if not ObjZav[ObjZav[o].UpdateObject].bParam[1] and not ObjZav[ObjZav[o].UpdateObject].bParam[2] then
            begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,81,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,81); exit;
            end;
          end;
        end;
      end;
    end;
  end;
  // ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ ÍÓÌÚÓÎˇ ÒÚÂÎÓÍ Ì‡ ÛÔ‡‚ÎÂÌËË
  g := ObjZav[ptr].ObjConstI[16];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 : begin
            if not (ObjZav[o].bParam[1] xor ObjZav[o].bParam[2]) then
            begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,81,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,81); exit;
            end;
          end;
          44 : begin
            if not (ObjZav[ObjZav[o].UpdateObject].bParam[1] xor ObjZav[ObjZav[o].UpdateObject].bParam[2]) then
            begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,81,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,81); exit;
            end;
          end;
        end;
      end;
    end;
  end;
  // ÔÓ‚ÂËÚ¸ ÔÛÚË ‡ÈÓÌ‡
  g := ObjZav[ptr].ObjConstI[15];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          4 : begin // ÔÛÚ¸
            if not ObjZav[o].bParam[4] and (not ObjZav[o].bParam[2] or not ObjZav[o].bParam[3]) then
            begin // ÛÒÚ‡ÌÓ‚ÎÂÌ ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ Ì‡ ÔÛÚ¸
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,341,ObjZav[o].Liter,1); InsMsg(1,o,341); exit;
            end;
          end;
        end;
      end;
    end;
  end;

  if WorkMode.RazdUpr then
  begin // ‚ ÂÊËÏÂ ‡Á‰ÂÎ¸ÌÓ„Ó ÛÔ‡‚ÎÂÌËˇ ÔÓ‚ÂËÚ¸ ÔÓÎÓÊÂÌËÂ ıÓ‰Ó‚˚ı Ë Óı‡ÌÌ˚ı ÒÚÂÎÓÍ ‚˚ÚˇÊÍË

  // ÔÓ‚ÂËÚ¸ Ó·˙ÂÍÚ˚ Óœ»
    g := ObjZav[ptr].ObjConstI[15];
    if g > 0 then
    begin
      for i := 1 to 24 do
      begin
        q := ObjZav[g].ObjConstI[i];
        if q > 0 then
        begin
          case ObjZav[q].TypeObj of
            43 : begin // Ó·˙ÂÍÚ Óœ»
              if ObjZav[q].bParam[1] then
              begin // ÔÓ‚ÂËÚ¸ ÓÚ‚Ó‰ˇ˘ÂÂ ÔÓÎÓÊÂÌËÂ ÒÚÂÎÓÍ
              // ÔÓÚ‡ÒÒËÓ‚‡Ú¸ ‚˚ÂÁ‰ Ì‡ ÔÛÚË ËÁ Ï‡ÌÂ‚Ó‚Ó„Ó ‡ÈÓÌ‡
                opi := false;
                if ObjZav[q].ObjConstB[1] then p := 2 else p := 1;
                o := ObjZav[q].Neighbour[p].Obj; p := ObjZav[q].Neighbour[p].Pin; j := 50;
                while j > 0 do
                begin
                  case ObjZav[o].TypeObj of
                    2 : begin // ÒÚÂÎÍ‡
                      case p of
                        2 : begin
                          if ObjZav[ObjZav[o].BaseObject].bParam[11] then
                          begin // ÂÒÚ¸ ‚ÓÁÏÓÊÌÓÒÚ¸ ÓÚ‚Ó‰‡ ÒÚÂÎÍË
                            if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then break;
                            opi := true; break;
                          end;
                        end;
                        3 : begin
                          if ObjZav[ObjZav[o].BaseObject].bParam[10] then
                          begin // ÂÒÚ¸ ‚ÓÁÏÓÊÌÓÒÚ¸ ÓÚ‚Ó‰‡ ÒÚÂÎÍË
                            if ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then break;
                            opi := true; break;
                          end;
                        end;
                      end;
                      p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
                    end;
                    48 : begin // –œÓ
                      opi := true; break;
                    end;
                  else
                    if p = 1 then begin p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj; end
                    else begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end;
                  end;
                  if (o = 0) or (p < 1) then break;
                  dec(j);
                end;

              // ÒÚÂÎÍË ÌÂ ÛÒÚ‡ÌÓ‚ÎÂÌ˚ ‚ ÓÚ‚Ó‰ ‰Îˇ ÔÛÚË, ËÒÍÎ˛˜ÂÌÌÓ„Ó ËÁ Ï‡ÌÂ‚Ó‚
                if opi then
                begin
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,425,ObjZav[ObjZav[q].UpdateObject].Liter,1); InsMsg(1,ObjZav[q].UpdateObject,425); exit;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  // ÔÓ‚ÂËÚ¸ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÏËÌÛÒÂ
    g := ObjZav[ptr].ObjConstI[23];
    if g > 0 then
    begin
      for i := 1 to 24 do
      begin
        o := ObjZav[g].ObjConstI[i];
        if o > 0 then
        begin
          case ObjZav[o].TypeObj of
            2 : begin
              if not ObjZav[o].bParam[2] or (ObjZav[o].bParam[1] and ObjZav[o].bParam[2]) then
              begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ -
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,267,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,267); exit;
              end;
              if not SigCircNegStrelki(o,false,1) then exit;
              if ObjZav[o].bParam[16] or
                 (ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[16]) or
                 (not ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[17]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,119,ObjZav[o].Liter,1); InsMsg(1,o,119); exit;
              end;
              if ObjZav[o].bParam[17] or
                 (ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[33]) or
                 (not ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[34]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,453,ObjZav[o].Liter,1); InsMsg(1,o,453); exit;
              end;
              if ObjZav[o].bParam[15] or ObjZav[ObjZav[o].BaseObject].bParam[15] then
              begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                inc(MarhTracert[1].WarCount);
                MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
                GetShortMsg(1,120,ObjZav[ObjZav[o].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
                InsWar(1,ObjZav[o].BaseObject,120+$5000);
              end;
            end;
            44 : begin
              if not SigCircNegStrelki(ObjZav[o].UpdateObject,false,1) then exit;
              if ObjZav[ObjZav[o].UpdateObject].bParam[16] or
                 (ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[16]) or
                 (not ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[17]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,119,ObjZav[ObjZav[o].UpdateObject].Liter,1); InsMsg(1,ObjZav[o].UpdateObject,119); exit;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[17] or
                 (ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[33]) or
                 (not ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[34]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,453,ObjZav[ObjZav[o].UpdateObject].Liter,1); InsMsg(1,ObjZav[o].UpdateObject,453); exit;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[15] or ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[15] then
              begin //-------------------------------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                inc(MarhTracert[1].WarCount);
                MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
                GetShortMsg(1,120,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
                InsWar(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,120+$5000);
              end;
            end;
          end;
        end;
      end;
    end;
  // ÔÓ‚ÂËÚ¸ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÔÎ˛ÒÂ
    g := ObjZav[ptr].ObjConstI[24];
    if g > 0 then
    begin
      for i := 1 to 24 do
      begin
        o := ObjZav[g].ObjConstI[i];
        if o > 0 then
        begin
          case ObjZav[o].TypeObj of
            2 : begin
              if not ObjZav[o].bParam[1] or (ObjZav[o].bParam[1] and ObjZav[o].bParam[2]) then
              begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ +
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,268,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,268); exit;
              end;
              if not SigCircNegStrelki(o,true,1) then exit;
              if ObjZav[o].bParam[16] or
                 (ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[16]) or
                 (not ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[17]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,119,ObjZav[o].Liter,1); InsMsg(1,o,119); exit;
              end;
              if ObjZav[o].bParam[17] or
                 (ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[33]) or
                 (not ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[34]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,453,ObjZav[o].Liter,1); InsMsg(1,o,453); exit;
              end;
              if ObjZav[o].bParam[15] or ObjZav[ObjZav[o].BaseObject].bParam[15] then
              begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                inc(MarhTracert[1].WarCount);
                MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
                GetShortMsg(1,120,ObjZav[ObjZav[o].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
                InsWar(1,ObjZav[o].BaseObject,120+$5000);
              end;
            end;
            44 : begin
              if not SigCircNegStrelki(ObjZav[o].UpdateObject,true,1) then exit;
              if ObjZav[ObjZav[o].UpdateObject].bParam[16] or
                 (ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[16]) or
                 (not ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[17]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,119,ObjZav[ObjZav[o].UpdateObject].Liter,1); InsMsg(1,ObjZav[o].UpdateObject,119); exit;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[17] or
                 (ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[33]) or
                 (not ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[34]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,453,ObjZav[ObjZav[o].UpdateObject].Liter,1); InsMsg(1,ObjZav[o].UpdateObject,453); exit;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[15] or ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[15] then
              begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                inc(MarhTracert[1].WarCount);
                MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
                GetShortMsg(1,120,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
                InsWar(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,120+$5000);
              end;
            end;
          end;
        end;
      end;
    end;
  // ÔÓ‚ÂËÚ¸ Óı‡ÌÌ˚Â ÒÚÂÎÍË ‚ ÏËÌÛÒÂ
    g := ObjZav[ptr].ObjConstI[21];
    if g > 0 then
    begin
      for i := 1 to 24 do
      begin
        o := ObjZav[g].ObjConstI[i];
        if o > 0 then
        begin
          if not ObjZav[o].bParam[2] or (ObjZav[o].bParam[1] and ObjZav[o].bParam[2]) then
          begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ -
            inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,267,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,267); exit;
          end;
          if ObjZav[o].bParam[15] or ObjZav[ObjZav[o].BaseObject].bParam[15] then
          begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
            inc(MarhTracert[1].WarCount);
            MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
            GetShortMsg(1,120,ObjZav[ObjZav[o].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
            InsWar(1,ObjZav[o].BaseObject,120+$5000);
          end;
        end;
      end;
    end;
  // ÔÓ‚ÂËÚ¸ Óı‡ÌÌ˚Â ÒÚÂÎÍË ‚ ÔÎ˛ÒÂ
    g := ObjZav[ptr].ObjConstI[22];
    if g > 0 then
    begin
      for i := 1 to 24 do
      begin
        o := ObjZav[g].ObjConstI[i];
        if o > 0 then
        begin
          if not ObjZav[o].bParam[1] or (ObjZav[o].bParam[1] and ObjZav[o].bParam[2]) then
          begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ +
            inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,268,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,268); exit;
          end;
          if ObjZav[o].bParam[15] or ObjZav[ObjZav[o].BaseObject].bParam[15] then
          begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
            inc(MarhTracert[1].WarCount);
            MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
            GetShortMsg(1,120,ObjZav[ObjZav[o].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
            InsWar(1,ObjZav[o].BaseObject,120+$5000);
          end;
        end;
      end;
    end;

  end else
  if WorkMode.MarhUpr then
  begin // ‚ ÂÊËÏÂ Ï‡¯ÛÚÌÓ„Ó ÛÔ‡‚ÎÂÌËˇ ÔÓ‚ÂËÚ¸ ‚ÓÁÏÓÊÌÓÒÚ¸ Ú‡ÒÒËÓ‚ÍË Ò ÔÓ‚ÂÍÓÈ Ï‡ÌÂ‚Ó‚˚ı ‚‡Ê‰Â·ÌÓÒÚÂÈ

    // ÔÓ‚ÂËÚ¸ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÏËÌÛÒÂ
    g := ObjZav[ptr].ObjConstI[23];
    if g > 0 then
    begin
      for i := 1 to 24 do
      begin
        o := ObjZav[g].ObjConstI[i];
        if o > 0 then
        begin
          case ObjZav[o].TypeObj of
            2 : begin
              if not ObjZav[o].bParam[2] and not ObjZav[o].bParam[12] and ObjZav[o].bParam[13] then
              begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÏËÌÛÒÓ‚Ó„Ó ÔÓÎÓÊÂÌËˇ
                if not ObjZav[ObjZav[o].BaseObject].bParam[21] or
                   not ObjZav[ObjZav[o].BaseObject].bParam[22] or
                   ObjZav[ObjZav[o].BaseObject].bParam[24] then
                begin
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,267,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,267); exit;
                end;
                if ObjZav[ObjZav[o].BaseObject].bParam[4] then
                begin
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,80,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,80); exit;
                end;
                if ObjZav[o].bParam[18] or ObjZav[ObjZav[o].BaseObject].bParam[18] then
                begin // ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,159,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,159); exit;
                end;
              end;
              if not NegStrelki(o,false,1) then exit;
              if ObjZav[o].bParam[16] or
                 (ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[16]) or
                 (not ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[17]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,119,ObjZav[o].Liter,1); InsMsg(1,o,119); exit;
              end;
              if ObjZav[o].bParam[17] or
                 (ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[33]) or
                 (not ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[34]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,453,ObjZav[o].Liter,1); InsMsg(1,o,453); exit;
              end;
              if ObjZav[o].bParam[15] or ObjZav[ObjZav[o].BaseObject].bParam[15] then
              begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                inc(MarhTracert[1].WarCount);
                MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
                GetShortMsg(1,120,ObjZav[ObjZav[o].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
                InsWar(1,ObjZav[o].BaseObject,120+$5000);
              end;
            end;
            44 : begin
              if not ObjZav[ObjZav[o].UpdateObject].bParam[2] and
                 not ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[12] and
                 ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[13] then
              begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÏËÌÛÒÓ‚Ó„Ó ÔÓÎÓÊÂÌËˇ
                if not ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[21] or
                   not ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[22] or
                   ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[24] then
                begin
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,267,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,267); exit;
                end;
                if ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[4] then
                begin
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,80,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,80); exit;
                end;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[18] or ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[18] then
              begin // ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,151,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,151); exit;
              end;
              if not NegStrelki(ObjZav[o].UpdateObject,false,1) then exit;
              if ObjZav[ObjZav[o].UpdateObject].bParam[16] or
                 (ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[16]) or
                 (not ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[17]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,119,ObjZav[ObjZav[o].UpdateObject].Liter,1); InsMsg(1,ObjZav[o].UpdateObject,119); exit;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[17] or
                 (ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[33]) or
                 (not ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[34]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,453,ObjZav[ObjZav[o].UpdateObject].Liter,1); InsMsg(1,ObjZav[o].UpdateObject,453); exit;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[15] or ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[15] then
              begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                inc(MarhTracert[1].WarCount);
                MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
                GetShortMsg(1,120,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
                InsWar(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,120+$5000);
              end;
            end;
          end;
        end;
      end;
    end;

    // ÔÓ‚ÂËÚ¸ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÔÎ˛ÒÂ
    g := ObjZav[ptr].ObjConstI[24];
    if g > 0 then
    begin
      for i := 1 to 24 do
      begin
        o := ObjZav[g].ObjConstI[i];
        if o > 0 then
        begin
          case ObjZav[o].TypeObj of
            2 : begin
              if ObjZav[o].bParam[12] and ObjZav[o].bParam[13] then
              begin // ÂÒÚ¸ ÂÁ‰‡ ÔÓ + Ë - Ò‰ÂÎ‡ÌÓ ‰Îˇ ŒÒÍ‡ ÒÚÂÎÍ‡ 202
                if ObjZav[o].bParam[18] or ObjZav[ObjZav[o].BaseObject].bParam[18] then
                begin // ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,151,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,151); exit;
                end;
              end else
              if not ObjZav[o].bParam[1] and ObjZav[o].bParam[12] and not ObjZav[o].bParam[13] then
              begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÔÎ˛ÒÂ
                if not ObjZav[ObjZav[o].BaseObject].bParam[21] or
                   not ObjZav[ObjZav[o].BaseObject].bParam[22] or
                   ObjZav[ObjZav[o].BaseObject].bParam[24] then
                begin
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,268,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,268); exit;
                end;
                if ObjZav[ObjZav[o].BaseObject].bParam[4] then
                begin
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,80,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,80); exit;
                end;
                if ObjZav[o].bParam[18] or ObjZav[ObjZav[o].BaseObject].bParam[18] then
                begin // ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,121,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,121); exit;
                end;
              end;
              if not NegStrelki(o,true,1) then exit;
              if ObjZav[o].bParam[16] or
                 (ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[16]) or
                 (not ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[17]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,119,ObjZav[o].Liter,1); InsMsg(1,o,119); exit;
              end;
              if ObjZav[o].bParam[17] or
                 (ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[33]) or
                 (not ObjZav[o].ObjConstB[6] and ObjZav[ObjZav[o].BaseObject].bParam[34]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,453,ObjZav[o].Liter,1); InsMsg(1,o,453); exit;
              end;
              if ObjZav[o].bParam[15] or ObjZav[ObjZav[o].BaseObject].bParam[15] then
              begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                inc(MarhTracert[1].WarCount);
                MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
                GetShortMsg(1,120,ObjZav[ObjZav[o].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
                InsWar(1,ObjZav[o].BaseObject,120+$5000);
              end;
            end;
            44 : begin
              if not ObjZav[ObjZav[o].UpdateObject].bParam[1] and
                 ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[12] and
                 not ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[13] then
              begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÔÎ˛ÒÂ
                if not ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[21] or
                   not ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[22] or
                   ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[24] then
                begin
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,268,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,268); exit;
                end;
                if ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[4] then
                begin
                  inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,80,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,80); exit;
                end;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[18] or ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[18] then
              begin // ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,151,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1); InsMsg(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,151); exit;
              end;
              if not NegStrelki(ObjZav[o].UpdateObject,true,1) then exit;
              if ObjZav[ObjZav[o].UpdateObject].bParam[16] or
                 (ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[16]) or
                 (not ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[17]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,119,ObjZav[ObjZav[o].UpdateObject].Liter,1); InsMsg(1,ObjZav[o].UpdateObject,119); exit;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[17] or
                 (ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[33]) or
                 (not ObjZav[ObjZav[o].UpdateObject].ObjConstB[6] and ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[34]) then
              begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
                inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,453,ObjZav[ObjZav[o].UpdateObject].Liter,1); InsMsg(1,ObjZav[o].UpdateObject,453); exit;
              end;
              if ObjZav[ObjZav[o].UpdateObject].bParam[15] or ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[15] then
              begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                inc(MarhTracert[1].WarCount);
                MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
                GetShortMsg(1,120,ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
                InsWar(1,ObjZav[ObjZav[o].UpdateObject].BaseObject,120+$5000);
              end;
            end;
          end;
        end;
      end;
    end;

    // ÔÓ‚ÂËÚ¸ Óı‡ÌÌ˚Â ÒÚÂÎÍË ‚ ÏËÌÛÒÂ
    g := ObjZav[ptr].ObjConstI[21];
    if g > 0 then
    begin
      for i := 1 to 24 do
      begin
        o := ObjZav[g].ObjConstI[i];
        if o > 0 then
        begin
          if not ObjZav[o].bParam[2] or (ObjZav[o].bParam[1] and ObjZav[o].bParam[2]) then
          begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ -
            if not ObjZav[ObjZav[o].BaseObject].bParam[21] or
               not ObjZav[ObjZav[o].BaseObject].bParam[22] or
               ObjZav[ObjZav[o].BaseObject].bParam[24] then
            begin
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,267,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,267); exit;
            end;
            if ObjZav[ObjZav[o].BaseObject].bParam[4] then
            begin
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,80,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,80); exit;
            end;
            if ObjZav[o].bParam[18] or ObjZav[ObjZav[o].BaseObject].bParam[18] then
            begin // ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,235,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,235); exit;
            end;
          end;
          if ObjZav[o].bParam[15] or ObjZav[ObjZav[o].BaseObject].bParam[15] then
          begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
            inc(MarhTracert[1].WarCount);
            MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
            GetShortMsg(1,120,ObjZav[ObjZav[o].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
            InsWar(1,ObjZav[o].BaseObject,120+$5000);
          end;
        end;
      end;
    end;

    // ÔÓ‚ÂËÚ¸ Óı‡ÌÌ˚Â ÒÚÂÎÍË ‚ ÔÎ˛ÒÂ
    g := ObjZav[ptr].ObjConstI[22];
    if g > 0 then
    begin
      for i := 1 to 24 do
      begin
        o := ObjZav[g].ObjConstI[i];
        if o > 0 then
        begin
          if not ObjZav[o].bParam[1] or (ObjZav[o].bParam[1] and ObjZav[o].bParam[2]) then
          begin // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ +
            if not ObjZav[ObjZav[o].BaseObject].bParam[21] or
               not ObjZav[ObjZav[o].BaseObject].bParam[22] or
               ObjZav[ObjZav[o].BaseObject].bParam[24] then
            begin
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,268,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,268); exit;
            end;
            if ObjZav[ObjZav[o].BaseObject].bParam[4] then
            begin
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,80,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,8); exit;
            end;
            if ObjZav[o].bParam[18] or ObjZav[ObjZav[o].BaseObject].bParam[18] then
            begin // ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
              inc(MarhTracert[1].MsgCount); MarhTracert[1].Msg[MarhTracert[1].MsgCount] := GetShortMsg(1,236,ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(1,ObjZav[o].BaseObject,236); exit;
            end;
          end;
          if ObjZav[o].bParam[15] or ObjZav[ObjZav[o].BaseObject].bParam[15] then
          begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
            inc(MarhTracert[1].WarCount);
            MarhTracert[1].Warning[MarhTracert[1].WarCount] :=
            GetShortMsg(1,120,ObjZav[ObjZav[o].BaseObject].Liter,1)+ '. œÓ‰ÓÎÊ‡Ú¸?';
            InsWar(1,ObjZav[o].BaseObject,120+$5000);
          end;
        end;
      end;
    end;
  end;

  if MarhTracert[1].MsgCount > 0 then
  begin
    ResetTrace; exit;
  end;

  ObjZav[ptr].bParam[8] := true; // ÔËÁÌ‡Í ‚˚‰‡˜Ë ÍÓÏ‡Ì‰˚ –Ã
  result := true;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.VytajkaRM]');
  result := false;
end;
end;
//========================================================================================
function VytajkaZM(ptr : SmallInt) : Boolean;
//----------------------------------------------- œÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ Ï‡ÌÂ‚Ó‚Ó„Ó ‡ÈÓÌ‡
var
  i,g,o : Integer;
begin
try
  result := false;
  if ptr < 1 then exit;

  // Á‡ÏÍÌÛÚ¸ ÍÓÎÓÌÍÛ
  ObjZav[ptr].bParam[14] := true;

  // Á‡Ï˚Í‡ÌËÂ ÒÂÍˆËË ‚˚ÚˇÊÍË
  g := ObjZav[ptr].ObjConstI[18];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          3 : begin
            ObjZav[o].bParam[14] := true;
          end;
          44 : begin
            if ObjZav[o].bParam[1] or ObjZav[o].bParam[2] then
              ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[14] := true;
          end;
        end;
      end;
    end;
  end;

  // ÔÓ„‡ÒËÚ¸ ÔÛÚË
  g := ObjZav[ptr].ObjConstI[15];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          4  : ObjZav[o].bParam[8] := true;
          43 : ObjZav[ObjZav[o].UpdateObject].bParam[8] := true;
        end;
      end;
    end;
  end;

  //--------------------------------------------------- Á‡Ï˚Í‡ÌËÂ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÏËÌÛÒÂ
  g := ObjZav[ptr].ObjConstI[23];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 :
          begin
            ObjZav[o].bParam[13] := false;
            ObjZav[o].bParam[7]  := true;
            ObjZav[o].bParam[14] := true;
          end;
          44 :
          begin
            ObjZav[ObjZav[o].UpdateObject].bParam[13] := false;
            if ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[11] then
            ObjZav[ObjZav[o].UpdateObject].bParam[7] := true;
           ObjZav[ObjZav[o].UpdateObject].bParam[14] := true;
          end;
        end;
      end;
    end;
  end;

  // Á‡Ï˚Í‡ÌËÂ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÔÎ˛ÒÂ
  g := ObjZav[ptr].ObjConstI[24];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 : begin
            ObjZav[o].bParam[12] := false; ObjZav[o].bParam[6] := true;
            ObjZav[o].bParam[14] := true;
          end;
          44 : begin
            ObjZav[ObjZav[o].UpdateObject].bParam[12] := false;
            if ObjZav[ObjZav[ObjZav[o].UpdateObject].BaseObject].bParam[10] then
              ObjZav[ObjZav[o].UpdateObject].bParam[6] := true;
            ObjZav[ObjZav[o].UpdateObject].bParam[14] := true;
          end;
        end;
      end;
    end;
  end;

  // Á‡Ï˚Í‡ÌËÂ ıÓ‰Ó‚˚ı ÒÚÂÎÓÍ Ì‡ ÛÔ‡‚ÎÂÌËË
  g := ObjZav[ptr].ObjConstI[16];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 : begin
            ObjZav[o].bParam[12] := false; ObjZav[o].bParam[6] := true;
            ObjZav[o].bParam[13] := false; ObjZav[o].bParam[7] := true;
            ObjZav[o].bParam[14] := true;
          end;
        end;
      end;
    end;
  end;

except
  reportf('Œ¯Ë·Í‡ [Marshrut.VytajkaZM]');
  result := false;
end;
end;
//========================================================================================
function VytajkaOZM(ptr : SmallInt) : Boolean;
//---------------------------------------------- œÓ„‡ÏÏÌÓÂ ‡ÁÏ˚Í‡ÌËÂ Ï‡ÌÂ‚Ó‚Ó„Ó ‡ÈÓÌ‡
var
  i,g,o : Integer;
begin
try
  result := false;
  if ptr < 1 then exit;

  // ‡ÁÓÏÍÌÛÚ¸ ÍÓÎÓÌÍÛ
  ObjZav[ptr].bParam[14] := false;
  ObjZav[ptr].bParam[8]  := false; // Ò·ÓÒËÚ¸ ÔËÁÌ‡Í ‚˚‰‡˜Ë ÍÓÏ‡Ì‰˚ –Ã

  // ‡ÁÓÏÍÌÛÚ¸ ÒÂÍˆËË ‚˚ÚˇÊÍË
  g := ObjZav[ptr].ObjConstI[18];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          3 : begin
            ObjZav[o].bParam[8] := true; ObjZav[o].bParam[14] := false;
          end;
          44 : begin
            ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[8] := true; ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[14] := false;
          end;
        end;
      end;
    end;
  end;

  // ‡ÁÓÏÍÌÛÚ¸ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÏËÌÛÒÂ
  g := ObjZav[ptr].ObjConstI[23];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 : begin
            ObjZav[o].bParam[12] := false; ObjZav[o].bParam[13] := false; ObjZav[o].bParam[6] := false; ObjZav[o].bParam[7] := false; ObjZav[o].bParam[14] := false;
          end;
          44 : begin
            ObjZav[ObjZav[o].UpdateObject].bParam[12] := false; ObjZav[ObjZav[o].UpdateObject].bParam[13] := false;
            ObjZav[ObjZav[o].UpdateObject].bParam[6] := false; ObjZav[ObjZav[o].UpdateObject].bParam[7] := false; ObjZav[ObjZav[o].UpdateObject].bParam[14] := false;
          end;
        end;
      end;
    end;
  end;

  // ‡ÁÓÏÍÌÛÚ¸ ıÓ‰Ó‚˚Â ÒÚÂÎÍË ‚ ÔÎ˛ÒÂ
  g := ObjZav[ptr].ObjConstI[24];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 : begin
            ObjZav[o].bParam[12] := false; ObjZav[o].bParam[13] := false; ObjZav[o].bParam[6] := false; ObjZav[o].bParam[7] := false; ObjZav[o].bParam[14] := false;
          end;
          44 : begin
            ObjZav[ObjZav[o].UpdateObject].bParam[12] := false; ObjZav[ObjZav[o].UpdateObject].bParam[13] := false;
            ObjZav[ObjZav[o].UpdateObject].bParam[6] := false; ObjZav[ObjZav[o].UpdateObject].bParam[7] := false; ObjZav[ObjZav[o].UpdateObject].bParam[14] := false;
          end;
        end;
      end;
    end;
  end;

  // ‡ÁÓÏÍÌÛÚ¸ ıÓ‰Ó‚˚ı ÒÚÂÎÓÍ Ì‡ ÛÔ‡‚ÎÂÌËË
  g := ObjZav[ptr].ObjConstI[16];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          2 : begin
            ObjZav[o].bParam[12] := false; ObjZav[o].bParam[6] := false;
            ObjZav[o].bParam[13] := false; ObjZav[o].bParam[7] := false;
            ObjZav[o].bParam[14] := false;
          end;
        end;
      end;
    end;
  end;

except
  reportf('Œ¯Ë·Í‡ [Marshrut.VytajkaOZM]');
  result := false;
end;
end;
//========================================================================================
function VytajkaCOT(ptr : SmallInt) : string;
//------------------------------------------------------- œÓ‚ÂÍ‡ ÛÒÎÓ‚ËÈ ÓÚÏÂÌ˚ Ï‡ÌÂ‚Ó‚
var
  i,g,o : Integer;
begin
try
  result := '';
  MarhTracert[1].MsgCount := 0; MarhTracert[1].WarCount := 0;
  if ptr < 1 then exit;
  // ÔÓ‚ÂËÚ¸ ÛÒÎÓ‚Ëˇ Ì‡ ÍÓÎÓÌÍÂ
  if ObjZav[ptr].bParam[2] then
  begin // Ó“
    result := GetShortMsg(1,259,ObjZav[ptr].Liter,1); exit;
  end;

  // ÔÓ‚ÂËÚ¸ ÒÂÍˆËË ‚˚ÚˇÊÍË
  g := ObjZav[ptr].ObjConstI[18];
  if g > 0 then
  begin
    for i := 1 to 24 do
    begin
      o := ObjZav[g].ObjConstI[i];
      if o > 0 then
      begin
        case ObjZav[o].TypeObj of
          3 : begin
            if not ObjZav[o].bParam[1] then
            begin
              result := GetShortMsg(1,83,ObjZav[o].Liter,1); exit;
            end;
          end;
          44 : begin
            if not ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].bParam[1] then
            begin
              result := GetShortMsg(1,83,ObjZav[ObjZav[ObjZav[o].UpdateObject].UpdateObject].Liter,1); exit;
            end;
          end;
        end;
      end;
    end;
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.VytajkaCOT]'); result := '';
end;
end;
//========================================================================================
function GetStateSP(mode : Byte; Obj : SmallInt) : SmallInt;
//--------------------------------- œÓÎÛ˜ËÚ¸ ËÌ‰ÂÍÒ —œ, ËÏÂ˛˘Â„Ó ‚‡Ê‰Â·ÌÓÒÚ¸ ‰Îˇ Ï‡¯ÛÚ‡
var
  sp1,sp2 : integer;
begin
try
  sp1 := ObjZav[ObjZav[ObjZav[Obj].BaseObject].ObjConstI[8]].UpdateObject;
  sp2 := ObjZav[ObjZav[ObjZav[Obj].BaseObject].ObjConstI[9]].UpdateObject;
  case mode of
    1 : begin // Á‡Ï˚Í‡ÌËÂ —œ
      if (sp1 > 0) and not ObjZav[sp1].bParam[2] then result := sp1 else
      if (sp2 > 0) and not ObjZav[sp2].bParam[2] then result := sp2 else
        result := ObjZav[Obj].UpdateObject;
    end;
    2 : begin // Á‡ÌˇÚÓÒÚ¸ —œ
      if (sp1 > 0) and not ObjZav[sp1].bParam[1] then result := sp1 else
      if (sp2 > 0) and not ObjZav[sp2].bParam[1] then result := sp2 else
        result := ObjZav[Obj].UpdateObject;
    end;
  else
    result := Obj;
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.GetStateSP]'); result := Obj;
end;
end;
//========================================================================================
procedure SetNadvigParam(Ptr : SmallInt);
//------------------------------------ ÛÒÚ‡ÌÓ‚ËÚ¸ ÔËÁÌ‡Í √¬ Ì‡ Ò‚ÂÚÓÙÓ˚ Ï‡¯ÛÚ‡ Ì‡‰‚Ë„‡
var
  max,o,p,nadv : integer;
begin
try
  //------------------------------------- Ì‡ÈÚË Ú‡ÒÒÛ Ï‡¯ÛÚ‡ Ì‡‰‚Ë„‡ Ë ÓÔÂ‰ÂÎËÚ¸ „ÓÍÛ
  max := 1000; nadv := 0;
  o := ObjZav[Ptr].Neighbour[2].Obj; p := ObjZav[Ptr].Neighbour[2].Pin;
  while max > 0 do
  begin
    case ObjZav[o].TypeObj of
      2 : begin // ÒÚÂÎÍ‡
        case p of
          2 : begin
            if ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
            begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end else break;
          end;
          3 : begin
            if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then
            begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end else break;
          end;
        else
          if ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
          begin
            p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj;
          end else
          if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then
          begin
            p := ObjZav[o].Neighbour[3].Pin; o := ObjZav[o].Neighbour[3].Obj;
          end else
            break;
        end;
      end;
      32 : begin // Ì‡‰‚Ë„
        nadv := o; break;
      end;
    else
      if p = 1 then
      begin
        p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj;
      end else
      begin
        p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
      end;
    end;
    dec(max);
  end;
  if nadv > 0 then
  begin // ‡ÒÍË‰‡Ú¸ ÔËÁÌ‡Í √¬ ÔÓ Ò‚ÂÚÓÙÓ‡Ï Ï‡¯ÛÚ‡
    ObjZav[Ptr].iParam[2] := nadv;
    max := 1000;
    o := ObjZav[Ptr].Neighbour[2].Obj; p := ObjZav[Ptr].Neighbour[2].Pin;
    while max > 0 do
    begin
      case ObjZav[o].TypeObj of
        2 : begin // ÒÚÂÎÍ‡
          case p of
            2 : begin
              if ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
              begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end else break;
            end;
            3 : begin
              if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then
              begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end else break;
            end;
          else
            if ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
            begin
              p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj;
            end else
            if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then
            begin
              p := ObjZav[o].Neighbour[3].Pin; o := ObjZav[o].Neighbour[3].Obj;
            end else
              break;
          end;
        end;
        32 : begin // Ì‡‰‚Ë„
          break;
        end;

        3 : begin // —œ,”œ
          ObjZav[o].iParam[3] := nadv; // ÔÓÏÂÚËÚ¸ ÔËÁÌ‡ÍÓÏ √¬
          if p = 1 then
          begin
            p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj;
          end else
          begin
            p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
          end;
        end;
        5 : begin // Ò‚ÂÚÓÙÓ
          if p = 1 then
          begin // ÔÓÔÛÚÌ˚È Ò‚ÂÚÓÙÓ ÔÓÏÂÚËÚ¸ ÔËÁÌ‡ÍÓÏ √¬
            ObjZav[o].iParam[2] := nadv;
            p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj;
          end else
          begin // ‚ÒÚÂ˜Ì˚È Ò‚ÂÚÓÙÓ ÔÓÏÂÚËÚ¸ ÔËÁÌ‡ÍÓÏ ”Õ
            ObjZav[o].iParam[3] := nadv;
            p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
          end;
        end;
      else
        if p = 1 then
        begin
          p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj;
        end else
        begin
          p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
        end;
      end;
      dec(max);
    end;
  end;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.SetNadvigParam]');
end;
end;
//========================================================================================
//----------------------------------------------- ”ÒÚ‡ÌÓ‚ËÚ¸ / ÒÌˇÚ¸ ‡‚ÚÓ‰ÂÈÒÚ‚ËÂ ÒË„Ì‡ÎÓ‚
function AutoMarsh(Ptr : SmallInt; mode : Boolean) : Boolean;
var
  i,j,o,p,g,signal,hvost : integer;
  vkl : boolean;
  jmp : TOZNeighbour;
begin
  try
    vkl := true;

    if mode then //----------------------------- ÔËÁÌ‡Í ‚ÍÎ˛˜ÂÌËˇ/ÓÚÍÎ˛˜ÂÌËˇ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
    begin //-------------------------------------------------------- ‚ÍÎ˛˜ËÚ¸ ‡‚ÚÓ‰ÂÈÒÚ‚ËÂ
      for i := 10 to 12 do //--- ÔÓÈÚË ÔÓ ˆÂÔÓ˜ÍÂ ÓÔËÒ‡ÌËÈ ‡‚ÚÓ‰ÂÈÒÚ‚ËÈ ÒË„Ì‡ÎÓ‚ Ï‡¯ÛÚ‡
      begin           //--------- ÔÓÔ˚Ú‡Ú¸Òˇ ÛÒÚ‡ÌÓ‚ËÚ¸ ‡‚ÚÓ‰ÂÈÒÚ‚ËÂ ‚ÒÂı ÒË„Ì‡ÎÓ‚ ˆÂÔÓ˜ÍË
        o := ObjZav[Ptr].ObjConstI[i]; //------------------------------ Ó˜ÂÂ‰ÌÓÂ ÓÔËÒ‡ÌËÂ
        if o > 0 then
        begin
          signal := ObjZav[o].BaseObject;
          if not ObjZav[signal].bParam[4] and WorkMode.Upravlenie then //- ÔÓÂÁ‰ÌÓÈ Á‡Í˚Ú
          begin //----------------------------------------------------- ÌÂ ÓÚÍ˚Ú Ò‚ÂÚÓÙÓ
            result := false;
            ShowShortMsg(429,LastX,LastY,ObjZav[signal].Liter);
            InsArcNewMsg(signal,429+$4000,1); //----------------------- ÕÂ ÓÚÍ˚Ú ÒË„Ì‡Î $
            exit;
          end;

          for j := 1 to 10 do //--------- ÔÓÈÚË ÔÓ ÒÚÂÎÍ‡Ï ÓÔËÒ‡ÌËˇ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ ÒË„Ì‡Î‡
          begin //-------------------------------------------- ÔÓ‚ÂËÚ¸ ÔÓÎÓÊÂÌËÂ ÒÚÂÎÓÍ
            p := ObjZav[o].ObjConstI[j];
            if p > 0 then
            begin
              if not ObjZav[p].bParam[1] and WorkMode.Upravlenie then
              begin //----------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÎ˛ÒÓ‚Ó„Ó ÔÓÎÓÊÂÌËˇ
                result := false;
                ShowShortMsg(268,LastX,LastY,ObjZav[ObjZav[p].BaseObject].Liter);
                InsArcNewMsg(ObjZav[o].BaseObject,268+$4000,1); // —ÚÂÎÍ‡ ·ÂÁ ÍÓÌÚÓÎˇ œ 
                exit;
              end;
              hvost:= ObjZav[p].BaseObject;
              if (ObjZav[hvost].bParam[15] or ObjZav[hvost].bParam[19])and //ÔËÁÌ‡Í Ï‡ÍÂÚ
              WorkMode.Upravlenie then
              begin //-------------------------------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                result := false;
                ShowShortMsg(120,LastX,LastY,ObjZav[ObjZav[p].BaseObject].Liter);
                InsArcNewMsg(ObjZav[o].BaseObject,120+$4000,1);
                exit;
              end;
            end;
          end;
        end;
      end;

      //------------------------------------------ ÔÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË ‰Îˇ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
      for i := 10 to 12 do
      begin
        o := ObjZav[Ptr].ObjConstI[i];
        if o > 0 then
        begin
          g := ObjZav[o].ObjConstI[25]; //-------------------------------------- ‚ÁˇÚ¸  –”
          MarhTracert[g].Rod := MarshP;
          MarhTracert[g].Finish := false;
          MarhTracert[g].WarCount := 0;
          MarhTracert[g].MsgCount := 0;
          MarhTracert[g].ObjStart := ObjZav[o].BaseObject;
          MarhTracert[g].Counter := 0;
          j := 1000;

          jmp := ObjZav[ObjZav[o].BaseObject].Neighbour[2];

          //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          //MarhTracert[g].Level := tlSignalCirc;//--------------- ÂÊËÏ ÒË„Ì‡Î¸Ì‡ˇ ÒÚÛÌ‡
          //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          MarhTracert[g].Level := tlSetAuto; //-------------- ÂÊËÏ ÛÒÚ‡ÌÓ‚ÍË ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
           //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          MarhTracert[g].FindTail := true;

          while j > 0 do
          begin
            case StepTrace(jmp,MarhTracert[g].Level,MarhTracert[g].Rod,g) of
              trStop, trEnd, trEndTrace : break;
            end;
            dec(j);
          end;
          if j < 1 then vkl := false; //------------------------ Ú‡ÒÒ‡ Ï‡¯ÛÚ‡ ‡ÁÛ¯ÂÌ‡
          if MarhTracert[g].MsgCount > 0 then vkl := false;
        end;
      end;

      if not vkl and WorkMode.Upravlenie then
      begin //--------------------------------------- ÓÚÍ‡Á‡ÌÓ ‚ ÛÒÚ‡ÌÓ‚ÍÂ Ì‡ ‡‚ÚÓ‰ÂÈÒÚ‚ËÂ
        InsArcNewMsg(Ptr,476+$4000,1);
        ShowShortMsg(476,LastX,LastY,ObjZav[Ptr].Liter); //¿‚ÚÓ‰ÂÈÒÚ‚ËÂ ÌÂ ÏÓÊÂÚ ·˚Ú¸ ‚ÍÎ.
        SingleBeep4 := true;
        result := false;
        exit;
      end;

      //------------------------------------------------- ‡ÒÒÚ‡‚ËÚ¸ ÔËÁÌ‡ÍË ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
      for i := 10 to 12 do
      begin
        o := ObjZav[Ptr].ObjConstI[i];
        if o > 0 then
        begin
          ObjZav[o].bParam[1] := vkl;
          AutoMarshON(ObjZav[Ptr].ObjConstI[i],ObjZav[Ptr].ObjConstB[1]);
        end;
      end;
      ObjZav[Ptr].bParam[1] := vkl;
      result := vkl;
    end else
    begin //------------------------------------------------------- ÓÚÍÎ˛˜ËÚ¸ ‡‚ÚÓ‰ÂÈÒÚ‚ËÂ
      for i := 10 to 12 do
      if ObjZav[Ptr].ObjConstI[i] > 0 then
      begin //--------------------------------- Ò·ÓÒËÚ¸ ‡‚ÚÓ‰ÂÈÒÚ‚ËÂ ‚ÒÂı ÒË„Ì‡ÎÓ‚ „ÛÔÔ˚
        ObjZav[ObjZav[Ptr].ObjConstI[i]].bParam[1] := false;
        AutoMarshOFF(ObjZav[Ptr].ObjConstI[i],ObjZav[Ptr].ObjConstB[1]);
      end;
      ObjZav[Ptr].bParam[1] := false;
      result := true;
    end;
  except
    reportf('Œ¯Ë·Í‡ [Marshrut.AutoMarsh]');
    result := false;
  end;
end;
//========================================================================================
function AutoMarshReset(Ptr : SmallInt) : Boolean;
//------------------------ —·ÓÒ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ ÔË ‚˚‰‡˜Â ÍÓÏ‡Ì‰˚ ÓÚÏÂÌ˚ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡
var
  i : integer;
begin
try
  if (Ptr > 0) and (ObjZav[Ptr].TypeObj = 47) then
  begin
    if ObjZav[Ptr].bParam[1] then
    begin
      for i := 10 to 12 do
      begin
        if ObjZav[Ptr].ObjConstI[i] > 0 then
        begin //------------------------------- Ò·ÓÒËÚ¸ ‡‚ÚÓ‰ÂÈÒÚ‚ËÂ ‚ÒÂı ÒË„Ì‡ÎÓ‚ „ÛÔÔ˚
          ObjZav[ObjZav[Ptr].ObjConstI[i]].bParam[1] := false;
          AutoMarshOFF(ObjZav[Ptr].ObjConstI[i],ObjZav[Ptr].ObjConstB[1]);
        end;
      end;
      ObjZav[Ptr].bParam[1] := false;
      InsArcNewMsg(Ptr,422+$4000,1);
      AddFixMessage(GetShortMsg(1,422, ObjZav[Ptr].Liter,1),4,3);
    end;
    result := true;
  end else
    result := false;
except
  reportf('Œ¯Ë·Í‡ [Marshrut.AutoMarshReset]'); result := false;
end;
end;
//========================================================================================
//---------------- –‡ÁÌÂÒÚË ÔËÁÌ‡ÍË ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ ÔÓ Ó·˙ÂÍÚ‡Ï Ú‡ÒÒ˚ Ï‡¯ÛÚ‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
function AutoMarshON(Ptr : SmallInt; Napr : Boolean) : Boolean;
var
  o,p,j,vid : integer;
begin
  result := false;
  if ObjZav[Ptr].BaseObject = 0 then exit;

  for j := 1 to 10 do
  if ObjZav[Ptr].ObjConstI[j] > 0 then
  begin
    o := ObjZav[Ptr].ObjConstI[j];
    if Napr then ObjZav[o].bParam[33] := true
    else ObjZav[o].bParam[25] := true;
    ObjZav[o].bParam[4] := ObjZav[o].bParam[33] or ObjZav[o].bParam[25];
  end;

  j := 100;
  o := ObjZav[ObjZav[Ptr].BaseObject].Neighbour[2].Obj;
  p := ObjZav[ObjZav[Ptr].BaseObject].Neighbour[2].Pin;
  ObjZav[ObjZav[Ptr].BaseObject].bParam[33] := true;
  while j > 0 do
  begin
    case ObjZav[o].TypeObj of
      2 :  //--------------------------------------------------------------------- ÒÚÂÎÍ‡
      begin
        vid := ObjZav[o].VBufferIndex;
        OVBuffer[vid].Param[28] := ObjZav[o].bParam[4];
        if p = 1 then
        begin
          p := ObjZav[o].Neighbour[2].Pin;
          o := ObjZav[o].Neighbour[2].Obj;
        end else
        begin
          p := ObjZav[o].Neighbour[1].Pin;
          o := ObjZav[o].Neighbour[1].Obj;
        end;
      end;

      3 :  //----------------------------------------------- ÒÚ‡‚ËÏ ‡‚ÚÓ‰ÂÈÒÚ‚ËÂ Ì‡ ÒÂÍˆË˛
      begin
        ObjZav[o].bParam[33] := true;

        if p = 1 then
        begin
          p := ObjZav[o].Neighbour[2].Pin;
          o := ObjZav[o].Neighbour[2].Obj;
        end  else
        begin
          p := ObjZav[o].Neighbour[1].Pin;
          o := ObjZav[o].Neighbour[1].Obj;
        end;
      end;

      4 : //------------------------------------------------------------------------- ÔÛÚ¸
      begin
        ObjZav[o].bParam[33] := true;

        if p = 1 then
        begin
          p := ObjZav[o].Neighbour[2].Pin;
          o := ObjZav[o].Neighbour[2].Obj;
        end else
        begin
          p := ObjZav[o].Neighbour[1].Pin;
          o := ObjZav[o].Neighbour[1].Obj;
        end;
      end;

      5 :  //-------------------------------------------------------------------- Ò‚ÂÚÓÙÓ
      begin
        if p = 1 then
        begin
          if ObjZav[o].ObjConstB[5] then break;
          ObjZav[o].bParam[33] := true;
          p := ObjZav[o].Neighbour[2].Pin;
          o := ObjZav[o].Neighbour[2].Obj;
        end else
        begin
          if ObjZav[o].ObjConstB[6] then break;
          ObjZav[o].bParam[33] := true;
          p := ObjZav[o].Neighbour[1].Pin;
          o := ObjZav[o].Neighbour[1].Obj;
        end;
      end;

      15 :
      begin //------------------------------------------------------------------------- ¿¡
        ObjZav[o].bParam[33] := true; break;
      end;

      else //--------------------------------------------------------------- ‚ÒÂ ÓÒÚ‡Î¸Ì˚Â
      if p = 1 then
      begin
        p := ObjZav[o].Neighbour[2].Pin;
        o := ObjZav[o].Neighbour[2].Obj;
      end else
      begin
        p := ObjZav[o].Neighbour[1].Pin;
        o := ObjZav[o].Neighbour[1].Obj;
      end;
    end;

    if o < 1 then break;
    dec(j);
  end;
  result := true;
end;
//========================================================================================
//-------------------- —ÌˇÚ¸ ÔËÁÌ‡ÍË ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ Ò Ó·˙ÂÍÚÓ‚ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡ ‡‚ÚÓ‰ÂÈÒÚ‚Ëˇ
function AutoMarshOFF(Ptr : SmallInt; Napr : Boolean) : Boolean;
var
  o,p,j,vid : integer;
begin
  result := false;
  if ObjZav[Ptr].BaseObject = 0 then exit;
  for j := 1 to 10 do
  if ObjZav[Ptr].ObjConstI[j] > 0 then
  begin
    o := ObjZav[Ptr].ObjConstI[j];
    if Napr then ObjZav[o].bParam[33] := false
    else ObjZav[o].bParam[25] := false;
    ObjZav[o].bParam[4] := ObjZav[o].bParam[25] or ObjZav[o].bParam[33];
  end;
  j := 100;
  o := ObjZav[ObjZav[Ptr].BaseObject].Neighbour[2].Obj;
  p := ObjZav[ObjZav[Ptr].BaseObject].Neighbour[2].Pin;
  ObjZav[ObjZav[Ptr].BaseObject].bParam[33] := false;
  while j > 0 do
  begin
    case ObjZav[o].TypeObj of
      2 :
      begin //-------------------------------------------------------------------- ÒÚÂÎÍ‡
        //--------------------- ÔÓÍ‡ Ò˜ËÚ‡ÂÏ ˜ÚÓ ‚ÒÂ ÒÚÂÎÍË ‚ ‡‚ÚÓ‰ÂÈÒÚ‚ËË ÒÚÓˇÚ ÔÓ ÔÎ˛ÒÛ
        vid := ObjZav[o].VBufferIndex;
        OvBuffer[vid].Param[28] := ObjZav[o].bParam[4];
        if p = 1 then
        begin p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj; end
        else
        begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end;
      end;

      3 :
      begin //--------------------------------------------------------------------- ÒÂÍˆËˇ
        ObjZav[o].bParam[33] := false;
        if p = 1 then
        begin p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj; end
        else
        begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end;
      end;

      4 :
      begin //----------------------------------------------------------------------- ÔÛÚ¸
        ObjZav[o].bParam[33] := false;
        if p = 1 then
        begin p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj; end
        else
        begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end;
      end;

      5 :
      begin //------------------------------------------------------------------- Ò‚ÂÚÓÙÓ
        if p = 1 then
        begin
          if ObjZav[o].ObjConstB[5] then break;
          ObjZav[o].bParam[33] := false;
          p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj;
        end else
        begin
          if ObjZav[o].ObjConstB[6] then break;
          ObjZav[o].bParam[33] := false;
          p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
        end;
      end;

      15 :
      begin //------------------------------------------------------------------------- ¿¡
        ObjZav[o].bParam[33] := false;
        break;
      end;
      else //--------------------------------------------------------------- ‚ÒÂ ÓÒÚ‡Î¸Ì˚Â
        if p = 1 then
        begin p := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj; end
        else
        begin p := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end;
    end;
    if o < 1 then break;
    dec(j);
  end;
  result := true;
end;
//========================================================================================
function StepTraceStrelka(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------ ÔÓˆÂ‰Û‡ ÔÓıÓ‰‡ ‚ Ï‡¯ÛÚÂ ˜ÂÂÁ Ó·˙ÂÍÚ ·‡Á˚ "ÒÚÂÎÍ‡"
begin
  case Lvl of //-------------------------------------------- ÔÂÂÍÎ˛˜‡ÚÂÎ¸ ÔÓ ÚËÔÛ ÔÓıÓ‰‡
    tlFindTrace    :  result := StepStrelFindTrassa(Con,Lvl,Rod,Group,jmp);
    tlContTrace    :  result := StepStrelContTrassa(Con,Lvl,Rod,Group,jmp);
    tlVZavTrace    :  result := StepStrelZavTrassa(Con,Lvl,Rod,Group,jmp);
    tlCheckTrace   :  result := StepStrelCheckTrassa(Con,Lvl,Rod,Group,jmp);
    tlZamykTrace   :  result := StepStrelZamykTrassa(Con,Lvl,Rod,Group,jmp);

    tlSetAuto, tlSignalCirc : result := StepStrelSignalCirc(Con,Lvl,Rod,Group,jmp);

    tlOtmenaMarh   :  result := StepStrelOtmenaMarh(Con,Lvl,Rod,Group,jmp);
    tlRazdelSign   :  result := StepStrelRazdelSign(Con,Lvl,Rod,Group,jmp);
    tlFindIzvest   :  result := StepStrelFindIzvest(Con,Lvl,Rod,Group,jmp);
    tlFindIzvStrel :  result := StepStrelFindIzvStrel(Con,Lvl,Rod,Group,jmp);
    tlPovtorMarh   :  result := StepStrelPovtorMarh(Con,Lvl,Rod,Group,jmp);
    tlAutoTrace    :  result := StepStrelAutoTrace(Con,Lvl,Rod,Group,jmp);
    else              result := trEnd;
  end;
end;
//========================================================================================
function StepTraceSP(var Con:TOZNeighbour; const Lvl:TTracertLevel;
Rod:Byte;Group:Byte;jmp:TOZNeighbour):TTracertResult;
//----------------------------------------------------------------------- ¯‡„ ˜ÂÂÁ ÒÂÍˆË˛
var
  k : integer;
  tail : boolean;
begin
  case Lvl of
    tlFindTrace    : result := StepSPforFindTrace (Con, Lvl, Rod, Group, jmp);
    tlContTrace    : result := StepSPforContTrace (Con, Lvl, Rod, Group, jmp);
    tlVZavTrace    : result := StepSPforZavTrace  (Con, Lvl, Rod, Group, jmp);
    tlCheckTrace   : result := StepSPforCheckTrace(Con, Lvl, Rod, Group, jmp);
    tlZamykTrace   : result := StepSPforZamykTrace(Con, Lvl, Rod, Group, jmp);

    tlSetAuto,  tlSignalCirc   : result := StepSPSignalCirc   (Con, Lvl, Rod, Group, jmp);

    tlOtmenaMarh   : result := StepSPOtmenaMarh   (Con, Lvl, Rod, Group, jmp);
    tlRazdelSign   : result := StepSPRazdelSign   (Con, Lvl, Rod, Group, jmp);
    tlPovtorRazdel : result := StepSPPovtorRazdel (Con, Lvl, Rod, Group, jmp);
    tlAutoTrace    : result := StepSPAutoTrace    (Con, Lvl, Rod, Group, jmp);
    tlFindIzvest   : result := StepSPFindIzvest   (Con, Lvl, Rod, Group, jmp);
    tlFindIzvStrel : result := StepSPFindIzvStrel (Con, Lvl, Rod, Group, jmp);
    tlPovtorMarh   : result := StepSPPovtorMarh   (Con, Lvl, Rod, Group, jmp);
    else             result := trNextStep;
  end;
end;
//========================================================================================
function StepTracePut (var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//----------------------------------- (4) ÔÓˆÂ‰Û‡ ‚˚ÔÓÎÌÂÌËˇ ¯‡„‡ Ú‡ÒÒËÓ‚ÍË ˜ÂÂÁ ÔÛÚ¸
//---------- Con - ÒÓÂ‰ËÌËÚÂÎ¸ Ò ÒÓÒÂ‰ÌËÏ Ó·˙ÂÍÚÓÏ, Ò ÍÓÚÓÓ„Ó Ú‡ÒÒ‡ ‚˚¯Î‡ Ì‡ ‰‡ÌÌ˚È ÔÛÚ¸
//---------- Lvl -------------------------------------------- ÛÓ‚ÂÌ¸ Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡
//---------- Rod ------------------------------------------------------------ ÚËÔ Ï‡¯ÛÚ‡
//---------- Group ------------------------------------ ÌÓÏÂ Ï‡¯ÛÚ‡ ‚ ÒÔËÒÍÂ Á‡‰‡‚‡ÂÏ˚ı
//---------- jmp ---------------------------------------- Ó·˙ÂÍÚ Á‡‚ËÒËÏÓÒÚÂÈ ‰‡ÌÌÓ„Ó ÔÛÚË

var
  k : integer;
  tail : boolean;
begin
  case Lvl of

    tlFindTrace    : result := StepPutFindTrassa  (Con, Lvl, Rod, Group, jmp);
    tlContTrace    : result := StepPutContTrassa  (Con, Lvl, Rod, Group, jmp);
    tlVZavTrace    : result := StepPutZavTrassa   (Con, Lvl, Rod, Group, jmp);
    tlCheckTrace   : result := StepPutCheckTrassa (Con, Lvl, Rod, Group, jmp);
    tlZamykTrace   : result := StepPutZamykTrassa (Con, Lvl, Rod, Group, jmp);

    tlSetAuto,  tlSignalCirc : result := StepPutSignalCirc  (Con, Lvl, Rod, Group, jmp);

    tlOtmenaMarh   : result := StepPutOtmenaMarh  (Con, Lvl, Rod, Group, jmp);
    tlRazdelSign   : result := StepPutRazdelSign  (Con, Lvl, Rod, Group, jmp);
    tlAutoTrace    : result := StepPutAutoTrace   (Con, Lvl, Rod, Group, jmp);
    tlFindIzvest   : result := StepPutFindIzvest  (Con, Lvl, Rod, Group, jmp);
    tlFindIzvStrel : result := StepPutFindIzvStrel(Con, Lvl, Rod, Group, jmp);
    tlPovtorRazdel,
    tlPovtorMarh   : result := StepPutPovtorMarh  (Con, Lvl, Rod, Group, jmp);
         else        result := trEnd;
  end;
end;
//========================================================================================
function StepTraceSvetofor(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod :Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------------------------------ ÔÓÈÚË ¯‡„ ˜ÂÂÁ Ò‚ÂÚÓÙÓ ÔÓ ·‡ÁÂ
//- Con : TOZNeighbour - ÔË ‚ıÓ‰Â Con = jmp (ÓÚÍÛ‰‡ ÔË¯ÎË), ÔË ‚˚ıÓ‰Â Con - ÍÛ‰‡ ÛıÓ‰ËÏ
//--------------------------------------- Lvl : TTracertLevel ---- ˝Ú‡Ô ‡·ÓÚ˚ Ò Ï‡¯ÛÚÓÏ
//------------------------------------------------------------ Rod:Byte ----- ÚËÔ Ï‡¯ÛÚ‡
//------------------------------------------ Group:Byte ÌÓÏÂ Ï‡¯ÛÚ‡ ‚ ÒÔËÒÍÂ Á‡‰‡‚‡ÂÏ˚ı
//------------------------- jmp : TOZNeighbour ------  Ò‚ˇÁ¸ Ò ÒÓÒÂ‰ÓÏ, ÓÚ ÍÓÚÓÓ„Ó ÔË¯ÎË
//------- Ú‡ÍËÏ Ó·‡ÁÓÏ jmp.Obj - ˝ÚÓ Ò‚ÂÚÓÙÓ, ˜ÂÂÁ ÍÓÚÓ˚È ÙÛÌÍˆËˇ ÔÓ‚Ó‰ËÚ ¯‡„ ÔÓ ·‡ÁÂ
begin
  case Lvl of
    tlFindTrace    :  result := StepSvetoforFindTrace  (Con, Lvl, Rod, Group, jmp);
    tlContTrace    :  result := StepSvetoforContTrace  (Con, Lvl, Rod, Group, jmp);
    tlVZavTrace    :  result := StepSvetoforZavTrace   (Con, Lvl, Rod, Group, jmp);
    tlCheckTrace   :  result := StepSvetoforCheckTrace (Con, Lvl, Rod, Group, jmp);
    tlZamykTrace   :  result := StepSvetoforZamykTrace (Con, Lvl, Rod, Group, jmp);

    tlSetAuto, tlSignalCirc : result := StepSignalCirc (Con, Lvl, Rod, Group, jmp);

    tlOtmenaMarh   :  result := StepSigOtmenaMarh      (Con, Lvl, Rod, Group, jmp);
    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign   :  result := StepSigAutoPovtorRazdel(Con, Lvl, Rod, Group, jmp);
    tlFindIzvest   :  result := StepSigFindIzvest      (Con, Lvl, Rod, Group, jmp);
    tlFindIzvStrel :  result := StepSigFindIzvStrel    (Con, Lvl, Rod, Group, jmp);
    tlPovtorMarh   :  result := StepSigPovtorMarh      (Con, Lvl, Rod, Group, jmp);
    else              result := trEnd;
  end;
end;
//========================================================================================
function StepTraceAB(var Con:TOZNeighbour; const Lvl:TTracertLevel;
Rod : Byte;Group:Byte;jmp:TOZNeighbour):TTracertResult;
//---------------------------------------- (15) ÔÓˆÂ‰Û‡ Ú‡ÒÒËÓ‚ÍË ˜ÂÂÁ ¿‚ÚÓ¡ÎÓÍËÓ‚ÍÛ
//--------------------------------------------------- Ú‡ÒÒËÛÂÚÒˇ Ó·˙ÂÍÚ  ObjZav[jmp.Obj]
begin
  case Lvl of
    tlFindTrace : //--------------------------------------------------------- ÔÓËÒÍ Ú‡ÒÒ˚
    begin
      result := trNextStep;
      if not MarhTracert[Group].LvlFNext then
      begin
        if Con.Pin = 1 then  //--------------------------- ÂÒÎË ÔÓ‰Ó¯ÎË ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 1
        begin
          Con := ObjZav[jmp.Obj].Neighbour[2]; //--------- ÚÓ ÍÓÌÌÂÍÚÓ ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 2
          case Con.TypeJmp of
            LnkRgn : result := trRepeat; //----------- ÍÓÌÂˆ ‡ÈÓÌ‡ ÛÔ‡‚ÎÂÌËˇ - ‚ÂÌÛÚ¸Òˇ
            LnkEnd : result := trRepeat; //---------------------- ÍÓÌÂˆ ÒÚÓÍË - ‚ÂÌÛÚ¸Òˇ
          end;
        end else
        begin
          Con := ObjZav[jmp.Obj].Neighbour[1]; //ÂÒÎË ÔË¯ÎË Ì‡ ÚÓ˜ÍÛ 2, ÚÓ ÍÓÌÌÂÍÚÓ ÓÚ 1
          case Con.TypeJmp of
            LnkRgn : result := trRepeat;
            LnkEnd : result := trRepeat;
          end;
        end;
      end;
    end;

    tlContTrace :  //----- ƒÓ‚ÂÒÚË Ú‡ÒÒÛ ‰Ó ÔÂ‰ÔÓÎ‡„‡ÂÏÓ„Ó ÍÓÌˆ‡ ËÎË ÓÚÍÎÓÌˇ˛˘ÂÈ ÒÚÂÎÍË
    begin
      case Rod of
        MarshP :
          if ObjZav[jmp.Obj].ObjConstB[1]     //--------- ÂÒÎË ÂÒÚ¸ ÓÚÔ‡‚ÎÂÌËÂ Ì‡ ÔÂÂ„ÓÌ
          then result := trEndTrace
          else result := trStop;
        MarshM : result := trStop;
        else
          MarhTracert[Group].FullTail := true;
          result := trEndTrace;
      end;
    end;

    tlVZavTrace :  //---------------- ÔÓ‚ÂËÚ¸ Óı‡ÌÌÓÒÚË ÔÓ Ú‡ÒÒÂ (ÍÓÌˆ˚ ‡ÈÓÌ‡ Ë ·‡Á˚)
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else  result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end;
    end;

    tlCheckTrace : //-------------- ÔÓ‚ÂËÚ¸ Ú‡ÒÒÛ Ì‡ ‚ÓÁÏÓÊÌÓÒÚ¸ ÓÒÛ˘ÂÒÚ‚ÎÂÌËˇ Ï‡¯ÛÚ‡
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          if not ObjZav[jmp.Obj].bParam[6] then //-------------------------- ÂÒÎË ËÁ˙ˇÚ  ∆
          begin
            if ObjZav[jmp.Obj].ObjConstB[3] and //- ÔÓ‰ÍÎ˛˜‡ÂÏ˚È ÍÓÏÔÎÂÍÚ Í‡ÔÂÏÓÌÚ‡ Ë ...
            (ObjZav[jmp.Obj].bParam[7] or //------------ ÂÒÚ¸ ÔÓ‰ÍÎ˛˜ÂÌËÂ Í ÔÛÚË 1 ËÎË ...
            ObjZav[jmp.Obj].bParam[8]) then //------------------ ÂÒÚ¸ ÔÓ‰ÍÎ˛˜ÂÌËÂ Í ÔÛÚË 2
            begin //-  œÓ‰ÍÎ˛˜‡ÂÌ ÍÓÏÔÎÂÍÚ —Õ Í‡ÔÂÏÓÌÚ‡ - Á‡ÔÂ˘ÂÌÓ ÓÚÔ‡‚ÎÂÌËÂ ıÓÁÔÓÂÁ‰‡
              result := trBreak;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,363, ObjZav[jmp.Obj].Liter,1);
              InsMsg(Group,jmp.Obj,363); //----------------------  ‡ÔÂÏÓÌÚ ÔÛÚË ÔÂÂ„ÓÌ‡!
                                         //--- «‡ÔÂ˘ÂÌÓ ÓÚÔ‡‚ÎÂÌËÂ ıÓÁÔÓÂÁ‰‡ Ì‡ ÔÂÂ„ÓÌ!
              MarhTracert[Group].GonkaStrel := false;
            end else
            begin //-------------------------------------- ¬˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ ıÓÁÔÓÂÁ‰Û
              result := trBreak;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,133, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,133); // ”ÒÚ‡ÌÓ‚ËÚ¸ Ï‡¯ÛÚ ÓÚÔ‡‚ÎÂÌËˇ
                                         // ıÓÁˇÈÒÚ‚ÂÌÌÓ„Ó ÔÓÂÁ‰‡ Ì‡ ÔÂÂ„ÓÌ $?
            end;
          end;

          if ObjZav[jmp.Obj].ObjConstB[1] then //------------- ÂÒÚ¸ ÓÚÔ‡‚ÎÂÌËÂ Ì‡ ÔÂÂ„ÓÌ
          begin
            if ObjZav[jmp.Obj].ObjConstB[2] then
            begin //--------------------- ÂÒÎË ÂÒÚ¸ ÒÏÂÌ‡ Ì‡Ô‡‚ÎÂÌËˇ - ÔÓ‚ÂËÚ¸ ÍÓÏÔÎÂÍÚ
              if ObjZav[jmp.Obj].ObjConstB[3] then
              begin //----------------------------------------- ÂÒÚ¸ ÔÓ‰ÍÎ˛˜ÂÌËÂ ÍÓÏÔÎÂÍÚ‡
                if ObjZav[jmp.Obj].ObjConstB[4] then
                begin //------------------------------------------------ ÔÂÂ„ÓÌ ÔÓ ÔËÂÏÛ
                  if (not ObjZav[jmp.Obj].bParam[7]) or
                  (ObjZav[jmp.Obj].bParam[7] and ObjZav[jmp.Obj].bParam[8]) then
                  begin //----------------  ÓÏÔÎÂÍÚ ÌÂ ÔÓ‰ÍÎ˛˜ÂÌ ËÎË ÔÓ‰ÍÎ˛˜ÂÌ ÌÂÔ‡‚ËÎ¸ÌÓ
                    result := trBreak;
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,132, ObjZav[jmp.Obj].Liter,1);
                    InsMsg(Group,jmp.Obj,132);//ÕÂ ÔÓ‰ÍÎ˛˜ÂÌ ÍÓÏÔÎÂÍÚ ÒÏÂÌ˚ Ì‡Ô‡‚ÎÂÌËˇ...
                    MarhTracert[Group].GonkaStrel := false;
                  end else
                  if not ObjZav[jmp.Obj].ObjConstB[10] then  //--------- ÂÒÎË ÌÂ Ó‰ÌÓÔÛÚÍ‡
                  begin
                    if not ObjZav[jmp.Obj].bParam[4] then //------------ —Õ ÌÂ ÓÚÔ‡‚ÎÂÌËÂ
                    begin
                      result := trBreak;
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,128, ObjZav[jmp.Obj].Liter,1);
                      InsMsg(Group,jmp.Obj,128);//- ÕÂ ÛÒÚ‡ÌÓ‚ÎÂÌÓ Ì‡Ô‡‚Î. ÔÓ ÓÚÔ‡‚ÎÂÌË˛
                    end;
                  end else //---------------------------------------------- ÂÒÎË Ó‰ÌÓÔÛÚÍ‡
                  begin
                    if not ObjZav[jmp.Obj].bParam[4] and //------------ —Õ ÌÂ ÓÚÔ‡‚ÎÂÌËÂ
                    not ObjZav[jmp.Obj].bParam[5]//------------------------- Á‡ÌˇÚ ÔÂÂ„ÓÌ
                    then
                    begin
                      result := trBreak;
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,262, ObjZav[jmp.Obj].Liter,1);
                      InsMsg(Group,jmp.Obj,262);//-------------------------- Á‡ÌˇÚ ÔÂÂ„ÓÌ
                    end;
                  end;
                end else
                if ObjZav[jmp.Obj].ObjConstB[5] then //------------ ÔÂÂ„ÓÌ ÔÓ ÓÚÔ‡‚ÎÂÌË˛
                begin
                  if ObjZav[jmp.Obj].bParam[7] then
                  begin //---------------------------------  ÓÏÔÎÂÍÚ ÔÓ‰ÍÎ˛˜ÂÌ ÌÂÔ‡‚ËÎ¸ÌÓ
                    result := trBreak;
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,132, ObjZav[jmp.Obj].Liter,1);
                    InsMsg(Group,jmp.Obj,132);//ÕÂ ÔÓ‰ÍÎ˛˜ÂÌ ÍÓÏÔÎÂÍÚ ÒÏÂÌ˚ Ì‡Ô‡‚ÎÂÌËˇ...
                    MarhTracert[Group].GonkaStrel := false;
                  end else
                  if ObjZav[jmp.Obj].bParam[8] then
                  begin
                    if not ObjZav[jmp.Obj].bParam[4] then //--------------------------- —Õ
                    begin
                      result := trBreak;
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,128, ObjZav[jmp.Obj].Liter,1);
                      InsMsg(Group,jmp.Obj,128);//ÕÂ ÛÒÚ‡ÌÓ‚ÎÂÌÓ Ì‡Ô‡‚ÎÂÌËÂ ÔÓ ÓÚÔ‡‚ÎÂÌË˛
                    end;
                  end;
                end;
              end else
              begin //--------------------- ÍÓÏÔÎÂÍÚ ÒÏÂÌ˚ Ì‡Ô‡‚ÎÂÌËˇ ÔÓ‰ÍÎ˛˜ÂÌ ÔÓÒÚÓˇÌÌÓ
                if not ObjZav[jmp.Obj].ObjConstB[10] then  //----- ÂÒÎË ÌÂ Ó‰ÌÓÔÛÚÍ‡ Ë ...
                begin
                  if not ObjZav[jmp.Obj].bParam[4] then //----------------- ÌÂ ÓÚÔ‡‚ÎÂÌËÂ
                  begin
                    result := trBreak;
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,128, ObjZav[jmp.Obj].Liter,1);
                    InsMsg(Group,jmp.Obj,128);// ÕÂ ÛÒÚ‡ÌÓ‚ÎÂÌÓ Ì‡Ô‡‚ÎÂÌËÂ ÔÓ ÓÚÔ‡‚ÎÂÌË˛
                  end;
                end else //------------------------------------------------ ÂÒÎË Ó‰ÌÓÔÛÚÍ‡
                begin
                  if not ObjZav[jmp.Obj].bParam[4] and //--------------- —Õ ÌÂ ÓÚÔ‡‚ÎÂÌËÂ
                  not ObjZav[jmp.Obj].bParam[5]//--------------------------- Á‡ÌˇÚ ÔÂÂ„ÓÌ
                  then
                  begin
                    result := trBreak;
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,262, ObjZav[jmp.Obj].Liter,1);
                    InsMsg(Group,jmp.Obj,262);//---------------------------- Á‡ÌˇÚ ÔÂÂ„ÓÌ
                  end;
                end;
              end;
            end;
          end else
          begin //--------------------------------------------- ÌÂÚ ÓÚÔ‡‚ÎÂÌËˇ Ì‡ ÔÂÂ„ÓÌ
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,131, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,131);//----------------------- ÕÂÚ ÓÚÔ‡‚ÎÂÌËˇ Ì‡ ÔÂÂ„ÓÌ
            MarhTracert[Group].GonkaStrel := false;
          end;

          if ObjZav[jmp.Obj].ObjConstB[3] then  //------------- ÂÒÎË ÔÓ‰ÍÎ˛˜‡ÂÏ˚È ÍÓÏÔÎÂÍÚ
          begin
            if ObjZav[jmp.Obj].ObjConstB[4] then //------------ ÂÒÎË ·ÂÁ ÍÓÏÔÎÂÍÚ‡ - ÔËÂÏ
            begin //------------------- ‡ Ò ÍÓÏÔÎÂÍÚÓÏ - ÓÚÔ‡‚ÎÂÌËÂ ÔÓ ÌÂÔ‡‚ËÎ¸ÌÓÏÛ ÔÛÚË
              if not ObjZav[jmp.Obj].bParam[2] or not ObjZav[jmp.Obj].bParam[3] then // »œ
              begin
                result := trBreak;
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,129, ObjZav[jmp.Obj].Liter,1);
                InsMsg(Group,jmp.Obj,129);//----------------------- «‡ÌˇÚ Û˜‡ÒÚÓÍ Û‰‡ÎÂÌËˇ
              end;
            end else
            begin //-------------------------------------- ŒÚÔ‡‚ÎÂÌËÂ ÔÓ Ô‡‚ËÎ¸ÌÓÏÛ ÔÛÚË
              if not ObjZav[jmp.Obj].bParam[2] then //--------------------------------- »œ
              begin
                result := trBreak;
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,129, ObjZav[jmp.Obj].Liter,1);
                InsMsg(Group,jmp.Obj,129);//----------------------- «‡ÌˇÚ Û˜‡ÒÚÓÍ Û‰‡ÎÂÌËˇ
              end;
            end;
          end else //--------------------------------- ÂÒÎË ÌÂÚ ÔÓ‰ÍÎ˛˜‡ÂÏÓ„Ó ÍÓÏÔÎÂÍÚ‡ —Õ
          begin
            if not ObjZav[jmp.Obj].bParam[2] then //----------------------------------- »œ
            begin
              result := trBreak;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,129, ObjZav[jmp.Obj].Liter,1);
              InsMsg(Group,jmp.Obj,129);//------------------------- «‡ÌˇÚ Û˜‡ÒÚÓÍ Û‰‡ÎÂÌËˇ
            end;
          end;

          if ObjZav[jmp.Obj].bParam[9] then //------------------------ ÓÚÔ‡‚ÎÂÌ ıÓÁ.ÔÓÂÁ‰
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,130, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,130);  //------- ŒÚÔ‡‚ÎÂÌ ıÓÁˇÈÒÚ‚ÂÌÌ˚È ÔÓÂÁ‰ Ì‡ ÔÂÂ„ÓÌ
            MarhTracert[Group].GonkaStrel := false;
          end;

          if ObjZav[jmp.Obj].bParam[12] or
          ObjZav[jmp.Obj].bParam[13] then //- ÔÂÂ„ÓÌ Á‡·ÎÓÍËÓ‚‡Ì ÔÓ„‡ÏÏÌÓ ("ÍÓÎÔ‡˜ÓÍ")
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,432, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,432); //-------------------------------  œÂÂ„ÓÌ $ Á‡Í˚Ú
            MarhTracert[Group].GonkaStrel := false;
          end;

          if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then
          begin
            if ObjZav[jmp.Obj].bParam[24] or
            ObjZav[jmp.Obj].bParam[27] then //--------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú.
            begin
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,462);//------------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ
            end else
            if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
            begin
              if ObjZav[jmp.Obj].bParam[25] or
              ObjZav[jmp.Obj].bParam[28] then //----------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
                InsWar(Group,jmp.Obj,467);//«‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓÒÚ.ÚÓÍ‡ ÔÓ $
              end;
              if ObjZav[jmp.Obj].bParam[26] or
              ObjZav[jmp.Obj].bParam[29] then //------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
                InsWar(Group,jmp.Obj,472);
              end;
            end;
          end else
          begin //--------------------------------------- ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÔÓ‚Ó‰‡
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,474, ObjZav[jmp.Obj].Liter,1); // ”˜‡ÒÚÓÍ $ ÌÂ ˝ÎÂÍÚËÙËˆËÓ‚‡ÌÌ˚È
            InsWar(Group,jmp.Obj,474);
          end;
        end;

        MarshM :
        begin
          //
        end;
        else   result := trStop; exit;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        if result = trBreak then exit;
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trEnd;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        if result = trBreak then exit;
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trEnd;
        end;
      end;
    end;

    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign,
    tlSignalCirc :
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          if not ObjZav[jmp.Obj].bParam[6] then //-------------------------------------  ∆
          begin
            if ObjZav[jmp.Obj].ObjConstB[3] and
            (ObjZav[jmp.Obj].bParam[7] or ObjZav[jmp.Obj].bParam[8]) then
            begin //-------------- œÓ‰ÍÎ˛˜‡ÂÏ˚È ÍÓÏÔÎÂÍÚ - Á‡ÔÂ˘ÂÌÓ ÓÚÔ‡‚ÎÂÌËÂ ıÓÁÔÓÂÁ‰‡
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,363, ObjZav[jmp.Obj].Liter,1);
              //------  ‡ÔÂÏÓÌÚ ÔÛÚË ÔÂÂ„ÓÌ‡! «‡ÔÂ˘ÂÌÓ ÓÚÔ‡‚ÎÂÌËÂ ıÓÁÔÓÂÁ‰‡ Ì‡ ÔÂÂ„ÓÌ
              InsMsg(Group,jmp.Obj,363);
            end else
            begin //-------------------------------------- ¬˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ ıÓÁÔÓÂÁ‰Û
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,133, ObjZav[jmp.Obj].Liter,1);
              //---------- ”ÒÚ‡ÌÓ‚ËÚ¸ Ï‡¯ÛÚ ÓÚÔ‡‚ÎÂÌËˇ ıÓÁˇÈÒÚ‚ÂÌÌÓ„Ó ÔÓÂÁ‰‡ Ì‡ ÔÂÂ„ÓÌ
              InsWar(Group,jmp.Obj,133);
            end;
          end;

          if ObjZav[jmp.Obj].ObjConstB[1] then
          begin //-------------------------------------------- ÂÒÚ¸ ÓÚÔ‡‚ÎÂÌËÂ Ì‡ ÔÂÂ„ÓÌ
            if ObjZav[jmp.Obj].ObjConstB[2] then
            begin //--------------------- ÂÒÎË ÂÒÚ¸ ÒÏÂÌ‡ Ì‡Ô‡‚ÎÂÌËˇ - ÔÓ‚ÂËÚ¸ ÍÓÏÔÎÂÍÚ
              if ObjZav[jmp.Obj].ObjConstB[3] then
              begin //----------------------------------------- ÂÒÚ¸ ÔÓ‰ÍÎ˛˜ÂÌËÂ ÍÓÏÔÎÂÍÚ‡
                if ObjZav[jmp.Obj].ObjConstB[4] then
                begin //------------------------------------------------ ÔÂÂ„ÓÌ ÔÓ ÔËÂÏÛ
                  if (not ObjZav[jmp.Obj].bParam[7]) or
                  (ObjZav[jmp.Obj].bParam[7] and ObjZav[jmp.Obj].bParam[8]) then
                  begin //----------------  ÓÏÔÎÂÍÚ ÌÂ ÔÓ‰ÍÎ˛˜ÂÌ ËÎË ÔÓ‰ÍÎ˛˜ÂÌ ÌÂÔ‡‚ËÎ¸ÌÓ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,132, ObjZav[jmp.Obj].Liter,1);
                    InsMsg(Group,jmp.Obj,132);
                  end else
                  if not ObjZav[jmp.Obj].ObjConstB[10] and //---------- ÌÂ Ó‰ÌÓÔÛÚÍ‡ Ë ...
                  not ObjZav[jmp.Obj].bParam[4] then //-------------------- ÌÂ ÓÚÔ‡‚ÎÂÌËÂ
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,128, ObjZav[jmp.Obj].Liter,1);
                    InsMsg(Group,jmp.Obj,128);
                  end;
                end else //---------------------------------------- ÔÂÂ„ÓÌ ÔÓ ÓÚÔ‡‚ÎÂÌË˛
                if ObjZav[jmp.Obj].ObjConstB[5] then
                begin //------------------------------------------- ÔÂÂ„ÓÌ ÔÓ ÓÚÔ‡‚ÎÂÌË˛
                  if ObjZav[jmp.Obj].bParam[7] then
                  begin //---------------------------------  ÓÏÔÎÂÍÚ ÔÓ‰ÍÎ˛˜ÂÌ ÌÂÔ‡‚ËÎ¸ÌÓ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,132, ObjZav[jmp.Obj].Liter,1);
                    InsMsg(Group,jmp.Obj,132);//ÕÂ ÔÓ‰ÍÎ˛˜ÂÌ ÍÓÏÔÎÂÍÚ ÒÏÂÌ˚ Ì‡Ô‡‚ÎÂÌËˇ ÔÓ
                  end else
                  if ObjZav[jmp.Obj].bParam[8] then
                  begin
                    if not ObjZav[jmp.Obj].bParam[4] then //--------------------------- —Õ
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,128, ObjZav[jmp.Obj].Liter,1);
                      InsMsg(Group,jmp.Obj,128);
                    end;
                  end;
                end;
              end else
              begin //--------------------- ÍÓÏÔÎÂÍÚ ÒÏÂÌ˚ Ì‡Ô‡‚ÎÂÌËˇ ÔÓ‰ÍÎ˛˜ÂÌ ÔÓÒÚÓˇÌÌÓ
                if not ObjZav[jmp.Obj].bParam[4] then //------------------------------- —Õ
                begin
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,128, ObjZav[jmp.Obj].Liter,1);
                  InsMsg(Group,jmp.Obj,128);
                end;
              end;
            end;
          end else
          begin //--------------------------------------------- ÌÂÚ ÓÚÔ‡‚ÎÂÌËˇ Ì‡ ÔÂÂ„ÓÌ
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,131, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,131);
          end;

          if ObjZav[jmp.Obj].ObjConstB[3] then
          begin
            if ObjZav[jmp.Obj].ObjConstB[4] then
            begin //------------------------------------ ŒÚÔ‡‚ÎÂÌËÂ ÔÓ ÌÂÔ‡‚ËÎ¸ÌÓÏÛ ÔÛÚË
              if not ObjZav[jmp.Obj].bParam[2] or not ObjZav[jmp.Obj].bParam[3] then // »œ
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,129, ObjZav[jmp.Obj].Liter,1);
                InsMsg(Group,jmp.Obj,129); //---------------------- «‡ÌˇÚ Û˜‡ÒÚÓÍ Û‰‡ÎÂÌËˇ
              end;
            end else
            begin //-------------------------------------- ŒÚÔ‡‚ÎÂÌËÂ ÔÓ Ô‡‚ËÎ¸ÌÓÏÛ ÔÛÚË
              if not ObjZav[jmp.Obj].bParam[2] then //--------------------------------- »œ
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,129, ObjZav[jmp.Obj].Liter,1);
                InsMsg(Group,jmp.Obj,129);  //--------------------- «‡ÌˇÚ Û˜‡ÒÚÓÍ Û‰‡ÎÂÌËˇ
              end;
            end;
          end else
          begin
            if not ObjZav[jmp.Obj].bParam[2] then //----------------------------------- »œ
            begin
              if Lvl= tlAutoTrace then exit;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,129, ObjZav[jmp.Obj].Liter,1);
              InsMsg(Group,jmp.Obj,129);//------------------------- «‡ÌˇÚ Û˜‡ÒÚÓÍ Û‰‡ÎÂÌËˇ
            end;
          end;

          if ObjZav[jmp.Obj].bParam[9] then //------------------------ ÓÚÔ‡‚ÎÂÌ ıÓÁ.ÔÓÂÁ‰
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,130, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,130); //------ ŒÚÔ‡‚ÎÂÌ ıÓÁˇÈÒÚ‚ÂÌÌ˚È ÔÓÂÁ‰ Ì‡ ÔÂÂ„ÓÌ $
          end;

          if ObjZav[jmp.Obj].bParam[12] or
          ObjZav[jmp.Obj].bParam[13] then //------------------------- ÔÂÂ„ÓÌ Á‡·ÎÓÍËÓ‚‡Ì
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,432, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,432); //-------------------------------- œÂÂ„ÓÌ $ Á‡Í˚Ú
          end;

          if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then
          begin
            //----------------------------------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú.
            if ObjZav[jmp.Obj].bParam[24] or ObjZav[jmp.Obj].bParam[27] then
            begin
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,462); //---------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
            end else
            if ObjZav[jmp.Obj].ObjConstB[8] and
            ObjZav[jmp.Obj].ObjConstB[9] then
            begin
              if ObjZav[jmp.Obj].bParam[25] or
              ObjZav[jmp.Obj].bParam[28] then //----------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
                InsWar(Group,jmp.Obj,467); //------ «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÓÒÚ. ÚÓÍ‡ ÔÓ $
              end;

              if ObjZav[jmp.Obj].bParam[26] or
              ObjZav[jmp.Obj].bParam[29] then //------------ «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
                InsWar(Group,jmp.Obj,472); //----- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÂÂÏ. ÚÓÍ‡ ÔÓ $
              end;
            end;
          end else
          begin //--------------------------------------- ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÔÓ‚Ó‰‡
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,474, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,474); //---------------- ”˜‡ÒÚÓÍ $ ÌÂ ˝ÎÂÍÚËÙËˆËÓ‚‡ÌÌ˚È
          end;
        end;

        MarshM :
        begin
         //
        end;
        else  result := trStop; exit;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        if result = trBreak then exit;
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            if result = trBreak then exit;
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            end;
          end;
        end;

        tlPovtorMarh :
        begin
          MarhTracert[Group].ObjEnd := jmp.Obj; // Á‡ÙËÍÒËÓ‚‡Ú¸ ÍÓÌÂˆ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
            else
              result := trNextStep;
            end;
          end;
        end;

        tlZamykTrace :
        begin
          ObjZav[jmp.Obj].bParam[14] := true;
          ObjZav[jmp.Obj].bParam[15] := true;
          ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart;
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
            else
              result := trNextStep;
            end;
          end;
        end;

        tlOtmenaMarh : begin
          ObjZav[jmp.Obj].bParam[14] := false;
          ObjZav[jmp.Obj].bParam[15] := false;
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
            else
              result := trNextStep;
            end;
          end;
        end;

        tlFindIzvest :
        begin
          if ObjZav[jmp.Obj].ObjConstB[2] then
          begin // ÂÒÚ¸ ÒÏÂÌ‡ Ì‡Ô‡‚ÎÂÌËˇ
            if ObjZav[jmp.Obj].ObjConstB[3] then
            begin // ÂÒÚ¸ ÔÓ‰ÍÎ˛˜ÂÌËÂ ÍÓÏÔÎÂÍÚ‡
              if ObjZav[jmp.Obj].ObjConstB[4] then
              begin // ÔÂÂ„ÓÌ ÒÔÂˆË‡ÎËÁÓ‚‡Ì ÔÓ ÔËÂÏÛ
                if ObjZav[jmp.Obj].bParam[7] and not ObjZav[jmp.Obj].bParam[8] then
                begin
                  if ObjZav[jmp.Obj].bParam[4] then
                  begin // ÔÂÂ„ÓÌ ÔÓ ÔËÂÏÛ
                    if not ObjZav[jmp.Obj].bParam[2] or not ObjZav[jmp.Obj].bParam[3] {or not ObjZav[jmp.Obj].bParam[11]} then
                    begin // «‡ÌˇÚÓ ÔË·ÎËÊÂÌËÂ
                      result := trBreak;
                    end else
                      result := trStop;
                  end else
                    result := trStop;
                end else
                if not ObjZav[jmp.Obj].bParam[2] or not ObjZav[jmp.Obj].bParam[3] {or not ObjZav[jmp.Obj].bParam[11]} then
                begin // «‡ÌˇÚÓ ÔË·ÎËÊÂÌËÂ
                  result := trBreak;
                end else
                  result := trStop;
              end else
              if ObjZav[jmp.Obj].ObjConstB[5] then
              begin // ÔÂÂ„ÓÌ ÒÔÂˆË‡ÎËÁÓ‚‡Ì ÔÓ ÓÚÔ‡‚ÎÂÌË˛
                if not ObjZav[jmp.Obj].bParam[7] and ObjZav[jmp.Obj].bParam[8] then
                begin
                  if not ObjZav[jmp.Obj].bParam[4] then
                  begin // ÔÂÂ„ÓÌ ÔÓ ÔËÂÏÛ
                    if not ObjZav[jmp.Obj].bParam[2] or not ObjZav[jmp.Obj].bParam[3] {or not ObjZav[jmp.Obj].bParam[11]} then
                    begin // «‡ÌˇÚÓ ÔË·ÎËÊÂÌËÂ
                      result := trBreak;
                    end else
                      result := trStop;
                  end else
                  if not ObjZav[jmp.Obj].bParam[2] then result := trBreak else result := trStop;
                end else
                  result := trStop;
              end else
                result := trStop;
            end else
            begin // ÍÓÏÔÎÂÍÚ ÔÓ‰ÍÎ˛˜ÂÌ ÔÓÒÚÓˇÌÌÓ
              if not ObjZav[jmp.Obj].bParam[4] then
              begin // ÔÂÂ„ÓÌ ÔÓ ÔËÂÏÛ
                if not ObjZav[jmp.Obj].bParam[2] or not ObjZav[jmp.Obj].bParam[3] {or not ObjZav[jmp.Obj].bParam[11]} then
                begin // «‡ÌˇÚÓ ÔË·ÎËÊÂÌËÂ
                  result := trBreak;
                end else
                  result := trStop;
              end else
              if not ObjZav[jmp.Obj].bParam[2] then result := trBreak else result := trStop;
            end;
          end else
          if ObjZav[jmp.Obj].ObjConstB[4] then
          begin // ÔÂÂ„ÓÌ ÒÔÂˆË‡ÎËÁÓ‚‡Ì ÔÓ ÔËÂÏÛ
            if not ObjZav[jmp.Obj].bParam[2] or not ObjZav[jmp.Obj].bParam[3] {or not ObjZav[jmp.Obj].bParam[11]} then
            begin // «‡ÌˇÚÓ ÔË·ÎËÊÂÌËÂ
              result := trBreak;
            end else
              result := trStop;
          end else
            result := trStop;
        end;

        tlFindIzvStrel :    result := trStop;

      else
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end;
      end;
    end;
//========================================================================================
function StepTracePriglas(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------------------------------------- œË„Î‡ÒËÚÂÎ¸Ì˚È ÒË„Ì‡Î (7)
begin
  case Lvl of
    tlFindTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end;
    end;
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    tlVZavTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else  result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end;
    end;
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    tlCheckTrace :
    begin
      result := trNextStep;
      if ObjZav[jmp.Obj].bParam[1] then //--------------------------------------------- œ—
      begin
        result := trBreak;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,116, ObjZav[jmp.Obj].Liter,1);
        InsMsg(Group,jmp.Obj,116); //------------ ŒÚÍ˚Ú ‚‡Ê‰Â·Ì˚È ÔË„Î‡ÒËÚÂÎ¸Ì˚È ÒË„Ì‡Î
        MarhTracert[Group].GonkaStrel := false;
      end;

      if Con.Pin = 1 then   //---------------------------------- ‚ÒÚÂ˜Ì˚È ÔË„Î‡ÒËÚÂÎ¸Ì˚È
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else  //----------------------------------------------- ÔÓÔÛÚÌ˚È ÔË„Î‡ÒËÚÂÎ¸Ì˚È
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign,
    tlSignalCirc :
    begin
      result := trNextStep;
      if ObjZav[jmp.Obj].bParam[1] then //--------------------------------------------- œ—
      begin
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,116, ObjZav[jmp.Obj].Liter,1);//---- ŒÚÍ˚Ú ‚‡Ê‰Â·Ì˚È ÔË„Î‡ÒËÚÂÎ¸Ì˚È
        InsMsg(Group,jmp.Obj,116);
      end;
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    else
    if Con.Pin = 1 then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else  result := trNextStep;
      end;
    end else
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else  result := trNextStep;
      end;
    end;
  end;
end;
//========================================================================================
function StepTraceUKSPS(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//----------------------------------------------------------------------------- ” —œ— (14)
begin
  case Lvl of
    tlFindTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end;
    end;
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    tlVZavTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end;
    end;
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    tlCheckTrace :
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          if ObjZav[jmp.Obj].BaseObject = MarhTracert[Group].ObjStart then
          begin
            if ObjZav[jmp.Obj].bParam[1] then //-------------------------------------- » —
            begin
              result := trBreak;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,124, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,124);
            end else
            begin
              if ObjZav[jmp.Obj].bParam[3] then //------------------------------------ 1 —
              begin
                result := trBreak;
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,125, ObjZav[jmp.Obj].Liter,0);
                InsMsg(Group,jmp.Obj,125);
                MarhTracert[Group].GonkaStrel := false;
              end;

              if ObjZav[jmp.Obj].bParam[4] then //------------------------------------ 2 —
              begin
                result := trBreak;
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,126, ObjZav[jmp.Obj].Liter,0);
                InsMsg(Group,jmp.Obj,126);
                MarhTracert[Group].GonkaStrel := false;
              end;

              if ObjZav[jmp.Obj].bParam[5] then //------------------------------------  Á 
              begin
                result := trBreak;
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,127, ObjZav[jmp.Obj].Liter,1);
                InsMsg(Group,jmp.Obj,127);
                MarhTracert[Group].GonkaStrel := false;
              end;
            end;
          end;
        end;

        MarshM,MarshL :
        begin
        end;

        else result := trStop;  exit;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign,
    tlSignalCirc :
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          if ObjZav[jmp.Obj].BaseObject = MarhTracert[Group].ObjStart then
          begin
            if ObjZav[jmp.Obj].bParam[1] then //-------------------------------------- » —
            begin
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,124, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,124);
            end else
            begin
              if ObjZav[jmp.Obj].bParam[3] then //------------------------------------ 1 —
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,125, ObjZav[jmp.Obj].Liter,0);
                InsMsg(Group,jmp.Obj,125);
              end;

              if ObjZav[jmp.Obj].bParam[4] then //------------------------------------ 2 —
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,126, ObjZav[jmp.Obj].Liter,0);
                InsMsg(Group,jmp.Obj,126);
              end;

              if ObjZav[jmp.Obj].bParam[5] then //------------------------------------  Á 
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,127, ObjZav[jmp.Obj].Liter,0);
                InsMsg(Group,jmp.Obj,127);
              end;
            end;
          end;
        end;

        MarshM,MarshL :
        begin
        end;

        else result := trStop; exit;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    else
    if Con.Pin = 1 then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else result := trNextStep;
      end;
    end else
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else result := trNextStep;
      end;
    end;
  end;
end;
//========================================================================================
function StepTraceVSN(var Con:TOZNeighbour; const Lvl:TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//---------------------------------------------- ¬ÒÔÓÏÓ„‡ÚÂÎ¸Ì‡ˇ ÒÏÂÌ‡ Ì‡Ô‡‚ÎÂÌËˇ ¿¡ (16)
begin
  case Lvl of
    tlFindTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else     result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else     result := trNextStep;
        end;
      end;
    end;

    tlVZavTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else     result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end;
    end;

    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign,
    tlSignalCirc,
    tlCheckTrace :
    begin
      case Rod of
        MarshP : begin      end;
        MarshM : begin      end;
        else  result := trStop;  exit;
      end;

      result := trNextStep;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    else
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trEnd;
          else  result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trEnd;
          else result := trNextStep;
        end;
      end;
  end;
end;
//========================================================================================
function StepTraceUvazManRn(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------------------------------- ”‚ˇÁÍ‡ Ò Ï‡ÌÂ‚Ó‚˚Ï ‡ÈÓÌÓÏ (23)
begin
  case Lvl of
    tlFindTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end;
    end;

    tlVZavTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end;
    end;

    tlCheckTrace :
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,244, '',1);
          InsMsg(Group,jmp.Obj,244);    //----------------------- "ÕÂÚ ÔÓÂÁ‰Ì˚ı Ï‡¯ÛÚÓ‚"
          MarhTracert[Group].GonkaStrel := false;
        end;

        MarshM :
        begin
         case Con.Pin of
          1 :
          begin
            if not ObjZav[jmp.Obj].bParam[1] then //---------------------------------- ”Ãœ
            begin
              result := trBreak;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,245, ObjZav[jmp.Obj].Liter,1);
              InsMsg(Group,jmp.Obj,245);
              MarhTracert[Group].GonkaStrel := false;
            end;
          end;

          else
            if not ObjZav[jmp.Obj].bParam[2] then //---------------------------------- ”ÃŒ
            begin
              result := trBreak;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,245, ObjZav[jmp.Obj].Liter,1);
              InsMsg(Group,jmp.Obj,245);
              MarhTracert[Group].GonkaStrel := false;
            end;
         end;
        end;
        else
          result := trStop;
          exit;
        end;

        if Con.Pin = 1 then
        begin
          Con := ObjZav[jmp.Obj].Neighbour[2];
          case Con.TypeJmp of
            LnkRgn : result := trStop;
            LnkEnd : result := trStop;
          end;
        end else
        begin
          Con := ObjZav[jmp.Obj].Neighbour[1];
          case Con.TypeJmp of
            LnkRgn : result := trStop;
            LnkEnd : result := trStop;
          end;
        end;
      end;

      tlAutoTrace,
      tlPovtorRazdel,
      tlRazdelSign,
      tlSignalCirc :
      begin
        result := trNextStep;
        case Rod of
          MarshP :
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,244, '',1);
            InsMsg(Group,jmp.Obj,244);
          end;

          MarshM :
          begin
              case Con.Pin of
                1 :
                begin
                  if not ObjZav[jmp.Obj].bParam[1] then //---------------------------- ”Ãœ
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,245, ObjZav[jmp.Obj].Liter,1);
                    InsMsg(Group,jmp.Obj,245);
                  end;
                end;
              else
                if not ObjZav[jmp.Obj].bParam[2] then //------------------------------ ”ÃŒ
                begin
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,245, ObjZav[jmp.Obj].Liter,1);
                  InsMsg(Group,jmp.Obj,245);
                end;
              end;
            end;
          else
            result := trStop;
            exit;
          end;
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end;
        end;

      else
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end;
      end;
    end;
//========================================================================================
function StepTraceZaprosPoezdOtpr(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//--------------------------------------------- «‡ÔÓÒ ÒÓ„Î‡ÒËˇ ÔÓÂÁ‰ÌÓ„Ó ÓÚÔ‡‚ÎÂÌËˇ (24)
begin
  case Lvl of
    tlFindTrace : result := trRepeat;

    tlContTrace :
    begin
      MarhTracert[Group].FullTail := true;
      result := trEndTrace;
    end;

    tlVZavTrace : result := trStop;

    tlCheckTrace :
    begin
      result := trEndTrace;
      case Rod of
        MarshP :
        begin
          if not ObjZav[jmp.Obj].bParam[13] then //------------------------------------ ‘—
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,246, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,246); //------------------- ÕÂÚ ÒÓ„Î‡ÒËˇ ÔÓÂÁ‰ÌÓ„Ó ÔËÂÏ‡
            MarhTracert[Group].GonkaStrel := false;
          end;

          if ObjZav[jmp.Obj].bParam[3] then //--------------------------------------- Õ›√—
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,105, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,105);//-------- Õ‡Ê‡Ú‡ ÍÌÓÔÍ‡ ˝ÍÒÚÂÌÌÓ„Ó „‡¯ÂÌËˇ ÒË„Ì‡Î‡
            MarhTracert[Group].GonkaStrel := false;
          end;

          if not ObjZav[jmp.Obj].bParam[8] then //------------------------------------- ˜Ë
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,248, ObjZav[jmp.Obj].Title,1);
            InsMsg(Group,jmp.Obj,248); //---------- ”ÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ
          end;

          if ObjZav[jmp.Obj].bParam[9] then //---------------------------------------- ˜ÍÏ
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,249, ObjZav[jmp.Obj].Title,1);
            InsMsg(Group,jmp.Obj,249); //-------- ”ÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
          end;

          if not ObjZav[jmp.Obj].bParam[7] then //-------------------------------------- Ô
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,250, ObjZav[jmp.Obj].Title,1);
            InsMsg(Group,jmp.Obj,250); //------------------------- «‡ÌˇÚ Û˜‡ÒÚÓÍ ÔÓ Û‚ˇÁÍÂ
          end;

          if ObjZav[jmp.Obj].bParam[14] or
          ObjZav[jmp.Obj].bParam[15] then //------------------------- ÔÂÂ„ÓÌ Á‡·ÎÓÍËÓ‚‡Ì
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,432, ObjZav[jmp.Obj].Title,1);
            InsMsg(Group,jmp.Obj,432);  //------------------------------ œÂÂ„ÓÌ $ Á‡Í˚Ú#
            MarhTracert[Group].GonkaStrel := false;
          end;

          if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then
          begin
            if ObjZav[jmp.Obj].bParam[24] or
            ObjZav[jmp.Obj].bParam[27] then //--------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú.
            begin
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,462, ObjZav[jmp.Obj].Title,1);
              InsWar(Group,jmp.Obj,462); //--------------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â
            end else
            if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
            begin
              if ObjZav[jmp.Obj].bParam[25] or
              ObjZav[jmp.Obj].bParam[28] then //----------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,467, ObjZav[jmp.Obj].Title,1);
                InsWar(Group,jmp.Obj,467); // «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÓÒÚÓˇÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
              end;

              if ObjZav[jmp.Obj].bParam[26] or
              ObjZav[jmp.Obj].bParam[29] then //------------ «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,472, ObjZav[jmp.Obj].Title,1);
                InsWar(Group,jmp.Obj,472); //-- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÂÂÏÂÌÌÓ„Ó ÚÓÍ‡ ÔÓ
              end;
            end;
          end else
          begin //--------------------------------------- ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÔÓ‚Ó‰‡
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,474, ObjZav[jmp.Obj].Title,1);
            InsWar(Group,jmp.Obj,474);
          end;
        end;

        MarshM : begin        end;

        else  result := trStop; exit;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign,
    tlSignalCirc :
    begin
      result := trEndTrace;
      case Rod of
        MarshP :
        begin
          if not ObjZav[jmp.Obj].bParam[13] then //------------------------------------ ‘—
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,246, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,246);   //----------------- ÕÂÚ ÒÓ„Î‡ÒËˇ ÔÓÂÁ‰ÌÓ„Ó ÔËÂÏ‡
          end;

          if ObjZav[jmp.Obj].bParam[3] then //--------------------------------------- Õ›√—
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,105, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,105);
          end;

          if not ObjZav[jmp.Obj].bParam[8] then //------------------------------------- ˜Ë
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,248, ObjZav[jmp.Obj].Title,1);
            InsMsg(Group,jmp.Obj,248);  //--------- ”ÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ
          end;

          if ObjZav[jmp.Obj].bParam[9] then //---------------------------------------- ˜ÍÏ
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,249, ObjZav[jmp.Obj].Title,1);
            InsMsg(Group,jmp.Obj,249); //-------- ”ÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
          end;

          if not ObjZav[jmp.Obj].bParam[7] then //-------------------------------------- Ô
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,250, ObjZav[jmp.Obj].Title,1);
            InsMsg(Group,jmp.Obj,250); //------------------------- «‡ÌˇÚ Û˜‡ÒÚÓÍ ÔÓ Û‚ˇÁÍÂ
          end;

          if ObjZav[jmp.Obj].bParam[14] or
          ObjZav[jmp.Obj].bParam[15] then //------------------------- ÔÂÂ„ÓÌ Á‡·ÎÓÍËÓ‚‡Ì
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,432, ObjZav[jmp.Obj].Title,1);
            InsMsg(Group,jmp.Obj,432); //-------------------------------- œÂÂ„ÓÌ $ Á‡Í˚Ú
          end;

          if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then
          begin
            if ObjZav[jmp.Obj].bParam[24] or
            ObjZav[jmp.Obj].bParam[27] then //--------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú.
            begin
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,462, ObjZav[jmp.Obj].Title,1);
              InsWar(Group,jmp.Obj,462); //------------ «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ
            end else
            if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
            begin
              if ObjZav[jmp.Obj].bParam[25] or
              ObjZav[jmp.Obj].bParam[28] then //----------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,467, ObjZav[jmp.Obj].Title,1);
                InsWar(Group,jmp.Obj,467); //-- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÓÒÚÓˇÌÌÓ„Ó ÚÓÍ‡ ÔÓ
              end;

              if ObjZav[jmp.Obj].bParam[26] or
              ObjZav[jmp.Obj].bParam[29] then //------------ «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,472, ObjZav[jmp.Obj].Title,1);
                InsWar(Group,jmp.Obj,472); //-----------------  ÓÌÂˆ ÍÓÌÚ‡ÍÚÌÓÈ ÔÓ‰‚ÂÒÍË $
              end;
            end;
          end else
          begin //--------------------------------------- ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÔÓ‚Ó‰‡
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,474, ObjZav[jmp.Obj].Title,1);
            InsWar(Group,jmp.Obj,474);   //-------------- ”˜‡ÒÚÓÍ $ ÌÂ ˝ÎÂÍÚËÙËˆËÓ‚‡ÌÌ˚È
          end;
        end;

        MarshM : begin      end;

        else  result := trStop; exit;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlFindIzvest :
    begin
      if (not ObjZav[jmp.Obj].bParam[5] and
      not ObjZav[jmp.Obj].bParam[8]) or
      not ObjZav[jmp.Obj].bParam[7] then //---------------------------- «‡ÌˇÚÓ ÔË·ÎËÊÂÌËÂ
      result := trBreak
      else result := trStop;
    end;

    tlFindIzvStrel : result := trStop;

    else
    if Con.Pin = 1 then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else result := trNextStep;
      end;
    end else
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else result := trNextStep;
      end;
    end;
  end;
end;
//========================================================================================
function StepTracePAB(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//-------------------------------------------------------------------------------- œ¿¡(26)
begin
  case Lvl of
    tlFindTrace :
    begin
      result := trNextStep;
      if not MarhTracert[Group].LvlFNext then
      begin
        if Con.Pin = 1 then
        begin
          Con := ObjZav[jmp.Obj].Neighbour[2];
          case Con.TypeJmp of
            LnkRgn : result := trRepeat;
            LnkEnd : result := trRepeat;
          end;
        end else
        begin
          Con := ObjZav[jmp.Obj].Neighbour[1];
          case Con.TypeJmp of
            LnkRgn : result := trRepeat;
            LnkEnd : result := trRepeat;
          end;
        end;
      end;
    end;

    tlPovtorMarh,
    tlContTrace :
    begin
      case Rod of
        MarshP :
          if ObjZav[jmp.Obj].ObjConstB[1] then result := trEndTrace
          else result := trStop;

        MarshM : result := trStop;

        else result := trEndTrace;
      end;
    end;

    tlVZavTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end;
    end;

    tlCheckTrace :
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          if ObjZav[jmp.Obj].bParam[12] or
          ObjZav[jmp.Obj].bParam[13] then //------------------------- ÔÂÂ„ÓÌ Á‡·ÎÓÍËÓ‚‡Ì
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,432, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,432);  //------------------------------ œÂÂ„ÓÌ $ Á‡Í˚Ú#
            MarhTracert[Group].GonkaStrel := false;
          end;

          if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then
          begin
            if ObjZav[jmp.Obj].bParam[24] or
            ObjZav[jmp.Obj].bParam[27] then //------------------ «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ›“
            begin
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,462); //------------ «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ
            end else
            if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
            begin
              if ObjZav[jmp.Obj].bParam[25] or
              ObjZav[jmp.Obj].bParam[28] then //----------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
                InsWar(Group,jmp.Obj,467); // «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÓÒÚÓˇÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
              end;

              if ObjZav[jmp.Obj].bParam[26] or
              ObjZav[jmp.Obj].bParam[29] then //------------ «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
                InsWar(Group,jmp.Obj,472); // «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÂÂÏÂÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
              end;
            end;
          end else
          begin //--------------------------------------- ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÔÓ‚Ó‰‡
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,474, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,474); //---------------- ”˜‡ÒÚÓÍ $ ÌÂ ˝ÎÂÍÚËÙËˆËÓ‚‡ÌÌ˚È
          end;

          if not ObjZav[jmp.Obj].bParam[7] then //------------------- ’ÓÁÔÓÂÁ‰ Ì‡ ÔÂÂ„ÓÌÂ
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,130, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,130); //-------- ŒÚÔ‡‚ÎÂÌ ıÓÁˇÈÒÚ‚ÂÌÌ˚È ÔÓÂÁ‰ Ì‡ ÔÂÂ„ÓÌ
            MarhTracert[Group].GonkaStrel := false;
          end else
          if not ObjZav[jmp.Obj].bParam[1] then //---------------- œÂÂ„ÓÌ Á‡ÌˇÚ ÔÓ ÔËÂÏÛ
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,318, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,318); //----------------------- œÂÂ„ÓÌ $ Á‡ÌˇÚ ÔÓ ÔËÂÏÛ
            MarhTracert[Group].GonkaStrel := false;
          end else
          if ObjZav[jmp.Obj].bParam[2] then //------------------- œÓÎÛ˜ÂÌÓ ÔË·˚ÚËÂ ÔÓÂÁ‰‡
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,319, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,319); //------------ œÓÎÛ˜ÂÌÓ ÔË·˚ÚËÂ ÔÓÂÁ‰‡ Ì‡ ÔÂÂ„ÓÌÂ
            MarhTracert[Group].GonkaStrel := false;
          end else
          if ObjZav[jmp.Obj].bParam[4] then //-------- ¬˚‰‡ÌÓ ÒÓ„Î‡ÒËÂ Ì‡ ÒÓÒÂ‰Ì˛˛ ÒÚ‡ÌˆË˛
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,320, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,320); // ¬˚‰‡ÌÓ ÒÓ„Î‡ÒËÂ ÓÚÔ‡‚ÎÂÌËˇ ÔÓÂÁ‰‡ Ì‡ ÔÂÂ„ÓÌÂ $
            MarhTracert[Group].GonkaStrel := false;
          end else
          if ObjZav[jmp.Obj].bParam[6] then //----------------------- ÒÓ„Î‡ÒËÂ ÓÚÔ‡‚ÎÂÌËˇ
          begin
            if not ObjZav[jmp.Obj].bParam[5] then //ÂÒÚ¸ Á‡ÌˇÚÓÒÚ¸ ÔÂÂ„ÓÌ‡ ÔÓ ÓÚÔ‡‚ÎÂÌË˛
            begin
              result := trBreak;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,299, ObjZav[jmp.Obj].Liter,1);
              InsMsg(Group,jmp.Obj,299); //---------------- œÂÂ„ÓÌ $ Á‡ÌˇÚ ÔÓ ÓÚÔ‡‚ÎÂÌË˛
              MarhTracert[Group].GonkaStrel := false;
            end;
          end else
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,237, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,237); //------------- ÕÂÚ ÒÓ„Î‡ÒËˇ ÓÚÔ‡‚ÎÂÌËˇ Ì‡ ÔÂÂ„ÓÌ
          end;

          if not ObjZav[jmp.Obj].bParam[9] then //---------------------- «‡ÌˇÚ ËÁ‚ÂÒÚËÚÂÎ¸
          begin
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83);  //--------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
          end;
        end;

        MarshM :  begin  end;

        else  result := trStop; exit;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign,
    tlSignalCirc :
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          if ObjZav[jmp.Obj].bParam[12] or
          ObjZav[jmp.Obj].bParam[13] then //------------------------- ÔÂÂ„ÓÌ Á‡·ÎÓÍËÓ‚‡Ì
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,432, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,432); //-------------------------------- œÂÂ„ÓÌ $ Á‡Í˚Ú
          end;

          if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then
          begin
            if ObjZav[jmp.Obj].bParam[24] or
            ObjZav[jmp.Obj].bParam[27] then //--------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú.
            begin
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,462); //---------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
            end else
            if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
            begin
              if ObjZav[jmp.Obj].bParam[25] or
              ObjZav[jmp.Obj].bParam[28] then //----------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
                InsWar(Group,jmp.Obj,467);
              end;

              if ObjZav[jmp.Obj].bParam[26] or
              ObjZav[jmp.Obj].bParam[29] then //------------ «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
              begin
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
                InsWar(Group,jmp.Obj,472); //-- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÂÂÏÂÌÌÓ„Ó ÚÓÍ‡ ÔÓ
              end;
            end;
          end else
          begin //-------------------------------------- ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓ„Ó ÔÓ‚Ó‰‡
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,474, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,474);
          end;

          if not ObjZav[jmp.Obj].bParam[7] then //------------------- ’ÓÁÔÓÂÁ‰ Ì‡ ÔÂÂ„ÓÌÂ
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,130, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,130); //------ ŒÚÔ‡‚ÎÂÌ ıÓÁˇÈÒÚ‚ÂÌÌ˚È ÔÓÂÁ‰ Ì‡ ÔÂÂ„ÓÌ $
          end else
          if not ObjZav[jmp.Obj].bParam[1] then //---------------- œÂÂ„ÓÌ Á‡ÌˇÚ ÔÓ ÔËÂÏÛ
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,318, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,318); //----------------------- œÂÂ„ÓÌ $ Á‡ÌˇÚ ÔÓ ÔËÂÏÛ
          end else
          if ObjZav[jmp.Obj].bParam[2] then //------------------- œÓÎÛ˜ÂÌÓ ÔË·˚ÚËÂ ÔÓÂÁ‰‡
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,319, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,319); //---------- œÓÎÛ˜ÂÌÓ ÔË·˚ÚËÂ ÔÓÂÁ‰‡ Ì‡ ÔÂÂ„ÓÌÂ $
          end else
          if ObjZav[jmp.Obj].bParam[4] then //-------- ¬˚‰‡ÌÓ ÒÓ„Î‡ÒËÂ Ì‡ ÒÓÒÂ‰Ì˛˛ ÒÚ‡ÌˆË˛
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,320, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,320); // ¬˚‰‡ÌÓ ÒÓ„Î‡ÒËÂ ÓÚÔ‡‚ÎÂÌËˇ ÔÓÂÁ‰‡ Ì‡ ÔÂÂ„ÓÌÂ $
          end else
          if ObjZav[jmp.Obj].bParam[6] then //----------------------- ÒÓ„Î‡ÒËÂ ÓÚÔ‡‚ÎÂÌËˇ
          begin
            if not ObjZav[jmp.Obj].bParam[5] then //ÂÒÚ¸ Á‡ÌˇÚÓÒÚ¸ ÔÂÂ„ÓÌ‡ ÔÓ ÓÚÔ‡‚ÎÂÌË˛
            begin
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,299, ObjZav[jmp.Obj].Liter,1);
              InsMsg(Group,jmp.Obj,299); //---------------- œÂÂ„ÓÌ $ Á‡ÌˇÚ ÔÓ ÓÚÔ‡‚ÎÂÌË˛
            end;
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,237, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,237);  //------------ ÕÂÚ ÒÓ„Î‡ÒËˇ ÓÚÔ‡‚ÎÂÌËˇ Ì‡ ÔÂÂ„ÓÌ
          end;

          if not ObjZav[jmp.Obj].bParam[9] then //---------------------- «‡ÌˇÚ ËÁ‚ÂÒÚËÚÂÎ¸
          begin
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83); //---------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
          end;
        end;

        MarshM : begin  end;

        else  result := trStop; exit;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlFindIzvest :
      if not ObjZav[jmp.Obj].bParam[9] then  result := trBreak  //----- «‡ÌˇÚÓ ÔË·ÎËÊÂÌËÂ
      else result := trStop;


    tlFindIzvStrel : result := trStop;

    else
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trEnd;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trEnd;
          else result := trNextStep;
        end;
      end;
  end;
end;
//========================================================================================
function StepTraceDZOhr(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//---------------------------------------------------------------- Œı‡ÌÌÓÒÚË ÒÚÂÎÓÍ (27)
var
  o,k,m : integer;
  tr : boolean;
begin
  case Lvl of
    tlFindTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end;
    end;

    tlVZavTrace : //------------------------- ÔÓ‚ÂÍ‡ Óı‡ÌÌÓ„Ó ÔÓÎÓÊÂÌËˇ ÔË Ú‡ÒÒËÓ‚ÍÂ
    begin
      o := ObjZav[jmp.Obj].ObjConstI[1]; //------------------------ ÍÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡
      k := ObjZav[jmp.Obj].ObjConstI[3]; //------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡
      if (o > 0) and (k > 0) then
      begin
        tr := ObjZav[k].bParam[6] or ObjZav[k].bParam[7] or
        ObjZav[k].bParam[10] or ObjZav[k].bParam[11] or
        ObjZav[k].bParam[12] or ObjZav[k].bParam[13];

        m := ObjZav[k].BaseObject;

        if (ObjZav[m].ObjConstI[8] = k) and (ObjZav[m].ObjConstI[9] > 0) then
        m := ObjZav[m].ObjConstI[9]
        else
        if ObjZav[m].ObjConstI[8] > 0
        then m := ObjZav[m].ObjConstI[8] else m := 0;

        if m > 0 then
        tr := tr or ObjZav[k].bParam[6] or ObjZav[k].bParam[7] or
        ObjZav[m].bParam[10] or ObjZav[m].bParam[11] or
        ObjZav[m].bParam[12] or ObjZav[m].bParam[13];

        if ObjZav[jmp.Obj].ObjConstB[5] or tr then
        begin //---------------------------- ‚˚ÔÓÎÌˇÂÚÒˇ „ÓÌÍ‡ Óı‡ÌÌÓÈ ÒÚÂÎÍË ‚ Ï‡¯ÛÚÂ
          if ObjZav[jmp.Obj].ObjConstB[1] then // ÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡ Óı‡ÌˇÂÚÒˇ ‚ ÔÎ˛ÒÂ
          begin
            if ((ObjZav[o].bParam[10] and not ObjZav[o].bParam[11])
            or ObjZav[o].bParam[12]) then
            begin
              if ObjZav[jmp.Obj].ObjConstB[3] then //-------- Óı‡ÌÌ‡ˇ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÔÎ˛ÒÂ
              begin
                if (ObjZav[k].bParam[10] and ObjZav[k].bParam[11]) or
                ((ObjZav[o].ObjConstI[20] = 0) and ObjZav[k].bParam[7]) or
                ObjZav[k].bParam[13] then
                begin
                  if (ObjZav[o].UpdateObject <> ObjZav[k].UpdateObject) and //-- ‡ÁÌ˚Â —œ
                  not ObjZav[k].bParam[14] then //-- ÌÂ ‚˚‰‡Ì‡ Ï‡¯ÛÚÌ‡ˇ ÍÓÏ‡Ì‰‡ ‚ ÒÂ‚Â
                  begin
                    result := trStop;
                    exit; //----------------------- Óı‡ÌÌ‡ˇ Ú‡ÒÒËÛÂÚÒˇ ‚ ÏËÌÛÒÂ - ÓÚÍ‡Á
                  end;
                end;
              end else
              if ObjZav[jmp.Obj].ObjConstB[4] then //------- Óı‡ÌÌ‡ˇ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÏËÌÛÒÂ
              begin
                if (ObjZav[k].bParam[10] and not ObjZav[k].bParam[11]) or
                ((ObjZav[o].ObjConstI[20] = 0) and ObjZav[k].bParam[6]) or
                ObjZav[k].bParam[12] then
                begin
                  if (ObjZav[o].UpdateObject <> ObjZav[k].UpdateObject) and //-- ‡ÁÌ˚Â —œ
                  not ObjZav[k].bParam[14] then //-- ÌÂ ‚˚‰‡Ì‡ Ï‡¯ÛÚÌ‡ˇ ÍÓÏ‡Ì‰‡ ‚ ÒÂ‚Â
                  begin
                    result := trStop; exit; //------ Óı‡ÌÌ‡ˇ Ú‡ÒÒËÛÂÚÒˇ ‚ ÔÎ˛ÒÂ - ÓÚÍ‡Á
                  end;
                end;
              end;
            end;
          end else
          if ObjZav[jmp.Obj].ObjConstB[2] then// ÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡ Óı‡ÌˇÂÚÒˇ ‚ ÏËÌÛÒÂ
          begin
            if ((ObjZav[o].bParam[10] and ObjZav[o].bParam[11]) or
            ObjZav[o].bParam[13]) then
            begin
              if ObjZav[jmp.Obj].ObjConstB[3] then //-------- Óı‡ÌÌ‡ˇ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÔÎ˛ÒÂ
              begin
                if (ObjZav[k].bParam[10] and ObjZav[k].bParam[11]) or
                ((ObjZav[o].ObjConstI[20] = 0) and ObjZav[k].bParam[7]) or
                ObjZav[k].bParam[13] then
                begin
                  if (ObjZav[o].UpdateObject <> ObjZav[k].UpdateObject) and //-- ‡ÁÌ˚Â —œ
                  not ObjZav[k].bParam[14] then //-- ÌÂ ‚˚‰‡Ì‡ Ï‡¯ÛÚÌ‡ˇ ÍÓÏ‡Ì‰‡ ‚ ÒÂ‚Â
                  begin
                    result := trStop; exit; //----- Óı‡ÌÌ‡ˇ Ú‡ÒÒËÛÂÚÒˇ ‚ ÏËÌÛÒÂ - ÓÚÍ‡Á
                  end;
                end;
              end else
              if ObjZav[jmp.Obj].ObjConstB[4] then //------- Óı‡ÌÌ‡ˇ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÏËÌÛÒÂ
              begin
                if (ObjZav[k].bParam[10] and not ObjZav[k].bParam[11]) or
                ((ObjZav[o].ObjConstI[20] = 0) and ObjZav[k].bParam[6]) or
                ObjZav[k].bParam[12] then
                begin
                  if (ObjZav[o].UpdateObject <> ObjZav[k].UpdateObject) and //-- ‡ÁÌ˚Â —œ
                  not ObjZav[k].bParam[14] then //-- ÌÂ ‚˚‰‡Ì‡ Ï‡¯ÛÚÌ‡ˇ ÍÓÏ‡Ì‰‡ ‚ ÒÂ‚Â
                  begin
                    result := trStop; exit; //------ Óı‡ÌÌ‡ˇ Ú‡ÒÒËÛÂÚÒˇ ‚ ÔÎ˛ÒÂ - ÓÚÍ‡Á
                  end;
                end;
              end;
            end;
          end;
        end else
        begin //------------------------- ÌÂ ‚˚ÔÓÎÌˇÂÚÒˇ „ÓÌÍ‡ Óı‡ÌÌÓÈ ÒÚÂÎÍË ‚ Ï‡¯ÛÚÂ
          if ((jmp.Pin = 1) and not ObjZav[jmp.Obj].ObjConstB[6]) or
          ((jmp.Pin = 2) and not ObjZav[jmp.Obj].ObjConstB[7]) then
          begin
            if ObjZav[jmp.Obj].ObjConstB[1] then //-  ÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡ Óı‡ÌˇÂÚÒˇ ‚ +
            begin
              if ((ObjZav[o].bParam[10] and not ObjZav[o].bParam[11]) or
              ObjZav[o].bParam[12]) then
              begin
                if ObjZav[jmp.Obj].ObjConstB[3] then //------ Óı‡ÌÌ‡ˇ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÔÎ˛ÒÂ
                begin
                  if not (ObjZav[k].bParam[1] and not ObjZav[k].bParam[2]) then
                  begin //--------------------- Óı‡ÌÌ‡ˇ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÔÎ˛ÒÂ - ÓÚÍ‡Á
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268,ObjZav[ObjZav[k].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[k].BaseObject,268); //- ÕÂÚ ÍÓÌÚÓÎˇ ÔÎ˛Ò‡ ÒÚÂÎÍË
                    result := trStop;
                    exit;
                  end;
                end else
                if ObjZav[jmp.Obj].ObjConstB[4] then //----- Óı‡ÌÌ‡ˇ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÏËÌÛÒÂ
                begin
                  if not (not ObjZav[k].bParam[1] and ObjZav[k].bParam[2]) then
                  begin //-------------------- Óı‡ÌÌ‡ˇ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÏËÌÛÒÂ - ÓÚÍ‡Á
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,267,ObjZav[ObjZav[k].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[k].BaseObject,267); // ÕÂÚ ÍÓÌÚÓÎˇ ÏËÌÛÒ‡ ÒÚÂÎÍË
                    result := trStop;
                    exit;
                  end;
                end;
              end;
            end else
            if ObjZav[jmp.Obj].ObjConstB[2] then //-  ÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡ Óı‡ÌˇÂÚÒˇ ‚ -
            begin
              if ((ObjZav[o].bParam[10] and ObjZav[o].bParam[11]) or
              ObjZav[o].bParam[13]) then
              begin
                if ObjZav[jmp.Obj].ObjConstB[3] then //------ Óı‡ÌÌ‡ˇ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÔÎ˛ÒÂ
                begin
                  if not (ObjZav[k].bParam[1] and not ObjZav[k].bParam[2]) then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268,ObjZav[ObjZav[k].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[k].BaseObject,268); //- ÕÂÚ ÍÓÌÚÓÎˇ ÔÎ˛Ò‡ ÒÚÂÎÍË
                    result := trStop;
                    exit;
                  end;
                end else
                if ObjZav[jmp.Obj].ObjConstB[4] then //----- Óı‡ÌÌ‡ˇ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÏËÌÛÒÂ
                begin
                  if not (not ObjZav[k].bParam[1] and ObjZav[k].bParam[2]) then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,267,ObjZav[ObjZav[k].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[k].BaseObject,267); // ÕÂÚ ÍÓÌÚÓÎˇ ÏËÌÛÒ‡ ÒÚÂÎÍË
                    result := trStop; exit;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;

      //--------------------------------------------------- Õ‡ÈÚË ÒÎÂ‰Û˛˘ËÈ ˝ÎÂÏÂÌÚ Ú‡ÒÒ˚
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end;
    end;

    tlCheckTrace :
    begin
      result := trNextStep;
      //------------ ÔÓ‚ÂÍ‡ ‚ÓÁÏÓÊÌÓÒÚË ÛÒÚ‡ÌÓ‚ÍË Óı‡ÌÌÓÈ ÒÚÂÎÍË ‚ ÚÂ·ÛÂÏÓÂ ÔÓÎÓÊÂÌËÂ
      o := ObjZav[jmp.Obj].ObjConstI[1]; //------------------------ ÍÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡
      k := ObjZav[jmp.Obj].ObjConstI[3]; //------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡

      if (o > 0) and (k > 0) then
      begin
        if ObjZav[jmp.Obj].ObjConstB[1] then
        begin
          if ((ObjZav[o].bParam[10] and not ObjZav[o].bParam[11]) or
          ObjZav[o].bParam[12]) then //---------- ÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡ Óı‡ÌˇÂÚÒˇ ‚ ÔÎ˛ÒÂ
          begin
            if ObjZav[jmp.Obj].ObjConstB[3] then //-- Œı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÔÎ˛ÒÂ
            begin
              if ObjZav[o].ObjConstI[20] = k then
              begin //--------- Ò‰ÂÎ‡Ú¸ ÔÓ‚ÂÍË Ú‡ÒÒËÓ‚ÍË ÒÂÍÛ˘Â„Ó Ï‡¯ÛÚ‡ ˜ÂÂÁ ÍÂÒÚ
                if ObjZav[ObjZav[k].BaseObject].bParam[7] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,117, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,117);// —œ Á‡ÏÍÌÛÚ‡(ÒÚ. ‚ Ï‡¯ÛÚÂ +)
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;

              if not ObjZav[k].bParam[1] then
              begin
                if not MarhTracert[Group].Povtor and not MarhTracert[Group].Dobor then
                inc(MarhTracert[Group].GonkaList); // Û‚ÂÎË˜ËÚ¸ ˜ËÒÎÓ ÒÚÂÎÓÍ, Ò ÔÂÂ‚Ó‰ÓÏ

                if not ObjZav[k].bParam[2] then //----------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                begin
                  if not ObjZav[k].bParam[6] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,81, ObjZav[ObjZav[k].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[k].BaseObject,81); //------ —ÚÂÎÍ‡ $ ·ÂÁ ÍÓÌÚÓÎˇ
                    result := trBreak;
                    MarhTracert[Group].GonkaStrel := false;
                  end;
                end else
                if not ObjZav[ObjZav[k].BaseObject].bParam[21] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,117, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,117);// —œ Á‡ÏÍÌÛÚ‡(ÒÚ. ‚ Ï‡¯ÛÚÂ +)
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].ObjConstB[3] and//--- Ì‡‰Ó ÔÓ‚ÂˇÚ¸ Ã—œ Ë
                not ObjZav[ObjZav[k].BaseObject].bParam[20] then //..... Ë‰ÂÚ ‚˚‰ÂÊÍ‡ Ã—œ
                begin
                  InsArcNewMsg(ObjZav[k].BaseObject,392+$4000,1);
                  ShowShortMsg(392,LastX,LastY,ObjZav[ObjZav[k].BaseObject].Liter);
                  result := trBreak;
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,392, ObjZav[k].Liter,1);
                  InsMsg(Group,k,392); //- »‰ÂÚ ‚˚‰ÂÊÍ‡ ‚ÂÏÂÌË ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËˇ ÒÚÂÎÍË
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].bParam[4] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,80, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,80); //------------ —ÚÂÎÍ‡ $ Á‡ÏÍÌÛÚ‡
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if not ObjZav[ObjZav[k].BaseObject].bParam[22] then
                begin //------------------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÌˇÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,118, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,118);//—œ Á‡ÌˇÚ‡ ÒÚ $ ‚ Ï‡¯ÛÚÂ ÔÓ +
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].bParam[19] then
                begin //--------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,136, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,136);// —Ú Ì‡ Ï‡ÍÂÚÂ(‰ÓÎÊÌ‡ ·˚Ú¸ ÔÓ+)
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[k].bParam[18] then
                begin //--------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,121, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,121);//—Ú ‚˚ÍÎ˛˜ÂÌ‡ (‚ Ï‡¯ÛÚÂ ÔÓ +)
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;
            end else
            if ObjZav[jmp.Obj].ObjConstB[4] then //- Œı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÏËÌÛÒÂ
            begin
              if ObjZav[o].ObjConstI[20] = k then
              begin //--------- Ò‰ÂÎ‡Ú¸ ÔÓ‚ÂÍË Ú‡ÒÒËÓ‚ÍË ÒÂÍÛ˘Â„Ó Ï‡¯ÛÚ‡ ˜ÂÂÁ ÍÂÒÚ
                if ObjZav[ObjZav[k].BaseObject].bParam[6] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,117, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,117);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;

              if ObjZav[ObjZav[k].BaseObject].ObjConstB[3] and//--- Ì‡‰Ó ÔÓ‚ÂˇÚ¸ Ã—œ Ë
                not ObjZav[ObjZav[k].BaseObject].bParam[20] then //..... Ë‰ÂÚ ‚˚‰ÂÊÍ‡ Ã—œ
                begin
                  InsArcNewMsg(ObjZav[k].BaseObject,392+$4000,1);
                  ShowShortMsg(392,LastX,LastY,ObjZav[ObjZav[k].BaseObject].Liter);
                  result := trBreak;
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,392, ObjZav[k].Liter,1);
                  InsMsg(Group,k,392); //- »‰ÂÚ ‚˚‰ÂÊÍ‡ ‚ÂÏÂÌË ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËˇ ÒÚÂÎÍË
                  MarhTracert[Group].GonkaStrel := false;
                end;

              if not ObjZav[k].bParam[2] then
              begin
                if not MarhTracert[Group].Povtor and not MarhTracert[Group].Dobor then
                inc(MarhTracert[Group].GonkaList); // Û‚ÂÎË˜ËÚ¸ ˜ËÒÎÓ ÔÂÂ‚ÓÓ‰ËÏ˚ı ÒÚÂÎÓÍ
                if not ObjZav[k].bParam[1] then
                begin //------------------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                  if not ObjZav[k].bParam[7] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,81, ObjZav[ObjZav[k].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[k].BaseObject,81);
                    result := trBreak;
                    MarhTracert[Group].GonkaStrel := false;
                  end;
                end else
                if not ObjZav[ObjZav[k].BaseObject].bParam[21] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,157, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,157);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].bParam[4] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,80, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,80);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if not ObjZav[ObjZav[k].BaseObject].bParam[22] then
                begin //------------------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÌˇÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,158, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,158);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].bParam[19] then
                begin //--------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,137, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,137);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[k].bParam[18] then
                begin //--------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,159, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,159);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;
            end;
          end;
        end else
        if ObjZav[jmp.Obj].ObjConstB[2] then
        begin
          if ((ObjZav[o].bParam[10] and ObjZav[o].bParam[11]) or
          ObjZav[o].bParam[13]) then //--------  ÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡ Óı‡ÌˇÂÚÒˇ ‚ ÏËÌÛÒÂ
          begin
            if ObjZav[jmp.Obj].ObjConstB[3] then //-- Œı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÔÎ˛ÒÂ
            begin
              if ObjZav[o].ObjConstI[20] = k then
              begin //--------- Ò‰ÂÎ‡Ú¸ ÔÓ‚ÂÍË Ú‡ÒÒËÓ‚ÍË ÒÂÍÛ˘Â„Ó Ï‡¯ÛÚ‡ ˜ÂÂÁ ÍÂÒÚ
                if ObjZav[ObjZav[k].BaseObject].bParam[7] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,117, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,117);//—œ Á‡ÏÍÌÛÚ‡ (ÒÚÂÎÍ‡ ÌÛÊÌ‡ ‚ +)
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;

              if ObjZav[ObjZav[k].BaseObject].ObjConstB[3] and//--- Ì‡‰Ó ÔÓ‚ÂˇÚ¸ Ã—œ Ë
                not ObjZav[ObjZav[k].BaseObject].bParam[20] then //..... Ë‰ÂÚ ‚˚‰ÂÊÍ‡ Ã—œ
                begin
                  InsArcNewMsg(ObjZav[k].BaseObject,392+$4000,1);
                  ShowShortMsg(392,LastX,LastY,ObjZav[ObjZav[k].BaseObject].Liter);
                  result := trBreak;
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,392, ObjZav[k].Liter,1);
                  InsMsg(Group,k,392); //- »‰ÂÚ ‚˚‰ÂÊÍ‡ ‚ÂÏÂÌË ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËˇ ÒÚÂÎÍË
                  MarhTracert[Group].GonkaStrel := false;
                end;

              if not ObjZav[k].bParam[1] then
              begin
                if not MarhTracert[Group].Povtor and not MarhTracert[Group].Dobor then
                inc(MarhTracert[Group].GonkaList); // Û‚ÂÎË˜ËÚ¸ ˜ËÒÎÓ ÔÂÂ‚ÓÓ‰ËÏ˚ı ÒÚÂÎÓÍ

                if not ObjZav[k].bParam[2] then
                begin //------------------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                  if not ObjZav[k].bParam[6] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,81, ObjZav[ObjZav[k].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[k].BaseObject,81);
                    result := trBreak;
                    MarhTracert[Group].GonkaStrel := false;
                  end;
                end else
                if not ObjZav[ObjZav[k].BaseObject].bParam[21] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,117, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,117);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].ObjConstB[3] and//--- Ì‡‰Ó ÔÓ‚ÂˇÚ¸ Ã—œ Ë
                not ObjZav[ObjZav[k].BaseObject].bParam[20] then //..... Ë‰ÂÚ ‚˚‰ÂÊÍ‡ Ã—œ
                begin
                  InsArcNewMsg(ObjZav[k].BaseObject,392+$4000,1);
                  ShowShortMsg(392,LastX,LastY,ObjZav[ObjZav[k].BaseObject].Liter);
                  result := trBreak;
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,392, ObjZav[k].Liter,1);
                  InsMsg(Group,k,392); //- »‰ÂÚ ‚˚‰ÂÊÍ‡ ‚ÂÏÂÌË ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËˇ ÒÚÂÎÍË
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].bParam[4] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,80, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,80);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if not ObjZav[ObjZav[k].BaseObject].bParam[22] then
                begin //------------------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÌˇÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,118, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,118);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].bParam[19] then
                begin //--------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,136, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,136);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[k].bParam[18] then
                begin //--------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,121, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,121);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;
            end else
            if ObjZav[jmp.Obj].ObjConstB[4] then //- Œı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÏËÌÛÒÂ
            begin
              if ObjZav[o].ObjConstI[20] = k then
              begin //--------- Ò‰ÂÎ‡Ú¸ ÔÓ‚ÂÍË Ú‡ÒÒËÓ‚ÍË ÒÂÍÛ˘Â„Ó Ï‡¯ÛÚ‡ ˜ÂÂÁ ÍÂÒÚ
                if ObjZav[ObjZav[k].BaseObject].bParam[6] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,117, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,117);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;

              if ObjZav[ObjZav[k].BaseObject].ObjConstB[3] and//--- Ì‡‰Ó ÔÓ‚ÂˇÚ¸ Ã—œ Ë
                not ObjZav[ObjZav[k].BaseObject].bParam[20] then //..... Ë‰ÂÚ ‚˚‰ÂÊÍ‡ Ã—œ
                begin
                  InsArcNewMsg(ObjZav[k].BaseObject,392+$4000,1);
                  ShowShortMsg(392,LastX,LastY,ObjZav[ObjZav[k].BaseObject].Liter);
                  result := trBreak;
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,392, ObjZav[k].Liter,1);
                  InsMsg(Group,k,392); //- »‰ÂÚ ‚˚‰ÂÊÍ‡ ‚ÂÏÂÌË ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËˇ ÒÚÂÎÍË
                  MarhTracert[Group].GonkaStrel := false;
                end;
                
              if not ObjZav[k].bParam[2] then
              begin
                if not MarhTracert[Group].Povtor and not MarhTracert[Group].Dobor then
                inc(MarhTracert[Group].GonkaList); //- Û‚ÂÎË˜ËÚ¸ ˜ËÒÎÓ ÔÂÂ‚Ó‰ËÏ˚ı ÒÚÂÎÓÍ

                if not ObjZav[k].bParam[1] then
                begin //------------------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                  if not ObjZav[k].bParam[7] then
                  begin
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,81, ObjZav[ObjZav[k].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[k].BaseObject,81);
                    result := trBreak;
                    MarhTracert[Group].GonkaStrel := false;
                  end;
                end else
                if not ObjZav[ObjZav[k].BaseObject].bParam[21] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,157, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,157);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].bParam[4] then
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,80, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,80);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if not ObjZav[ObjZav[k].BaseObject].bParam[22] then
                begin //------------------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÌˇÚ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,158, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,158);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[ObjZav[k].BaseObject].bParam[19] then
                begin //--------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,137, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,137);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;

                if ObjZav[k].bParam[18] then
                begin //--------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,159, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,159);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;
            end;
          end;
        end;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign,
    tlSignalCirc :
    begin
      result := trNextStep;
      //------------ ÔÓ‚ÂÍ‡ ‚ÓÁÏÓÊÌÓÒÚË ÛÒÚ‡ÌÓ‚ÍË Óı‡ÌÌÓÈ ÒÚÂÎÍË ‚ ÚÂ·ÛÂÏÓÂ ÔÓÎÓÊÂÌËÂ
      o := ObjZav[jmp.Obj].ObjConstI[1]; //------------------------ ÍÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡
      k := ObjZav[jmp.Obj].ObjConstI[3]; //------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡

      if (o > 0) and (k > 0) then
      begin
        if ObjZav[jmp.Obj].ObjConstB[1] then
        begin
          if ObjZav[o].bParam[1] then //--------  ÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡ Óı‡ÌˇÂÚÒˇ ‚ ÔÎ˛ÒÂ
          begin
            if ObjZav[jmp.Obj].ObjConstB[3] then //-- Œı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÔÎ˛ÒÂ
            begin
              if ObjZav[k].bParam[1] then
              begin //------------------------------------ ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‚ ÏËÌÛÒ
                if ObjZav[k].bParam[7] then
                begin //----------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ „ÓÌËÚÒˇ ‚ ÏËÌÛÒ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,236, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,236);
                end;
              end else
              begin
                if not ObjZav[k].bParam[2] then
                begin //------------------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,81, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,81);
                end else
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,236, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,236);
                end;
              end;
            end else
            if ObjZav[jmp.Obj].ObjConstB[4] then //- Œı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÏËÌÛÒÂ
            begin
              if ObjZav[k].bParam[2] then
              begin //------------------------------------- ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‚ ÔÎ˛Ò
                if ObjZav[k].bParam[6] then
                begin //---------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ „ÓÌËÚÒˇ ‚ ÔÎ˛Ò
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,235, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,235);
                end;
              end else
              begin
                if not ObjZav[k].bParam[1] then
                begin //------------------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,81, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,81); //--- —ÚÂÎÍ‡ $ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
                end else
                begin //----------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,235, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,235); //-- Œı‡ÌÌ‡ˇ ÒÚ. ‚ + (ÌÛÊÂÌ -)
                end;
              end;
            end;
          end;
        end else
        if ObjZav[jmp.Obj].ObjConstB[2] then
        begin
          if ObjZav[o].bParam[2] then //-------  ÓÌÚÓÎËÛÂÏ‡ˇ ÒÚÂÎÍ‡ Óı‡ÌˇÂÚÒˇ ‚ ÏËÌÛÒÂ
          begin
            if ObjZav[jmp.Obj].ObjConstB[3] then //-- Œı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÔÎ˛ÒÂ
            begin
              if ObjZav[k].bParam[1] then
              begin //------------------------------------ ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‚ ÏËÌÛÒ
                if ObjZav[k].bParam[7] then
                begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ „ÓÌËÚÒˇ ‚ ÏËÌÛÒ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,236, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,236);//--- Œı‡ÌÌ‡ˇ ÒÚ. ‚ - (ÌÛÊÂÌ +)
                end;
              end else
              begin
                if not ObjZav[k].bParam[2] then
                begin //------------------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,81, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,81); //--- —ÚÂÎÍ‡ $ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
                end else
                begin //---------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,236, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,236);//--- Œı‡ÌÌ‡ˇ ÒÚ. ‚ - (ÌÛÊÂÌ +)
                end;
              end;
            end else
            if ObjZav[jmp.Obj].ObjConstB[4] then //- Œı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ‚ ÏËÌÛÒÂ
            begin
              if ObjZav[k].bParam[2] then
              begin //----------------------------00------- ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‚ ÔÎ˛Ò
                if ObjZav[k].bParam[6] then
                begin //-------------------------00------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ „ÓÌËÚÒˇ ‚ ÔÎ˛Ò
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,235, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,235); //00 Œı‡ÌÌ‡ˇ ÒÚ. ‚ + (ÌÛÊÂÌ -)
                end;
              end else
              begin
                if not ObjZav[k].bParam[1] then
                begin //-----------------------00------------------ ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,81, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,81); //--- —ÚÂÎÍ‡ $ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ
                end else
                begin //----------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,235, ObjZav[ObjZav[k].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[k].BaseObject,235); //-- Œı‡ÌÌ‡ˇ ÒÚ. ‚ + (ÌÛÊÂÌ -)
                end;
              end;
            end;
          end;
        end;
      end;
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;
    else
    if Con.Pin = 1 then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else result := trNextStep;
      end;
    end else
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else  result := trNextStep;
      end;
    end;
  end;
end;
//========================================================================================
function StepTraceIzvPer(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp:TOZNeighbour) : TTracertResult;
//-------------------------------------------------------------- »Á‚Â˘ÂÌËÂ Ì‡ ÔÂÂÂÁ‰ (28)
var
  o : integer;
begin
  case Lvl of
    tlFindTrace :  //-------------------------------------------------------- ÔÓËÒÍ Ú‡ÒÒ˚
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end;
    end;

    tlVZavTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end;
    end;

    tlCheckTrace :
    begin
      result := trNextStep;
      o := ObjZav[jmp.Obj].BaseObject; //--------------------------------- Ó·˙ÂÍÚ ÔÂÂÂÁ‰‡
      if ObjZav[o].bParam[4] then //--------------------------------------- Á√ Ì‡ ÔÂÂÂÁ‰Â
      begin
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,107, ObjZav[o].Liter,1);
        result := trBreak;
        InsMsg(Group,o,107);
        MarhTracert[Group].GonkaStrel := false;
      end;

      if ObjZav[o].bParam[1] then //----------------------------------- ‡‚‡Ëˇ Ì‡ ÔÂÂÂÁ‰Â
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,143, ObjZav[o].Liter,1);
        result := trBreak;
        InsWar(Group,o,143);
        MarhTracert[Group].GonkaStrel := false;
      end;

      if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then // ÌÂËÒÔ‡‚ÌÓÒÚ¸ Ì‡ ÔÂÂÂÁ‰Â
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,144, ObjZav[o].Liter,1);
        result := trBreak;
        InsWar(Group,o,144);
        MarhTracert[Group].GonkaStrel := false;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign,
    tlSignalCirc :
    begin
      result := trNextStep;
      o := ObjZav[jmp.Obj].BaseObject;
      if ObjZav[o].bParam[4] then //--------------------------------------- Á√ Ì‡ ÔÂÂÂÁ‰Â
      begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,107, ObjZav[o].Liter,1);
            InsMsg(Group,o,107);
          end;
          if ObjZav[o].bParam[1] then
          begin // ‡‚‡Ëˇ Ì‡ ÔÂÂÂÁ‰Â
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,143, ObjZav[o].Liter,1);
            InsWar(Group,o,143);
          end;
          if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then
          begin // ÌÂËÒÔ‡‚ÌÓÒÚ¸ Ì‡ ÔÂÂÂÁ‰Â
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,144, ObjZav[o].Liter,1); InsWar(Group,o,144);
          end;
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end;
        end;

      else
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end;
      end;
    end;
//========================================================================================
function StepTraceDZSP(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------------------------------------------------- ƒ« ÒÂÍˆËË (29)
var
  o,k : integer;
  p : boolean;
begin
      case Lvl of
        tlFindTrace :
        begin
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trRepeat;
              LnkEnd : result := trRepeat;
              else     result := trNextStep;
            end;
          end
          else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trRepeat;
              LnkEnd : result := trRepeat;
              else     result := trNextStep;
            end;
          end;
        end;

        tlVZavTrace :
        begin
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
              else     result := trNextStep;
            end;
          end
          else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
              else     result := trNextStep;
            end;
          end;
        end;

        tlCheckTrace :
        begin
          result := trNextStep;
          if ((Con.Pin = 1) and (Rod = MarshM) and ObjZav[jmp.Obj].ObjConstB[1]) or
          ((Con.Pin = 1) and (Rod = MarshP) and ObjZav[jmp.Obj].ObjConstB[2]) or
          ((Con.Pin = 2) and (Rod = MarshM) and ObjZav[jmp.Obj].ObjConstB[3]) or
          ((Con.Pin = 2) and (Rod = MarshP) and ObjZav[jmp.Obj].ObjConstB[4]) then
          begin
            for k := 1 to 10 do
            begin
              o := ObjZav[jmp.Obj].ObjConstI[k];
              if o > 0 then
              begin
                case ObjZav[o].TypeObj of
                  8 :
                  begin // ”“—
                    if ((not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2]) or
                    (ObjZav[o].bParam[1] and ObjZav[o].bParam[2])) and not ObjZav[o].bParam[3] then
                    begin // ”ÔÓ ‚ÍÎ˛˜ÂÌ ‚ Á‡‚ËÒËÏÓÒÚË Ë ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,109, ObjZav[o].Liter,1);
                      InsMsg(Group,o,109); result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end
                    else
                    if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] and
                    not ObjZav[o].bParam[3] and (Rod = MarshP) then
                    begin //--- ”ÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ Ë ‚ÍÎ˛˜ÂÌ ‚ Á‡‚ËÒËÏÓÒÚË Ë ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,108, ObjZav[o].Liter,1);
                      InsMsg(Group,o,108); result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end else
                    if not ObjZav[o].bParam[27] then
                    begin //------------------------- ÌÂ Á‡Â„ËÒÚËÓ‚‡ÌÓ ÒÓÓ·˘ÂÌËÂ ÔÓ ”“—
                      if ObjZav[o].bParam[3] then
                      begin //------------------------------ ”ÔÓ ‚˚ÍÎ˛˜ÂÌ ËÁ Á‡‚ËÒËÏÓÒÚÂÈ
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,253, ObjZav[o].Liter,1);
                        InsWar(Group,o,253); result := trBreak;
                      end;
                      if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then
                      begin // ”ÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,108, ObjZav[o].Liter,1);
                        InsWar(Group,o,108); result := trBreak;
                      end else
                      if (not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2]) or
                      (ObjZav[o].bParam[1] and ObjZav[o].bParam[2]) then
                      begin //--------------------------- ”ÔÓ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,109, ObjZav[o].Liter,1);
                        InsWar(Group,o,109);
                        result := trBreak;
                      end;
                    end;
                    if result = trBreak then ObjZav[o].bParam[27] := true;
                  end;

                  33 : begin // Ó‰ËÌÓ˜Ì˚È ‰‡Ú˜ËÍ
                    if ObjZav[o].bParam[1] then
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      if ObjZav[o].ObjConstB[1] then
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := MsgList[ObjZav[o].ObjConstI[3]];
                        InsMsg(Group,o,3);
                      end else
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := MsgList[ObjZav[o].ObjConstI[2]];
                        InsMsg(Group,o,2);
                      end;
                      MarhTracert[Group].GonkaStrel := false;
                      result := trBreak;
                    end;
                  end;
                  // ‰Û„ËÂ Ó·˙ÂÍÚ˚ Á‡‚ËÒËÏÓÒÚÂÈ
                  else
                end;
              end;
            end;
          end;
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end;
        end;

        tlAutoTrace,
        tlPovtorRazdel,
        tlRazdelSign,
        tlSignalCirc :
        begin
          result := trNextStep;
          if ((Con.Pin = 1) and (Rod = MarshM) and ObjZav[jmp.Obj].ObjConstB[1]) or
          ((Con.Pin = 1) and (Rod = MarshP) and ObjZav[jmp.Obj].ObjConstB[2]) or
          ((Con.Pin = 2) and (Rod = MarshM) and ObjZav[jmp.Obj].ObjConstB[3]) or
          ((Con.Pin = 2) and (Rod = MarshP) and ObjZav[jmp.Obj].ObjConstB[4]) then
          begin
            for k := 1 to 10 do
            begin
              o := ObjZav[jmp.Obj].ObjConstI[k];
              if o > 0 then
              begin
                case ObjZav[o].TypeObj of
                  8 :
                  begin // ”“—
                    if ((not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2]) or
                    (ObjZav[o].bParam[1] and ObjZav[o].bParam[2])) and not ObjZav[o].bParam[3] then
                    begin // ”ÔÓ ‚ÍÎ˛˜ÂÌ ‚ Á‡‚ËÒËÏÓÒÚË Ë ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,109, ObjZav[o].Liter,1);
                      InsMsg(Group,o,109);
                    end else
                    if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] and
                    not ObjZav[o].bParam[3] and (Rod = MarshP) then
                    begin // ”ÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ Ë ‚ÍÎ˛˜ÂÌ ‚ Á‡‚ËÒËÏÓÒÚË Ë ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,108, ObjZav[o].Liter,1);
                      InsMsg(Group,o,108);
                    end else
                    if not ObjZav[o].bParam[27] then
                    begin
                      p := false;
                      if ObjZav[o].bParam[3] then
                      begin // ”ÔÓ ‚˚ÍÎ˛˜ÂÌ ËÁ Á‡‚ËÒËÏÓÒÚÂÈ
                        p := true;
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,253, ObjZav[o].Liter,1);
                        InsWar(Group,o,253);
                      end;
                      if not ObjZav[o].bParam[1] and ObjZav[o].bParam[2] then
                      begin // ”ÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ
                        p := true;
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,108, ObjZav[o].Liter,1);
                        InsWar(Group,o,108);
                      end else
                      if (not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2]) or
                      (ObjZav[o].bParam[1] and ObjZav[o].bParam[2]) then
                      begin // ”ÔÓ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                        p := true;
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,109, ObjZav[o].Liter,1);
                        InsWar(Group,o,109);
                      end;
                      if p then ObjZav[o].bParam[27] := true;
                    end;
                  end;

                  33 : begin // Ó‰ËÌÓ˜Ì˚È ‰‡Ú˜ËÍ
                    if ObjZav[o].bParam[1] then
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      if ObjZav[o].ObjConstB[1] then
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := MsgList[ObjZav[o].ObjConstI[3]];
                        InsMsg(Group,o,3);
                      end
                      else
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := MsgList[ObjZav[o].ObjConstI[2]];
                        InsMsg(Group,o,2);
                      end;
                    end;
                  end;
                  // ‰Û„ËÂ Ó·˙ÂÍÚ˚ Á‡‚ËÒËÏÓÒÚÂÈ
                else

                end;
              end;
            end;
          end;
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end;
        end;

        else
        if Con.Pin = 1 then
        begin
          Con := ObjZav[jmp.Obj].Neighbour[2];
          case Con.TypeJmp of
            LnkRgn : result := trEnd;
            LnkEnd : result := trEnd;
            else     result := trNextStep;
          end;
        end
        else
        begin
          Con := ObjZav[jmp.Obj].Neighbour[1];
          case Con.TypeJmp of
            LnkRgn : result := trEnd;
            LnkEnd : result := trEnd;
            else     result := trNextStep;
          end;
        end;
      end;
    end;
//========================================================================================
function StepTracePoezdSogl(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//--------------------------------------------------------- ¬˚‰‡˜‡ ÔÓÂÁ‰ÌÓ„Ó ÒÓ„Î‡ÒËˇ (30)
var
  sig_uvaz,uch_uvaz,start_tras : integer;
begin
  start_tras := MarhTracert[Group].ObjStart;
  sig_uvaz := ObjZav[jmp.Obj].BaseObject;
  uch_uvaz := ObjZav[jmp.Obj].UpdateObject;
  case Lvl of
    tlFindTrace :
    begin
      if ObjZav[Con.Obj].RU = ObjZav[start_tras].RU then
      begin //-------------------------- œÓ‰ÓÎÊËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË Ò‚ÓÈ ‡ÈÓÌ ÛÔ‡‚ÎÂÌËˇ
        if Con.Pin = 1 then
        begin
          Con := ObjZav[jmp.Obj].Neighbour[2];
          case Con.TypeJmp of
            LnkRgn : result := trRepeat;
            LnkEnd : result := trRepeat;
            else result := trNextStep;
          end;
        end else
        begin
          Con := ObjZav[jmp.Obj].Neighbour[1];
          case Con.TypeJmp of
            LnkRgn : result := trRepeat;
            LnkEnd : result := trRepeat;
            else result := trNextStep;
          end;
        end;
      end
      else result := trRepeat;
    end;

    tlContTrace :
    begin
      if ObjZav[Con.Obj].RU = ObjZav[start_tras].RU then
      begin //-------------------------- œÓ‰ÓÎÊËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË Ò‚ÓÈ ‡ÈÓÌ ÛÔ‡‚ÎÂÌËˇ
        result := trNextStep;
        if Con.Pin = 1 then
        begin
          Con := ObjZav[jmp.Obj].Neighbour[2];
          case Con.TypeJmp of
            LnkRgn : result := trEnd;
            LnkEnd : result := trEnd;
          end;
        end else
        begin
          Con := ObjZav[jmp.Obj].Neighbour[1];
          case Con.TypeJmp of
            LnkRgn : result := trEnd;
            LnkEnd : result := trEnd;
          end;
        end;
      end
      else result := trEndTrace; //«‡‚Â¯ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ Ï‡¯ÛÚ‡, ‰Û„ÓÈ ‡ÈÓÌ ÛÔ‡‚ÎÂÌËˇ
    end;

    tlVZavTrace :
    begin
      result := trNextStep;
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlCheckTrace :
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          if jmp.Obj = MarhTracert[Group].ObjLast then
          begin
            if sig_uvaz > 0 then
            begin
              if ObjZav[jmp.Obj].bParam[1] then
              begin //-------------------------------------------------- Ì‡Ê‡Ú‡ ÍÌÓÔÍ‡ ›√—
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,105, ObjZav[sig_uvaz].Liter,1);
                InsMsg(Group,sig_uvaz,105);//- "Õ‡Ê‡Ú‡ ÍÌÓÔÍ‡ ˝ÍÒÚÂÌÌÓ„Ó „‡¯ÂÌËˇ ÒË„Ì‡Î‡"
                result := trBreak;
              end;

              if not ObjZav[sig_uvaz].bParam[4] then
              begin //--------------------------------------------- ÌÂÚ ÔÓÂÁ‰ÌÓ„Ó ÒÓ„Î‡ÒËˇ
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,246, ObjZav[sig_uvaz].Liter,1);
                InsMsg(Group,sig_uvaz,246);  //----------- "ÕÂÚ ÒÓ„Î‡ÒËˇ ÔÓÂÁ‰ÌÓ„Ó ÔËÂÏ‡"
                result := trBreak;
              end;
            end;
          end;
        end;
      end;

      if jmp.Obj <> MarhTracert[Group].ObjLast then
      begin
        if uch_uvaz > 0 then
        begin //------------------------------------ ÔÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË Û˜‡ÒÚÍ‡ Û‚ˇÁÍË
          if not ObjZav[uch_uvaz].bParam[2] or not ObjZav[uch_uvaz].bParam[3] then
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,113, ObjZav[uch_uvaz].Liter,1);
            InsMsg(Group,uch_uvaz,113); //-------- "Õ‡ ÔÛÚ¸ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ"
            result := trBreak;
            MarhTracert[Group].GonkaStrel := false;
          end;
        end;
      end;

      MarhTracert[Group].TailMsg := ' ‰Ó '+ ObjZav[ObjZav[jmp.Obj].BaseObject].Liter;
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlSignalCirc :
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          if MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter] <>
          ObjZav[jmp.Obj].BaseObject then
          begin
            if sig_uvaz > 0 then
            begin
              if ObjZav[jmp.Obj].bParam[1] then
              begin //-------------------------------------------------- Ì‡Ê‡Ú‡ ÍÌÓÔÍ‡ ›√—
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,105, ObjZav[sig_uvaz].Liter,1);
                InsMsg(Group,sig_uvaz,105);
              end;

              if not ObjZav[sig_uvaz].bParam[4] then
              begin //--------------------------------------------- ÌÂÚ ÔÓÂÁ‰ÌÓ„Ó ÒÓ„Î‡ÒËˇ
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,246, ObjZav[sig_uvaz].Liter,1);
                InsMsg(Group,sig_uvaz,246);
              end;
            end;
          end;
        end;
      end;

      if MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter] = sig_uvaz  then
      begin
        if uch_uvaz > 0 then
        begin //------------------------------------ ÔÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË Û˜‡ÒÚÍ‡ Û‚ˇÁÍË
          if ObjZav[uch_uvaz].bParam[2] and ObjZav[uch_uvaz].bParam[3] then
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,163, ObjZav[uch_uvaz].Liter,1);
            InsMsg(Group,uch_uvaz,163);
          end;
        end;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlAutoTrace,
    tlPovtorRazdel,
    tlRazdelSign :
    begin
      result := trNextStep;
      case Rod of
        MarshP :
        begin
          if MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter] <>  sig_uvaz then
          begin
            if sig_uvaz > 0 then
            begin
              if ObjZav[jmp.Obj].bParam[1] then
              begin //-------------------------------------------------- Ì‡Ê‡Ú‡ ÍÌÓÔÍ‡ ›√—
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,105, ObjZav[sig_uvaz].Liter,1);
                InsMsg(Group,sig_uvaz,105);
              end;

              if not ObjZav[sig_uvaz].bParam[4] then
              begin //--------------------------------------------- ÌÂÚ ÔÓÂÁ‰ÌÓ„Ó ÒÓ„Î‡ÒËˇ
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,246, ObjZav[sig_uvaz].Liter,1);
                InsMsg(Group,sig_uvaz,246);
              end;
            end;
          end;
        end;
      end;

      if MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter] = sig_uvaz then
      begin
        if uch_uvaz  > 0 then
        begin //------------------------------------ ÔÓ‚ÂËÚ¸ ‚‡Ê‰Â·ÌÓÒÚË Û˜‡ÒÚÍ‡ Û‚ˇÁÍË
          if not ObjZav[uch_uvaz].bParam[2] or not ObjZav[uch_uvaz].bParam[3] then
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,113, ObjZav[uch_uvaz].Liter,1);
            InsMsg(Group,uch_uvaz,113);
          end;
        end;
      end;

      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
        end;
      end;
    end;

    tlZamykTrace :
    begin
      MarhTracert[Group].TailMsg := ' ‰Ó '+ ObjZav[sig_uvaz].Liter;
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trEnd;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trEnd;
          else result := trNextStep;
        end;
      end;
    end;

    else
    if Con.Pin = 1 then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else result := trNextStep;
      end;
    end else
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else result := trNextStep;
      end;
    end;
  end;
end;
//========================================================================================
function StepTraceUvazGor(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//---------------------------------------------------------- ”‚ˇÁÍ‡ Ò „ÓÍÓÈ (Ì‡‰‚Ë„) (32)
var
  o : integer;
begin
      case Lvl of
        tlFindTrace : begin
          result := trRepeat;
        end;

        tlPovtorMarh,
        tlContTrace :
        begin
          MarhTracert[Group].FullTail := true; result := trEndTrace;
        end;

        tlVZavTrace : begin
          result := trStop;
        end;

        tlCheckTrace : begin
          result := trBreak;
          MarhTracert[Group].TailMsg := ' ‰Ó '+ ObjZav[jmp.Obj].Liter;
          if ObjZav[jmp.Obj].bParam[10] then
          begin // ÛÊÂ ÂÒÚ¸ Ï‡¯ÛÚ Ì‡‰‚Ë„‡ Ì‡ „ÓÍÛ
            inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,355, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,355); MarhTracert[Group].GonkaStrel := false; exit;
          end;
          case Rod of
            MarshP : begin
              o := 1;
              while o < 13 do
              begin
                if MarhTracert[Group].ObjStart = ObjZav[ObjZav[jmp.Obj].UpdateObject].ObjConstI[o] then break;
                inc(o);
              end;
              if o > 12 then
              begin
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,106, ObjZav[MarhTracert[Group].ObjStart].Liter,1); InsMsg(Group,MarhTracert[Group].ObjStart,106); MarhTracert[Group].GonkaStrel := false; exit;
              end else
              if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then
              begin // ·ÎÓÍËÓ‚Í‡ ÍÌÓÔÍË „ÓÓ˜ÌÓ„Ó Ò‚ÂÚÓÙÓ‡
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,123, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,123); MarhTracert[Group].GonkaStrel := false; exit;
              end;
              if ObjZav[jmp.Obj].bParam[11] then
              begin // √œ
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,83); MarhTracert[Group].GonkaStrel := false; exit;
              end;
              if ObjZav[jmp.Obj].bParam[7] then
              begin // ›√—
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,105, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,105); MarhTracert[Group].GonkaStrel := false; exit;
              end;
              if not ObjZav[jmp.Obj].bParam[8] then
              begin // ÌÂÚ ÒÓ„Î‡ÒËˇ Ì‡‰‚Ë„‡
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,103, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,103); MarhTracert[Group].GonkaStrel := false; exit;
              end;
              o := MarhTracert[Group].PutNadviga;
              if not ObjZav[ObjZav[o].BaseObject].bParam[4] and
                 not (ObjZav[ObjZav[o].BaseObject].bParam[2] and ObjZav[ObjZav[o].BaseObject].bParam[3]) then
              begin // ÛÒÚ‡ÌÓ‚ÎÂÌ ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ Ì‡ ÔÛÚ¸ Ì‡‰‚Ë„‡
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,356, ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(Group,ObjZav[o].BaseObject,356); MarhTracert[Group].GonkaStrel := false; exit;
              end;
            end;
            MarshM : begin
              if not ObjZav[jmp.Obj].bParam[9] then
              begin // ÌÂÚ ÒÓ„Î‡ÒËˇ Ï‡ÌÂ‚Ó‚
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,104, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,104); MarhTracert[Group].GonkaStrel := false; exit;
              end;
            end;
          else
            result := trStop; exit;
          end;
          MarhTracert[Group].FullTail := true; result := trEndTrace;
        end;

        tlAutoTrace,
        tlPovtorRazdel,
        tlRazdelSign :
        begin
          result := trStop;
          if ObjZav[jmp.Obj].bParam[10] then
          begin // ÛÊÂ ÂÒÚ¸ Ï‡¯ÛÚ Ì‡‰‚Ë„‡ Ì‡ „ÓÍÛ
            inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,355, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,355); exit;
          end;
          case Rod of
            MarshP : begin
              o := 1;
              while o < 13 do
              begin
                if MarhTracert[Group].ObjStart = ObjZav[ObjZav[jmp.Obj].UpdateObject].ObjConstI[o] then break;
                inc(o);
              end;
              if o > 12 then
              begin
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,106, ObjZav[MarhTracert[Group].ObjStart].Liter,1); InsMsg(Group,MarhTracert[Group].ObjStart,106); exit;
              end else
              if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then
              begin // ·ÎÓÍËÓ‚Í‡ ÍÌÓÔÍË „ÓÓ˜ÌÓ„Ó Ò‚ÂÚÓÙÓ‡
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,123, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,123); exit;
              end;
              if ObjZav[jmp.Obj].bParam[11] then
              begin // √œ
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,83); exit;
              end;
              if ObjZav[jmp.Obj].bParam[7] then
              begin // ›√—
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,105, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,105); exit;
              end;
              if not ObjZav[jmp.Obj].bParam[8] then
              begin // ÌÂÚ ÒÓ„Î‡ÒËˇ Ì‡‰‚Ë„‡
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,103, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,103); exit;
              end;
              o := MarhTracert[Group].PutNadviga;
              if Con.Pin = 1 then
              begin
                if not ObjZav[ObjZav[o].BaseObject].bParam[4] and
                   not ObjZav[ObjZav[o].BaseObject].bParam[2] then
                begin // ÛÒÚ‡ÌÓ‚ÎÂÌ ˜ÂÚÌ˚È ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ Ì‡ ÔÛÚ¸ Ì‡‰‚Ë„‡
                  inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,356, ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(Group,ObjZav[o].BaseObject,356); exit;
                end;
              end else
              begin
                if not ObjZav[ObjZav[o].BaseObject].bParam[4] and
                   not ObjZav[ObjZav[o].BaseObject].bParam[3] then
                begin // ÛÒÚ‡ÌÓ‚ÎÂÌ ÌÂ˜ÂÚÌ˚È ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ Ì‡ ÔÛÚ¸ Ì‡‰‚Ë„‡
                  inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,356, ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(Group,ObjZav[o].BaseObject,356); exit;
                end;
              end;
            end;
            MarshM : begin
              if not ObjZav[jmp.Obj].bParam[9] then
              begin // ÌÂÚ ÒÓ„Î‡ÒËˇ Ï‡ÌÂ‚Ó‚
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,104, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,104); exit;
              end;
            end;
          else
            result := trStop; exit;
          end;
          MarhTracert[Group].FullTail := true; result := trEndTrace;
        end;

        tlSignalCirc :
        begin
          result := trStop;
          case Rod of
            MarshP : begin
              o := 1;
              while o < 13 do
              begin
                if MarhTracert[Group].ObjStart = ObjZav[ObjZav[jmp.Obj].UpdateObject].ObjConstI[o] then break;
                inc(o);
              end;
              if o > 12 then
              begin
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,106, ObjZav[MarhTracert[Group].ObjStart].Liter,1); InsMsg(Group,MarhTracert[Group].ObjStart,106); exit;
              end else
              if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then
              begin // ·ÎÓÍËÓ‚Í‡ ÍÌÓÔÍË „ÓÓ˜ÌÓ„Ó Ò‚ÂÚÓÙÓ‡
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,123, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,123); exit;
              end;
              if ObjZav[jmp.Obj].bParam[11] then
              begin // √œ
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,83); exit;
              end;
              if ObjZav[jmp.Obj].bParam[7] then
              begin // ›√—
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,105, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,105); exit;
              end;
              if not ObjZav[jmp.Obj].bParam[8] then
              begin // ÌÂÚ ÒÓ„Î‡ÒËˇ Ì‡‰‚Ë„‡
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,103, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,103); exit;
              end;
              o := MarhTracert[Group].PutNadviga;
              if Con.Pin = 1 then
              begin
                if not ObjZav[ObjZav[o].BaseObject].bParam[4] and
                   not ObjZav[ObjZav[o].BaseObject].bParam[2] then
                begin // ÛÒÚ‡ÌÓ‚ÎÂÌ ˜ÂÚÌ˚È ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ Ì‡ ÔÛÚ¸ Ì‡‰‚Ë„‡
                  inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,356, ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(Group,ObjZav[o].BaseObject,356); exit;
                end;
              end else
              begin
                if not ObjZav[ObjZav[o].BaseObject].bParam[4] and
                   not ObjZav[ObjZav[o].BaseObject].bParam[3] then
                begin // ÛÒÚ‡ÌÓ‚ÎÂÌ ÌÂ˜ÂÚÌ˚È ÔÓÂÁ‰ÌÓÈ Ï‡¯ÛÚ Ì‡ ÔÛÚ¸ Ì‡‰‚Ë„‡
                  inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,356, ObjZav[ObjZav[o].BaseObject].Liter,1); InsMsg(Group,ObjZav[o].BaseObject,356); exit;
                end;
              end;
            end;
            MarshM : begin
              if not ObjZav[jmp.Obj].bParam[9] then
              begin // ÌÂÚ ÒÓ„Î‡ÒËˇ Ï‡ÌÂ‚Ó‚
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,104, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,104); exit;
              end;
            end;
          else
            result := trStop; exit;
          end;
          MarhTracert[Group].FullTail := true; result := trEndTrace;
        end;

        tlFindIzvest : begin
          if ObjZav[jmp.Obj].bParam[11] then
          begin // «‡ÌˇÚÓ ÔË·ÎËÊÂÌËÂ
            result := trBreak;
          end else
            result := trStop;
        end;

        tlFindIzvStrel : result := trStop;

        else
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end;
      end;
    end;
//========================================================================================
function StepTraceMarNadvig(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//--------------------------------------------------------  ÓÌÚÓÎ¸ Ï‡¯ÛÚ‡ Ì‡‰‚Ë„‡  (38)
begin
      case Lvl of
        tlFindTrace : begin
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trRepeat;
              LnkEnd : result := trRepeat;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trRepeat;
              LnkEnd : result := trRepeat;
            else
              result := trNextStep;
            end;
          end;
        end;

        tlCheckTrace : begin
          MarhTracert[Group].PutNadviga := jmp.Obj; // ÒÓı‡ÌËÚ¸ ËÌ‰ÂÍÒ Ó·˙ÂÍÚ‡ ÒÓ„Î‡ÒËˇ Ì‡‰‚Ë„‡ Ò ÔÛÚË
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end;
        end;

        tlAutoTrace,
        tlPovtorRazdel,
        tlRazdelSign,
        tlSignalCirc : begin
          MarhTracert[Group].PutNadviga := jmp.Obj; // ÒÓı‡ÌËÚ¸ ËÌ‰ÂÍÒ Ó·˙ÂÍÚ‡ ÒÓ„Î‡ÒËˇ Ì‡‰‚Ë„‡ Ò ÔÛÚË
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end;
        end;

      else
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end;
      end;
    end;
//========================================================================================
function StepTraceMarshOtpr(var Con : TOZNeighbour;
const Lvl : TTracertLevel; Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//-----------------------------------------------------  ÓÌÚÓÎ¸ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ (41)
var
  k,o,hvost,s_v_put : integer;
begin
  result := trNextStep;
  s_v_put := jmp.Obj;
  case Lvl of
    tlFindTrace : //--------------------------------------------------------- ÔÓËÒÍ Ú‡ÒÒ˚
    begin
      result := trNextStep;
      if Con.Pin = 1 then Con := ObjZav[s_v_put].Neighbour[2]
      else Con := ObjZav[s_v_put].Neighbour[1];

      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;

    tlPovtorMarh,
    tlContTrace,
    tlVZavTrace,
    tlFindIzvest,
    tlFindIzvStrel :
    begin
      result := trNextStep;
      if Con.Pin = 1 then  Con := ObjZav[s_v_put].Neighbour[2]
      else  Con := ObjZav[s_v_put].Neighbour[1];

      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trStop;
      end;
    end;

    tlCheckTrace :
    begin
      result := trNextStep;

      if Con.Pin = 1 then //--------------------- ‚ıÓ‰ ‚ Ó·˙ÂÍÚ ÒÓ  ÒÚÓÓÌ˚ Ú˜Í 1 (ÌÂ˜ÂÚÌ)
      begin
        Con := ObjZav[s_v_put].Neighbour[2];
        if (Rod = MarshP) and ObjZav[s_v_put].ObjConstB[1] then //ÔÓÂÁ‰ÌÓÈ Ë ÔÓ‚ÂˇÚ¸ ÌÂ˜
        begin
          ObjZav[s_v_put].bParam[21] := true; //-------- Ú‡ÒÒËÓ‚Í‡ ÔÓÂÁ‰ÌÓ„Ó ÓÚÔ‡‚ÎÂÌËˇ
          for k := 1 to 4 do //----------------------- ÔÓÈÚË ÔÓ ‚ÓÁÏÓÊÌ˚Ï ÒÚÂÎÍ‡Ï ‚ ÔÛÚË
          begin
            o := ObjZav[s_v_put].ObjConstI[k]; //------------- ‚ÁˇÚ¸ ËÌ‰ÂÍÒ ÒÚÂÎÍË ‚ ÔÛÚË
            if o > 0 then
            begin
              hvost := ObjZav[o].BaseObject;

              if not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
              begin //------------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,81, ObjZav[hvost].Liter,1);
                InsMsg(Group,hvost,81);//----------- —ÚÂÎÍ‡ $ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                MarhTracert[Group].GonkaStrel := false;
                exit;
              end else
              if (ObjZav[hvost].bParam[4] or //------ ÂÒÎË Û ÒÚÂÎÍË ‰ÓÔ.Á‡Ï˚Í‡ÌËÂ ËÎË ...
              ObjZav[hvost].bParam[14]) and //----------------- ÔÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ Ë...
              ObjZav[hvost].bParam[21] then //------------------------ ÌÂÚ Á‡Ï˚Í‡ÌËˇ ËÁ —œ
              begin //--------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ú‡ÒÒËÛÂÚÒˇ ‚ Ï‡¯ÛÚÂ
                if (ObjZav[s_v_put].ObjConstB[k*3+1] and //Óı‡ÌÌÓÒÚ¸ ÔÓ "-" ÒÚÂÎÍË Ë ...
                ObjZav[hvost].bParam[6]) or //-------------------- ÂÒÚ¸ ÔËÁÌ‡Í œ” ËÎË ...
                (ObjZav[s_v_put].ObjConstB[k*3] and //---- Óı‡ÌÌÓÒÚ¸ ÔÓ "+" ÒÚÂÎÍË Ë ...
                ObjZav[hvost].bParam[7]) then //-------------------------- ÂÒÚ¸ ÔËÁÌ‡Í Ã”
                begin //------------------------ Ú‡ÒÒËÓ‚Í‡ ‚ ‡ÁÂÁ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,80, ObjZav[hvost].Liter,1); //----------- —ÚÂÎÍ‡ $ Á‡ÏÍÌÛÚ‡
                  InsMsg(Group,hvost,80);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;

              if (not ObjZav[o].bParam[1] or ObjZav[o].bParam[2]) and //- ÌÂ ‚ ÔÎ˛ÒÂ Ë ...
              (not ObjZav[hvost].bParam[21]) and (Rod = MarshP) then //-- ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,80, ObjZav[hvost].Liter,1);
                InsMsg(Group,hvost,80);//----------- —ÚÂÎÍ‡ $ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                MarhTracert[Group].GonkaStrel := false;
                exit;
              end;

              if ObjZav[s_v_put].ObjConstB[k*3+2] then // ÂÒÎË ÔÂ‰ÛÒÏÓÚÂÌ‡ „ÓÌÍ‡ ÒÚÂÎÍË
              begin
                if ObjZav[s_v_put].ObjConstB[k*3] and //---------- Óı‡ÌÌÓÒÚ¸ ÔÓ "+" Ë ...
                not ObjZav[o].bParam[1] then  //----------------------- ÒÚÂÎÍ‡ ÌÂ ‚ ÔÎ˛ÒÂ
                begin //------------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÔÎ˛ÒÂ
                  if ObjZav[s_v_put].ObjConstI[k+4] = 0 then //--- ÌÂÚ ËÌ‰ÂÍÒ‡ ÒË„Ì‡Î‡ ...
                  begin //----------------------- ÌÂÚ ÒË„Ì‡Î‡ ÔËÍ˚ÚËˇ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË
                    if not ObjZav[hvost].bParam[21] then //-ÂÒÎË Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,117, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,117); //-------------- —ÚÂÎÓ˜Ì‡ˇ ÒÂÍˆËˇ Á‡ÏÍÌÛÚ‡
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if not ObjZav[hvost].bParam[22] then //------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÌˇÚ‡
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,118, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,118); //--------------- —ÚÂÎÓ˜Ì‡ˇ ÒÂÍˆËˇ Á‡ÌˇÚ‡
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if ObjZav[hvost].bParam[15] or   //-------- ÂÒÎË ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚË ËÎË
                    ObjZav[hvost].bParam[19] then   //-------------------- Ì‡ Ó·˘ÂÏ Ï‡ÍÂÚÂ
                    begin //----------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,136, ObjZav[hvost].Liter,1);//----- —ÚÂÎÍ‡ $ Ì‡ Ï‡ÍÂÚÂ.
                      InsMsg(Group,hvost,136);//œÂÂ‰ Ï‡¯ÛÚÓÏ ‰ÓÎÊÌ‡ ·˚Ú¸ ÔÂÂ‚Â‰ÂÌ‡ ‚ +
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if ObjZav[o].bParam[18] then //------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,121, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,121);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;
                  end else
                  begin //---------------------------------- ÂÒÚ¸ ÔËÍ˚ÚËÂ ÒÚÂÎÍË ‚ ÔÛÚË
                    if ObjZav[hvost].bParam[21] and //----- ÂÒÎË ÌÂÚ Á‡Ï˚Í‡ÌËˇ ËÁ —œ Ë ...
                    ObjZav[hvost].bParam[22] then  //----------------- ÌÂÚ Á‡ÌˇÚÓÒÚË ËÁ —œ
                    begin //------------------------------- ÒÚÂÎÍ‡ Ò‚Ó·Ó‰Ì‡ Ë ÌÂ Á‡ÏÍÌÛÚ‡
                      if ObjZav[hvost].bParam[15] or //------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ ËÎË
                      ObjZav[hvost].bParam[19] then //-------------------- Ì‡ Ó·˘ÂÏ Ï‡ÍÂÚÂ
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                        inc(MarhTracert[Group].MsgCount);
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,136, ObjZav[hvost].Liter,1);
                        InsMsg(Group,hvost,136); //"ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ, ÒÌ‡˜‡Î‡ ÛÒÚ‡ÌÓ‚Ë +"
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;

                      if ObjZav[o].bParam[18] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                        inc(MarhTracert[Group].MsgCount);
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,121, ObjZav[hvost].Liter,1);
                        InsMsg(Group,hvost,121); //------- ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;
                    end else
                    begin
                      if ObjZav[hvost].bParam[15] or
                      ObjZav[hvost].bParam[19] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                        GetShortMsg(1,136, ObjZav[hvost].Liter,1);
                        InsWar(Group,hvost,136); //----- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ, ÒÌ‡˜‡Î‡ ‚ ÔÎ˛Ò
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;
                    end;
                  end;
                end;

                if ObjZav[s_v_put].ObjConstB[k*3+1] and
                not ObjZav[o].bParam[2] then
                begin //------------------------ ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÏËÌÛÒÂ
                  if ObjZav[s_v_put].ObjConstI[k+4] = 0 then
                  begin //----------------------- ÌÂÚ ÒË„Ì‡Î‡ ÔËÍ˚ÚËˇ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË
                    if not ObjZav[hvost].bParam[21] then
                    begin //------------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,117, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,117); //---------------------- ÒÂÍˆËˇ —œ Á‡ÏÍÌÛÚ‡
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if not ObjZav[hvost].bParam[22] then
                    begin //-------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÌˇÚ‡
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,118, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,118);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if ObjZav[hvost].bParam[15] or
                    ObjZav[hvost].bParam[19] then
                    begin //----------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,137, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,137);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if ObjZav[o].bParam[18] then
                    begin //----------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,159, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,159);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;
                  end else
                  begin //---------------------------------- ÂÒÚ¸ ÔËÍ˚ÚËÂ ÒÚÂÎÍË ‚ ÔÛÚË
                    if ObjZav[hvost].bParam[21] and
                    ObjZav[hvost].bParam[22] then
                    begin //------------------------------- ÒÚÂÎÍ‡ Ò‚Ó·Ó‰Ì‡ Ë ÌÂ Á‡ÏÍÌÛÚ‡
                      if ObjZav[hvost].bParam[15] or
                      ObjZav[hvost].bParam[19] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                        inc(MarhTracert[Group].MsgCount);
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,137, ObjZav[hvost].Liter,1);
                        InsMsg(Group,hvost,137);
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;

                      if ObjZav[o].bParam[18] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                        inc(MarhTracert[Group].MsgCount);
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,159, ObjZav[hvost].Liter,1);
                        InsMsg(Group,hvost,159);
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;
                    end else
                    begin
                      if ObjZav[hvost].bParam[15] or ObjZav[hvost].bParam[19] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                        GetShortMsg(1,137, ObjZav[hvost].Liter,1);
                        InsWar(Group,hvost,137);
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;
                    end;
                  end;
                end;
              end else
              begin //--------------------- Ï‡¯ÛÚÌ‡ˇ „ÓÌÍ‡ ÒÚÂÎÍË ‚ ÔÛÚË ÌÂ ‚˚ÔÓÎÌˇÂÚÒˇ
                if ObjZav[s_v_put].ObjConstB[k*3] and not ObjZav[o].bParam[1] then
                begin //------------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÔÎ˛ÒÂ
                  if (ObjZav[s_v_put].ObjConstI[k+4] = 0) or
                  (ObjZav[hvost].bParam[21] and ObjZav[hvost].bParam[22]) then
                  begin //- ÌÂÚ ÒË„Ì.ÔËÍ. ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË ËÎË ÌÂÚ Á‡ÌˇÚÓÒÚË,Á‡Ï˚Í‡ÌËˇ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[o].Liter,1);
                    InsMsg(Group,hvost,268);
                    MarhTracert[Group].GonkaStrel := false;
                    exit;
                  end;
                end;

                if ObjZav[s_v_put].ObjConstB[k*3+1] and not ObjZav[o].bParam[2] then
                begin //------------------------ ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÏËÌÛÒÂ
                  if (ObjZav[s_v_put].ObjConstI[k+4] = 0) or
                  (ObjZav[hvost].bParam[21] and ObjZav[hvost].bParam[22]) then
                  begin //-- ÌÂÚ ÒË„Ì.ÔËÍ.‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË ËÎË ÌÂÚ Á‡ÌˇÚÓÒÚË,Á‡Ï˚Í‡ÌËˇ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,267, ObjZav[o].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,267);
                    MarhTracert[Group].GonkaStrel := false;
                    exit;
                  end;
                end;
              end;
            end;
          end;
        end
        else ObjZav[s_v_put].bParam[21] := false;
      end else
      begin
        Con := ObjZav[s_v_put].Neighbour[1];

        if (Rod = MarshP) and ObjZav[s_v_put].ObjConstB[2] then
        begin
          ObjZav[s_v_put].bParam[21] := true;
          for k := 1 to 4 do
          begin
            o := ObjZav[s_v_put].ObjConstI[k];
            if o > 0 then
            begin
              hvost := ObjZav[o].BaseObject;
              if not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
              begin //------------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,81, ObjZav[hvost].Liter,1);
                InsMsg(Group,hvost,81);
                MarhTracert[Group].GonkaStrel := false; exit;
              end else

              if (ObjZav[hvost].bParam[4] or ObjZav[hvost].bParam[14]) and
              ObjZav[hvost].bParam[21] then
              begin //--------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ú‡ÒÒËÛÂÚÒˇ ‚ Ï‡¯ÛÚÂ
                if (ObjZav[s_v_put].ObjConstB[k*3+1] and ObjZav[hvost].bParam[6]) or
                (ObjZav[s_v_put].ObjConstB[k*3] and ObjZav[hvost].bParam[7]) then
                begin //------------------------ Ú‡ÒÒËÓ‚Í‡ ‚ ‡ÁÂÁ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,80, ObjZav[hvost].Liter,1);
                  InsMsg(Group,hvost,80);
                  result := trBreak;
                  MarhTracert[Group].GonkaStrel := false;
                end;
              end;

              if (not ObjZav[o].bParam[1] or ObjZav[o].bParam[2]) and //- ÌÂ ‚ ÔÎ˛ÒÂ Ë ...
              (not ObjZav[hvost].bParam[21]) and (Rod = MarshP) then //-- ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
              begin
                inc(MarhTracert[Group].MsgCount);
                MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                GetShortMsg(1,80, ObjZav[hvost].Liter,1);
                InsMsg(Group,hvost,80);//------------------------------ —ÚÂÎÍ‡ $ Á‡ÏÍÌÛÚ‡
                MarhTracert[Group].GonkaStrel := false;
                exit;
              end;

              if ObjZav[s_v_put].ObjConstB[k*3+2] then
              begin //------------------------ Ï‡¯ÛÚÌ‡ˇ „ÓÌÍ‡ ÒÚÂÎÍË ‚ ÔÛÚË ‚˚ÔÓÎÌˇÂÚÒˇ
                if ObjZav[s_v_put].ObjConstB[k*3] and not ObjZav[o].bParam[1] then
                begin //------------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÔÎ˛ÒÂ
                  if ObjZav[s_v_put].ObjConstI[k+4] = 0 then
                  begin //----------------------- ÌÂÚ ÒË„Ì‡Î‡ ÔËÍ˚ÚËˇ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË
                    if not ObjZav[hvost].bParam[21] then
                    begin //------------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,117, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,117);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if not ObjZav[hvost].bParam[22] then
                    begin //-------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÌˇÚ‡
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,118, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,118);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if ObjZav[hvost].bParam[15] or ObjZav[hvost].bParam[19] then
                    begin //----------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,136, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,136);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if ObjZav[o].bParam[18] then
                    begin //----------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,121, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,121);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;
                  end else
                  begin //---------------------------------- ÂÒÚ¸ ÔËÍ˚ÚËÂ ÒÚÂÎÍË ‚ ÔÛÚË
                    if ObjZav[hvost].bParam[21] and ObjZav[hvost].bParam[22] then
                    begin //------------------------------- ÒÚÂÎÍ‡ Ò‚Ó·Ó‰Ì‡ Ë ÌÂ Á‡ÏÍÌÛÚ‡
                      if ObjZav[hvost].bParam[15] or ObjZav[hvost].bParam[19] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                        inc(MarhTracert[Group].MsgCount);
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,136, ObjZav[hvost].Liter,1);
                        InsMsg(Group,hvost,136);
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;

                      if ObjZav[o].bParam[18] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                        inc(MarhTracert[Group].MsgCount);
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,121, ObjZav[hvost].Liter,1);
                        InsMsg(Group,hvost,121);
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;
                    end else
                    begin
                      if ObjZav[hvost].bParam[15] or ObjZav[hvost].bParam[19] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                        GetShortMsg(1,136, ObjZav[hvost].Liter,1);
                        InsWar(Group,hvost,136);
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;
                    end;
                  end;
                end;

                if ObjZav[s_v_put].ObjConstB[k*3+1] and not ObjZav[o].bParam[2] then
                begin //------------------------ ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÏËÌÛÒÂ
                  if ObjZav[s_v_put].ObjConstI[k+4] = 0 then
                  begin //----------------------- ÌÂÚ ÒË„Ì‡Î‡ ÔËÍ˚ÚËˇ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË
                    if not ObjZav[ObjZav[o].BaseObject].bParam[21] then
                    begin //------------------------------------ Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÏÍÌÛÚ‡
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,117, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,117);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if not ObjZav[hvost].bParam[22] then
                    begin //-------------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Á‡ÌˇÚ‡
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,118, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,118);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if ObjZav[hvost].bParam[15] or ObjZav[hvost].bParam[19] then
                    begin //----------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,137, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,137);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;

                    if ObjZav[o].bParam[18] then
                    begin //----------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                      inc(MarhTracert[Group].MsgCount);
                      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                      GetShortMsg(1,159, ObjZav[hvost].Liter,1);
                      InsMsg(Group,hvost,159);
                      result := trBreak;
                      MarhTracert[Group].GonkaStrel := false;
                    end;
                  end else
                  begin //---------------------------------- ÂÒÚ¸ ÔËÍ˚ÚËÂ ÒÚÂÎÍË ‚ ÔÛÚË
                    if ObjZav[hvost].bParam[21] and ObjZav[hvost].bParam[22] then
                    begin //------------------------------- ÒÚÂÎÍ‡ Ò‚Ó·Ó‰Ì‡ Ë ÌÂ Á‡ÏÍÌÛÚ‡
                      if ObjZav[hvost].bParam[15] or ObjZav[hvost].bParam[19] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                        inc(MarhTracert[Group].MsgCount);
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,137, ObjZav[hvost].Liter,1);
                        InsMsg(Group,hvost,137);
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;

                      if ObjZav[o].bParam[18] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡
                        inc(MarhTracert[Group].MsgCount);
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,159, ObjZav[hvost].Liter,1);
                        InsMsg(Group,hvost,159);
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;
                    end else
                    begin
                      if ObjZav[hvost].bParam[15] or ObjZav[hvost].bParam[19] then
                      begin //--------------------------------- Óı‡ÌÌ‡ˇ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ
                        inc(MarhTracert[Group].WarCount);
                        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                        GetShortMsg(1,137, ObjZav[hvost].Liter,1);
                        InsWar(Group,hvost,137);
                        result := trBreak;
                        MarhTracert[Group].GonkaStrel := false;
                      end;
                    end;
                  end;
                end;
              end else
              begin //--------------------- Ï‡¯ÛÚÌ‡ˇ „ÓÌÍ‡ ÒÚÂÎÍË ‚ ÔÛÚË ÌÂ ‚˚ÔÓÎÌˇÂÚÒˇ
                if ObjZav[s_v_put].ObjConstB[k*3] and not ObjZav[o].bParam[1] then
                begin //------------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÔÎ˛ÒÂ
                  if (ObjZav[s_v_put].ObjConstI[k+4] = 0) or
                  (ObjZav[hvost].bParam[21] and ObjZav[hvost].bParam[22]) then
                  begin //- ÌÂÚ ÒË„Ì.ÔËÍ. ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË ËÎË ÌÂÚ Á‡ÌˇÚÓÒÚË,Á‡Ï˚Í‡ÌËˇ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[o].Liter,1);
                    InsMsg(Group,hvost,268);
                    MarhTracert[Group].GonkaStrel := false; exit;
                  end;
                end;

                if ObjZav[s_v_put].ObjConstB[k*3+1] and not ObjZav[o].bParam[2] then
                begin //------------------------ ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÏËÌÛÒÂ
                  if (ObjZav[s_v_put].ObjConstI[k+4] = 0) or
                  (ObjZav[hvost].bParam[21] and ObjZav[hvost].bParam[22]) then
                  begin //- ÌÂÚ ÒË„Ì.ÔËÍ. ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË ËÎË ÌÂÚ Á‡ÌˇÚÓÒÚË,Á‡Ï˚Í‡ÌËˇ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,267, ObjZav[o].Liter,1);
                    InsMsg(Group,hvost,267);
                    MarhTracert[Group].GonkaStrel := false; exit;
                  end;
                end;
              end;
            end;
          end;
        end
        else ObjZav[s_v_put].bParam[21] := false;
      end;

      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd : result := trStop;
      end;
    end;

    //----------------------- ÍÓÏÔ¸˛ÚÂÌÓÂ Á‡Ï˚Í‡ÌËÂ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡ ---------------------
    tlZamykTrace :
    begin
      ObjZav[s_v_put].bParam[21] := false;//---- ÔËÁÌ‡Í Ú‡ÒÒËÓ‚ÍË ÔÓÂÁ‰ÌÓ„Ó ÓÚÔ‡‚ÎÂÌËˇ

      if Con.Pin = 1 then
      begin
        Con := ObjZav[s_v_put].Neighbour[2];

        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;

        if ObjZav[s_v_put].ObjConstB[1] then //--------------------- ÂÒÎË ÔÓ‚ÂˇÚ¸ 1->2
        begin
          if Rod = MarshP then ObjZav[s_v_put].bParam[20] := true //ÔÓÂÁ‰ÌÓÂ ÓÚÔ‡‚ÎÂÌËÂ
          else ObjZav[s_v_put].bParam[20] := false;
        end;
      end else
      if Con.Pin = 2 then
      begin
        Con := ObjZav[s_v_put].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;

        if ObjZav[s_v_put].ObjConstB[2] then //--------------------- ÂÒÎË ÔÓ‚ÂˇÚ¸ 2->1
        begin
          if Rod = MarshP then ObjZav[s_v_put].bParam[20] := true //ÔÓÂÁ‰ÌÓÂ ÓÚÔ‡‚ÎÂÌËÂ
          else ObjZav[s_v_put].bParam[20] := false;
        end;
      end
      else  ObjZav[s_v_put].bParam[20] := false; //------------ ‰Û„ËÂ ÚÓ˜ÍË ÌÂ‰ÓÔÛÒÚËÏ˚
    end;

    tlAutoTrace,
    tlSignalCirc,
    tlPovtorRazdel,
    tlRazdelSign :
    begin
      result := trNextStep;
      if Con.Pin = 1 then
      begin
        if ObjZav[s_v_put].ObjConstB[1] then
        begin
          if Rod = MarshP then
          begin
            ObjZav[s_v_put].bParam[20] := true;
            ObjZav[s_v_put].bParam[21] := true;
            for k := 1 to 4 do
            begin
              o := ObjZav[s_v_put].ObjConstI[k];
              if o > 0 then
              begin
                if not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
                begin //----------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,81, ObjZav[ObjZav[o].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[o].BaseObject,81);
                end;

                if ObjZav[s_v_put].ObjConstB[k*3] and not ObjZav[o].bParam[1] then
                begin //------------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÔÎ˛ÒÂ
                  if ObjZav[s_v_put].ObjConstI[k+4] = 0 then
                  begin //----------------------- ÌÂÚ ÒË„Ì‡Î‡ ÔËÍ˚ÚËˇ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,268);
                  end else
                  if ObjZav[ObjZav[o].BaseObject].bParam[21] and
                  ObjZav[ObjZav[o].BaseObject].bParam[22] then
                  begin //--------------------------------------- ÌÂÚ Á‡ÌˇÚÓÒÚË, Á‡Ï˚Í‡ÌËˇ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,268);
                  end else
                  if not ObjZav[ObjZav[s_v_put].UpdateObject].bParam[2] then
                  begin //ÌÂËÒÔ.ÒË„Ì‡Î ÔËÍ˚ÚËˇ ÒÚÂÎÍË ‚ ÔÛÚË ÔË Á‡Ï˚Í‡ÌËˇ ‚˚ıÓ‰ÌÓÈ —œ
                    if ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].bParam[5] then
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      if ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].bParam[10] then
                      begin //-------------------------------- ÌÂËÒÔ‡‚ÂÌ ÒË„Ì‡Î ÔËÍ˚ÚËˇ
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,481, ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].Liter,1);
                        InsMsg(Group,ObjZav[s_v_put].ObjConstI[k+4],481);
                      end else //------------------------------------- ÌÂËÒÔ‡‚ÂÌ Ò‚ÂÚÓÙÓ
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,272, ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].Liter,1);
                        InsMsg(Group,ObjZav[s_v_put].ObjConstI[k+4],272);
                      end;
                    end;
                  end;
                end;

                if ObjZav[s_v_put].ObjConstB[k*3+1] and not ObjZav[o].bParam[2] then
                begin //------------------------ ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÏËÌÛÒÂ
                  if ObjZav[s_v_put].ObjConstI[k+4] = 0 then
                  begin //----------------------- ÌÂÚ ÒË„Ì‡Î‡ ÔËÍ˚ÚËˇ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,268);
                  end else

                  if ObjZav[ObjZav[o].BaseObject].bParam[21] and
                  ObjZav[ObjZav[o].BaseObject].bParam[22] then
                  begin //--------------------------------------- ÌÂÚ Á‡ÌˇÚÓÒÚË, Á‡Ï˚Í‡ÌËˇ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,268);
                  end else

                  if not ObjZav[ObjZav[s_v_put].UpdateObject].bParam[2] then
                  begin //-- ÌÂËÒÔ.ÒË„Ì‡Î ÔËÍ˚ÚËˇ ÒÚ. ‚ ÔÛÚË ÔË Á‡ÏÍÌÛÚÓÈ ‚˚ıÓ‰ÌÓÈ —œ
                    if ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].bParam[5] then
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      if ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].bParam[10] then
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,481, ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].Liter,1);
                        InsMsg(Group,ObjZav[s_v_put].ObjConstI[k+4],481);
                      end else // ÌÂËÒÔ‡‚ÂÌ Ò‚ÂÚÓÙÓ

                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,272, ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].Liter,1);
                        InsMsg(Group,ObjZav[s_v_put].ObjConstI[k+4],272);
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end else
          begin
            ObjZav[s_v_put].bParam[20] := false;
            ObjZav[s_v_put].bParam[21] := false;
          end;
        end else
        begin
          ObjZav[s_v_put].bParam[20] := false;
          ObjZav[s_v_put].bParam[21] := false;
        end;

        if result = trNextStep then
        begin
          Con := ObjZav[s_v_put].Neighbour[2];
          case Con.TypeJmp of
            LnkRgn : result := trRepeat;
            LnkEnd : result := trRepeat;
          end;
        end;
      end else
      begin
        if ObjZav[s_v_put].ObjConstB[2] then
        begin
          if Rod = MarshP then
          begin
            ObjZav[s_v_put].bParam[20] := true;
            ObjZav[s_v_put].bParam[21] := true;
            for k := 1 to 4 do
            begin
              o := ObjZav[s_v_put].ObjConstI[k];
              if o > 0 then
              begin
                if not ObjZav[o].bParam[1] and not ObjZav[o].bParam[2] then
                begin //----------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
                  inc(MarhTracert[Group].MsgCount);
                  MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                  GetShortMsg(1,81, ObjZav[ObjZav[o].BaseObject].Liter,1);
                  InsMsg(Group,ObjZav[o].BaseObject,81);
                end;

                if ObjZav[s_v_put].ObjConstB[k*3] and not ObjZav[o].bParam[1] then
                begin //------------------------- ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÔÎ˛ÒÂ
                  if ObjZav[s_v_put].ObjConstI[k+4] = 0 then
                  begin //----------------------- ÌÂÚ ÒË„Ì‡Î‡ ÔËÍ˚ÚËˇ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,268);
                  end else
                  if ObjZav[ObjZav[o].BaseObject].bParam[21] and
                  ObjZav[ObjZav[o].BaseObject].bParam[22] then
                  begin //--------------------------------------- ÌÂÚ Á‡ÌˇÚÓÒÚË, Á‡Ï˚Í‡ÌËˇ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,268);
                  end else

                  if not ObjZav[ObjZav[s_v_put].UpdateObject].bParam[2] then
                  begin //-- ÌÂËÒÔ.ÒË„Ì‡Î ÔËÍ˚ÚËˇ ÒÚ ‚ ÔÛÚË ÔË Á‡Ï˚ÍÌÛÚÓÈ ‚˚ıÓ‰ÌÓÈ —œ
                    if ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].bParam[5] then
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      //-------------------------------------- ÌÂËÒÔ‡‚ÂÌ ÒË„Ì‡Î ÔËÍ˚ÚËˇ
                      if ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].bParam[10] then
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,481, ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].Liter,1);
                        InsMsg(Group,ObjZav[s_v_put].ObjConstI[k+4],481);
                      end else //------------------------------------- ÌÂËÒÔ‡‚ÂÌ Ò‚ÂÚÓÙÓ
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,272, ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].Liter,1);
                        InsMsg(Group,ObjZav[s_v_put].ObjConstI[k+4],272);
                      end;
                    end;
                  end;
                end;

                if ObjZav[s_v_put].ObjConstB[k*3+1] and not ObjZav[o].bParam[2] then
                begin //------------------------ ÒÚÂÎÍ‡ ‚ ÔÛÚË ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ‚ ÏËÌÛÒÂ
                  if ObjZav[s_v_put].ObjConstI[k+4] = 0 then
                  begin //----------------------- ÌÂÚ ÒË„Ì‡Î‡ ÔËÍ˚ÚËˇ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,268);
                  end else
                  if ObjZav[ObjZav[o].BaseObject].bParam[21] and
                  ObjZav[ObjZav[o].BaseObject].bParam[22] then
                  begin //--------------------------------------- ÌÂÚ Á‡ÌˇÚÓÒÚË, Á‡Ï˚Í‡ÌËˇ
                    inc(MarhTracert[Group].MsgCount);
                    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                    GetShortMsg(1,268, ObjZav[ObjZav[o].BaseObject].Liter,1);
                    InsMsg(Group,ObjZav[o].BaseObject,268);
                  end else

                  if not ObjZav[ObjZav[s_v_put].UpdateObject].bParam[2] then
                  begin //-- ÌÂËÒÔ.ÒË„Ì‡Î ÔËÍ˚ÚËˇ ÒÚ. ‚ ÔÛÚË ÔË Á‡ÏÍÌÛÚÓÈ ‚˚ıÓ‰ÌÓÈ —œ
                    if ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].bParam[5] then
                    begin
                      inc(MarhTracert[Group].MsgCount);
                      if ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].bParam[10] then
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,481, ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].Liter,1);
                        InsMsg(Group,ObjZav[s_v_put].ObjConstI[k+4],481);
                      end else // ÌÂËÒÔ‡‚ÂÌ Ò‚ÂÚÓÙÓ
                      begin
                        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
                        GetShortMsg(1,272, ObjZav[ObjZav[s_v_put].ObjConstI[k+4]].Liter,1);
                        InsMsg(Group,ObjZav[s_v_put].ObjConstI[k+4],272);
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end else
          begin
            ObjZav[s_v_put].bParam[20] := false;
            ObjZav[s_v_put].bParam[21] := false;
          end;
        end else
        begin
          ObjZav[s_v_put].bParam[20] := false;
          ObjZav[s_v_put].bParam[21] := false;
        end;
        if result = trNextStep then
        begin
          Con := ObjZav[s_v_put].Neighbour[1];
          case Con.TypeJmp of
            LnkRgn : result := trRepeat;
            LnkEnd : result := trRepeat;
          end;
        end;
      end;
    end;

    tlOtmenaMarh :
    begin
      if ObjZav[s_v_put].bParam[5] then ObjZav[s_v_put].bParam[20] := false;
      ObjZav[s_v_put].bParam[21] := false;
      if Con.Pin = 1 then
      begin
        Con := ObjZav[s_v_put].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[s_v_put].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end;
    end;

    else result := trNextStep;
   end;
end;
//========================================================================================
function StepTracePerezamStrInPut(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------  ÓÌÚÓÎ¸ ÔÂÂÁ‡Ï˚Í‡ÌËˇ Ï‡¯ÛÚÓ‚ ÔËÂÏ‡ ‰Îˇ ÒÚÂÎÍË ‚ ÔÛÚË (42)
var
  k,o : integer;
begin
  case Lvl of
    //----------------------------- œ Œ » —     “ – ¿ — — € ------------------------------
    tlFindTrace :
    begin
      result := trNextStep;
      //------------- ÔË ÔÓËÒÍÂ Ú‡ÒÒ˚ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡ ÒÓı‡ÌËÚ¸ Ó·˙ÂÍÚ ÒÚÂÎÍË ‚ ÔÛÚË
      if Rod = MarshP then
      MarhTracert[Group].VP := jmp.Obj;

      if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
      else Con := ObjZav[jmp.Obj].Neighbour[1];

      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;

    tlVZavTrace,   //--------- œÓ‚ÂÍ‡ ‚Á‡ËÏÓÁ‡‚ËÒËÏÓÒÚÂÈ ÔÓ Ú‡ÒÒÂ (Óı‡ÌÌÓÒÚË Ë ÔÓ˜ÂÂ)
    tlContTrace :  //----- ƒÓ‚ÂÒÚË Ú‡ÒÒÛ ‰Ó ÔÂ‰ÔÓÎ‡„‡ÂÏÓ„Ó ÍÓÌˆ‡ ËÎË ÓÚÍÎÓÌˇ˛˘ÂÈ ÒÚÂÎÍË
    begin
      result := trNextStep;

      if Rod = MarshP then MarhTracert[Group].VP := jmp.Obj; //ÒÓı‡ÌËÚ¸ Ó·˙ÂÍÚ ‰Îˇ ÔÓÂÁ‰‡

      if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
      else Con := ObjZav[jmp.Obj].Neighbour[1];

      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trStop;
      end;
    end;

    //--------------------------- œ – Œ ¬ ≈ –   ¿   “ – ¿ — — €  -------------------------
    tlCheckTrace :
    begin
      if Rod = MarshP then
      begin
        for k := 1 to 4 do //--------------------- ÔÓÈÚË ÔÓ 4-Ï ‚ÓÁÏÓÊÌ˚Ï ÒÚÂÎÍ‡Ï ‚ ÔÛÚË
        begin
          o := ObjZav[jmp.Obj].ObjConstI[k];
          if o > 0 then
          begin //-------------------- ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ Ú‡ÒÒËÓ‚ÍË ÔÓ "-" ÒÚÂÎÍË ‚ ÔÛÚË
            if ObjZav[o].bParam[13] then
            begin// Á‡‚Â¯ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË ·˚Î‡ ÂÁ‰‡ ÔÓ "-" ÒÚÂÎÍË ‚ ÔÛÚË
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,482, ObjZav[ObjZav[o].BaseObject].Liter,1);
              InsWar(Group,ObjZav[o].BaseObject,482);
              break;
            end;
          end;
        end;
      end;
      result := trNextStep;

      if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
      else  Con := ObjZav[jmp.Obj].Neighbour[1];

      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trStop;
      end;
    end;

    tlPovtorMarh,
    tlFindIzvest,
    tlFindIzvStrel :
    begin
      result := trNextStep;

      if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
      else Con := ObjZav[jmp.Obj].Neighbour[1];

      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trStop;
      end;
    end;

    tlZamykTrace :
    begin
      result := trNextStep;
      if Rod = MarshP then ObjZav[jmp.Obj].bParam[1] := true; //- ÔËÁÌ‡Í ÔÓÂÁ‰ÌÓ„Ó ÔËÂÏ‡

      if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
      else Con := ObjZav[jmp.Obj].Neighbour[1];

      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trStop;
      end;
    end;

    tlAutoTrace,
    tlSignalCirc,
    tlPovtorRazdel,
    tlRazdelSign :
    begin
      if Rod = MarshP then MarhTracert[Group].VP:= jmp.Obj;//ı‡ÌËÚ¸ Ó·˙ÂÍÚ ÒÚÂÎÍË ‚ ÔÛÚË
      result := trNextStep;

      if Rod = MarshP then ObjZav[jmp.Obj].bParam[1] := true; //- ÔËÁÌ‡Í ÔÓÂÁ‰ÌÓ„Ó ÔËÂÏ‡

      if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
      else Con := ObjZav[jmp.Obj].Neighbour[1];

      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;

    tlOtmenaMarh :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trEnd;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end;
    end;

    else result := trNextStep;
  end;
end;
//========================================================================================
function StepTraceOPI(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------------------------------------------------------- Óœ» (43)
var
  j,k,o : integer;
  tr : boolean;
begin
      case Lvl of
        tlFindTrace : begin
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trRepeat;
              LnkEnd : result := trRepeat;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trRepeat;
              LnkEnd : result := trRepeat;
            else
              result := trNextStep;
            end;
          end;
        end;

        tlVZavTrace : begin
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trStop;
            else
              result := trNextStep;
            end;
          end;
        end;

        tlCheckTrace : begin
          tr := true;
          result := trNextStep;
          if Con.Pin = 1 then
          begin
            if (Rod = MarshP) and ObjZav[jmp.Obj].ObjConstB[1] then
            begin
              o := ObjZav[jmp.Obj].BaseObject;
              if o > 0 then
              begin // ÔÓÚ‡ÒÒËÓ‚‡Ú¸ ‚˚ÂÁ‰ Ì‡ ÔÛÚË ËÁ Ï‡ÌÂ‚Ó‚Ó„Ó ‡ÈÓÌ‡
                k := 2;
                o := ObjZav[jmp.Obj].Neighbour[k].Obj; k := ObjZav[jmp.Obj].Neighbour[k].Pin; j := 50;
                while j > 0 do
                begin
                  case ObjZav[o].TypeObj of
                    2 : begin // ÒÚÂÎÍ‡
                      case k of
                        2 : begin
                          if ObjZav[ObjZav[o].BaseObject].bParam[11] then
                          begin // ÒÚÂÎÍÛ ÏÓÊÌÓ ÔÓÒÚ‡‚ËÚ¸ ‚ ÓÚ‚Ó‰ ÔÓ ÏËÌÛÒÛ
                            tr := false; break;
                          end;
                        end;
                        3 : begin
                          if ObjZav[ObjZav[o].BaseObject].bParam[10] then
                          begin // ÒÚÂÎÍÛ ÏÓÊÌÓ ÔÓÒÚ‡‚ËÚ¸ ‚ ÓÚ‚Ó‰ ÔÓ ÔÎ˛ÒÛ
                            tr := false; break;
                          end;
                        end;
                      end;
                      k := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
                    end;
                    48 : begin // –œÓ
                      break;
                    end;
                  else
                    if k = 1 then begin k := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj; end
                    else begin k := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end;
                  end;
                  if (o = 0) or (k < 1) then break;
                  dec(j);
                end;
              end;
              if tr then // ÌÂÚ ÓÚ‚Ó‰ˇ˘Ëı ÒÚÂÎÓÍ ÔÓ Ú‡ÒÒÂ ‰Ó Ó·˘ÂÈ ÚÓ˜ÍË ÔÛ˜Í‡
              begin
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,258, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1); InsMsg(Group,ObjZav[jmp.Obj].BaseObject,258); MarhTracert[Group].GonkaStrel := false;
              end else
              if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[3] and not ObjZav[jmp.Obj].bParam[1] then // Ã» Ë Óœ»
              begin
                inc(MarhTracert[Group].WarCount); MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,258, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1); InsWar(Group,ObjZav[jmp.Obj].BaseObject,258); MarhTracert[Group].GonkaStrel := false;
              end;
            end;
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end else
          begin
            if (Rod = MarshP) and ObjZav[jmp.Obj].ObjConstB[2] then
            begin
              o := ObjZav[jmp.Obj].BaseObject;
              if o > 0 then
              begin // ÔÓÚ‡ÒÒËÓ‚‡Ú¸ ‚˚ÂÁ‰ Ì‡ ÔÛÚË ËÁ Ï‡ÌÂ‚Ó‚Ó„Ó ‡ÈÓÌ‡
                k := 1;
                o := ObjZav[jmp.Obj].Neighbour[k].Obj; k := ObjZav[jmp.Obj].Neighbour[k].Pin; j := 50;
                while j > 0 do
                begin
                  case ObjZav[o].TypeObj of
                    2 : begin // ÒÚÂÎÍ‡
                      case k of
                        2 : begin
                          if ObjZav[ObjZav[o].BaseObject].bParam[11] then
                          begin // ÒÚÂÎÍÛ ÏÓÊÌÓ ÔÓÒÚ‡‚ËÚ¸ ‚ ÓÚ‚Ó‰ ÔÓ ÏËÌÛÒÛ
                            tr := false; break;
                          end;
                        end;
                        3 : begin
                          if ObjZav[ObjZav[o].BaseObject].bParam[10] then
                          begin // ÒÚÂÎÍÛ ÏÓÊÌÓ ÔÓÒÚ‡‚ËÚ¸ ‚ ÓÚ‚Ó‰ ÔÓ ÔÎ˛ÒÛ
                            tr := false; break;
                          end;
                        end;
                      end;
                      k := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj;
                    end;
                    48 : begin // –œÓ
                      break;
                    end;
                  else
                    if k = 1 then begin k := ObjZav[o].Neighbour[2].Pin; o := ObjZav[o].Neighbour[2].Obj; end
                    else begin k := ObjZav[o].Neighbour[1].Pin; o := ObjZav[o].Neighbour[1].Obj; end;
                  end;
                  if (o = 0) or (k < 1) then break;
                  dec(j);
                end;
              end;
              if tr then // ÌÂÚ ÓÚ‚Ó‰ˇ˘Ëı ÒÚÂÎÓÍ ÔÓ Ú‡ÒÒÂ ‰Ó Ó·˘ÂÈ ÚÓ˜ÍË ÔÛ˜Í‡
              begin
                inc(MarhTracert[Group].MsgCount); MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] := GetShortMsg(1,258, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1); InsMsg(Group,ObjZav[jmp.Obj].BaseObject,258); MarhTracert[Group].GonkaStrel := false;
              end else
              if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[3] and not ObjZav[jmp.Obj].bParam[1] then // Ã» Ë Óœ»
              begin
                inc(MarhTracert[Group].WarCount); MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,258, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1); InsWar(Group,ObjZav[jmp.Obj].BaseObject,258); MarhTracert[Group].GonkaStrel := false;
              end;
            end;
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end;
        end;

        tlAutoTrace,
        tlPovtorRazdel,
        tlRazdelSign,
        tlSignalCirc : begin
          result := trNextStep;
          if Con.Pin = 1 then
          begin
            if (Rod = MarshP) and ObjZav[jmp.Obj].ObjConstB[1] then
            begin
              if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[3] and not ObjZav[jmp.Obj].bParam[1] then // Ã» Ë Óœ»
              begin
                inc(MarhTracert[Group].WarCount); MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,258, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1); InsWar(Group,ObjZav[jmp.Obj].BaseObject,258);
              end;
            end;
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end else
          begin
            if (Rod = MarshP) and ObjZav[jmp.Obj].ObjConstB[2] then
            begin
              if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[3] and not ObjZav[jmp.Obj].bParam[1] then // Ã» Ë Óœ»
              begin
                inc(MarhTracert[Group].WarCount); MarhTracert[Group].Warning[MarhTracert[Group].WarCount] := GetShortMsg(1,258, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1); InsWar(Group,ObjZav[jmp.Obj].BaseObject,258);
              end;
            end;
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trStop;
              LnkEnd : result := trStop;
            end;
          end;
        end;

      else
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
            case Con.TypeJmp of
              LnkRgn : result := trEnd;
              LnkEnd : result := trEnd;
            else
              result := trNextStep;
            end;
          end;
      end;
    end;
//========================================================================================
function StepTraceZonaOpov(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------------------------------------------- «ÓÌ‡ ÓÔÓ‚Â˘ÂÌËˇ (45)
begin
      case Lvl of
        tlFindTrace :
        begin
          result := trNextStep;
          if Con.Pin = 1 then
          begin
            Con := ObjZav[jmp.Obj].Neighbour[2];
          end else
          begin
            Con := ObjZav[jmp.Obj].Neighbour[1];
          end;
          case Con.TypeJmp of
            LnkRgn : result := trRepeat;
            LnkEnd : result := trRepeat;
          end;
        end;

        tlVZavTrace,
        tlFindIzvest,
        tlZamykTrace,
        tlOtmenaMarh,
        tlFindIzvStrel,
        tlPovtorMarh,
        tlContTrace :
        begin
          result := trNextStep;
          if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
          else Con := ObjZav[jmp.Obj].Neighbour[1];
          case Con.TypeJmp of
            LnkRgn : result := trEnd;
            LnkEnd : result := trStop;
          end;
        end;

        tlSetAuto,  
        tlSignalCirc,
        tlPovtorRazdel,
        tlRazdelSign,
        tlCheckTrace :
        begin
          result := trNextStep;
          if ObjZav[jmp.Obj].bParam[1] then
          begin //------------------------------------------- ¬ÍÎ˛˜ÂÌÓ ÓÔÓ‚Â˘ÂÌËÂ ÏÓÌÚÂÓ‚
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,456, ObjZav[jmp.Obj].Liter,1); //-- $ ÓÔÓ‚Â˘ÂÌËÂ ÏÓÌÚÂÓ‚ ‚ÍÎ˛˜ÂÌÓ
            InsWar(Group,jmp.Obj,456);
          end;
          if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
          else Con := ObjZav[jmp.Obj].Neighbour[1];
          case Con.TypeJmp of
            LnkRgn : result := trEnd;
            LnkEnd : result := trStop;
          end;
        end;

        tlAutoTrace :
        begin
          result := trNextStep;
          if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
          else Con := ObjZav[jmp.Obj].Neighbour[1];
          case Con.TypeJmp of
            LnkRgn : result := trEnd;
            LnkEnd : result := trStop;
          end;
        end;

        else result := trNextStep;
      end;
    end;
//========================================================================================
function StepTraceProchee(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//--------------------------------------- ÔÓ˜ËÂ Ó·˙ÂÍÚ˚ (Ú‡ÌÁËÚ ˜ÂÂÁ ÒÂ·ˇ ·ÂÁ ÔÓ‚ÂÓÍ)
begin
  case Lvl of
    tlFindTrace :
    begin
      if Con.Pin = 1 then
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end else
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          else result := trNextStep;
        end;
      end;
    end;
    else
    if Con.Pin = 1 then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else result := trNextStep;
      end;
    end else
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trEnd;
        else result := trNextStep;
      end;
    end;
  end;
end;
//========================================================================================
function StepStrelFindTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  Strelka : integer;
//---------------------------------------------------- ÔÓıÓ‰ ÔÓ ÒÚÂÎÍÂ ÔË ÔÓËÒÍÂ Ú‡ÒÒ˚
begin
  Strelka :=  jmp.Obj;
  result := trNextStep;
  case Con.Pin of //--------------- ÔÂÂÍÎ˛˜‡ÚÂÎ¸ ÔÓ ÚÓ˜ÍÂ ‚ıÓ‰‡ ˜ÂÂÁ ÍÓÌÌÂÍÚÓ Ò ÒÓÒÂ‰ÓÏ
    1 : //------------------------------------------------------------------ œÓÚË‚ ¯ÂÒÚË
    begin
      if ObjZav[Strelka].ObjConstB[1] then //--------------------------- ÂÒÎË Ò·‡Ò˚‚‡˛˘‡ˇ
      begin //------------------------- —·‡Ò˚‚‡˛˘‡ˇ ÒÚÂÎÍ‡ Ú‡ÒÒËÛÂÚÒˇ ÚÓÎ¸ÍÓ ÔÓ ÏËÌÛÒÛ
        Con := ObjZav[Strelka].Neighbour[3]; //------------------ ÚÓ˜Í‡ ‚˚ıÓ‰‡ - ÔÓ ÏËÌÛÒÛ
        ObjZav[Strelka].bParam[10] := true; //--------------------- œÓÏÂÚËÚ¸ ÔÂ‚˚È ÔÓıÓ‰
        ObjZav[Strelka].bParam[11] := true; //--------------------- œÓÏÂÚËÚ¸ ÔÂ‚˚È ÔÓıÓ‰
      end
      else
      begin //------------------------------------------------------------ ’Ó‰Ó‚‡ˇ ÒÚÂÎÍ‡
        if ObjZav[Strelka].ObjConstB[3] then //---------- ÂÒÎË ÓÒÌÓ‚Ì˚Â Ï‡¯ÛÚ˚ ÔÓ ÏËÌÛÒÛ
        begin
          if not ObjZav[Strelka].bParam[10] then //---------- ÂÒÎË ÌÂ ·˚ÎÓ ÔÂ‚Ó„Ó ÔÓıÓ‰‡
          begin //----------------------------------------- ¬Ì‡˜‡ÎÂ Ë‰ÚË ÔÓ ÏËÌÛÒÛ ÒÚÂÎÍË
            Con := ObjZav[Strelka].Neighbour[3]; //----------- ÍÓÌÌÂÍÚÓ ÒÓ ÒÚÓÓÌ˚ ÏËÌÛÒ‡
            ObjZav[Strelka].bParam[10] := true; //----------------- œÓÏÂÚËÚ¸ ÔÂ‚˚È ÔÓıÓ‰
            ObjZav[Strelka].bParam[11] := true; //----------------- œÓÏÂÚËÚ¸ ÔÂ‚˚È ÔÓıÓ‰
          end else
          begin //----------------------------- ÔË ‚ÚÓÓÏ ÔÓıÓ‰Â ÔÓÈÚË ÔÓ ÔÎ˛ÒÛ ÒÚÂÎÍË
            Con := ObjZav[Strelka].Neighbour[2]; //------ ‚˚ÈÚË Ì‡ ÍÓÌÌÂÍÚÓ ÒÚÓÓÌ˚ ÔÎ˛Ò‡
            ObjZav[Strelka].bParam[11] := false; //---------------- œÓÏÂÚËÚ¸ ‚ÚÓÓÈ ÔÓıÓ‰
          end;
        end else//---------------------------------------- ÂÒÎË ÓÒÌÓ‚Ì˚Â Ï‡¯ÛÚ˚ ÔÓ ÔÎ˛ÒÛ
        begin
          if ObjZav[Strelka].bParam[10] then //-------- ÂÒÎË ÔÂ‚˚È ÔÓıÓ‰ Ú‡ÒÒËÓ‚ÍË ·˚Î
          begin //-------------------------------- ÚÓ ‚ÚÓÓÈ ÔÓıÓ‰ Ë‰ÚË ÔÓ ÏËÌÛÒÛ ÒÚÂÎÍË
            Con := ObjZav[Strelka].Neighbour[3];
            ObjZav[Strelka].bParam[11] := true; //-------------- œÓÏÂÚËÚ¸ ‚ÚÓË˜Ì˚È ÔÓıÓ‰
          end else
          begin //---------------------------------------- ¬Ì‡˜‡ÎÂ ÔÓÈÚË ÔÓ ÔÎ˛ÒÛ ÒÚÂÎÍË
            Con := ObjZav[Strelka].Neighbour[2];
            ObjZav[Strelka].bParam[10] := true; //-------------- œÓÏÂÚËÚ¸ ÔÂ‚Ë˜Ì˚È ÔÓıÓ‰
          end;
        end;
      end;

      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
        else result := trNextStep;
      end;
    end;

    2 ://--------------------------------------------------------------- œÓ ¯ÂÒÚË Ò ÔÎ˛Ò‡
    begin
      ObjZav[Strelka].bParam[12] := true; //------------ œÓÏÂÚËÚ¸ ÔÓıÓ‰ ÔÓ ¯ÂÒÚË Ò ÔÎ˛Ò‡
      Con := ObjZav[Strelka].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
        else result := trNextStep;
      end;
    end;

    3 ://-------------------------------------------------------------- œÓ ¯ÂÒÚË Ò ÏËÌÛÒ‡
    begin
      ObjZav[Strelka].bParam[13] := true; //----------- œÓÏÂÚËÚ¸ ÔÓıÓ‰ ÔÓ ¯ÂÒÚË Ò ÏËÌÛÒ‡
      Con := ObjZav[Strelka].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
        else result := trNextStep;
      end;
    end;
  end;
end;
//========================================================================================
function StepStrelContTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//---------------------------------------------- ÔÓıÓ‰ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË ÔÓ‰ÎÂÌËË Ú‡ÒÒ˚
var
  p : boolean;
  k : integer;
begin
  result := trNextStep;
  p := false;

  case Con.Pin of
    1 ://------------------------------------------------- ÔÓÚË‚Ó¯ÂÒÚÌ˚È ‚ıÓ‰ Ì‡ ÒÚÂÎÍÛ
    begin
      if MarhTracert[Group].VP >0 then //--------- ÂÒÚ¸ ¬œ ‰Îˇ Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡ ÔËÂÏ‡
      begin //-------------------------------------------- ÔÓÈÚË ÔÓ ÒÔËÒÍÛ ÒÚÂÎÓÍ ‚ ÔÛÚË
        //--- ÔÓÎÛ˜ËÚ¸ Ó˜ÂÂ‰ÌÛ˛ ÒÚÂÎÍÛ ‚ ÔÛÚË, ÂÒÎË ˝ÚÓ ÓÌ‡  Ë ˜ÂÂÁ ÌÂ∏ ÔÓıÓ‰ËÚ Ú‡ÒÒ‡
        for k := 1 to 4 do //---------------------------- ÏÓÊÂÚ ·˚Ú¸ ‰Ó 4-ı ÒÚÂÎÓÍ ‚ ÔÛÚË
        if(ObjZav[MarhTracert[Group].VP].ObjConstI[k] = jmp.Obj) and //-- ÂÒÎË ˝Ú‡ ÒÚÂÎÍ‡
        ObjZav[MarhTracert[Group].VP].ObjConstB[k+1] then //-------- ÔËÁÌ‡Í ‰Ó·Ó‡ Ú‡ÒÒ˚
        begin //-------------------------------------------- Ú‡ÒÒËÓ‚‡Ú¸ ÒÚÂÎÍÛ ÔÓ ÔÎ˛ÒÛ
          Con := ObjZav[jmp.Obj].Neighbour[2]; //------------- ÔÓÎÛ˜ËÚ¸ ÍÓÌÌÂÍÚÓ ÔÓ ÔÎ˛ÒÛ
          ObjZav[jmp.Obj].bParam[10] := true;  //------------------ ÛÒÚ‡ÌÓ‚ËÚ¸ 1-˚È ÔÓıÓ‰
          ObjZav[jmp.Obj].bParam[11] := false; //----------------------- ÒÌˇÚ¸ 2-ÓÈ ÔÓıÓ‰
          ObjZav[jmp.Obj].bParam[12] := false; //---------------- ÒÌˇÚ¸ ÔÓ¯ÂÒÚÌ‡ˇ ‚ ÔÎ˛ÒÂ
          ObjZav[jmp.Obj].bParam[13] := false; //--------------- ÒÌˇÚ¸ ÔÓ¯ÂÒÚÌ‡ˇ ‚ ÏËÌÛÒÂ
          result := trNextStep;
          p := true;
          break;
        end;

        if not p then
        begin //----------------------- ÒÚÂÎÍ‡ ÌÂ ÓÔËÒ‡Ì‡ ‚ ÚÂÍÛ˘ÂÏ ÒÔËÒÍÂ ÒÚÂÎÓÍ ‚ ÔÛÚË
          con := ObjZav[jmp.Obj].Neighbour[1]; //-------------- ÍÓÌÌÂÍÚÓ ÒÓ ÒÚÓÓÌ˚ ‚ıÓ‰‡
          result := trBreak; //--------------------------------------- ÓÚÍ‡ÚËÚ¸ ÓÚ ÒÚÂÎÍË
        end;
      end else //------------------------------------------------------ ÌÂÚ ÒÚÂÎÓÍ ‚ ÔÛÚË

      if ObjZav[jmp.Obj].ObjConstB[1] then //------------------- ÂÒÎË Ò·‡Ò˚‚‡˛˘‡ˇ ÒÚÂÎÍ‡
      begin //------------------ Ò·‡Ò˚‚‡˛˘‡ˇ ÒÚÂÎÍ‡ ‚ÒÂ„‰‡ Ú‡ÒÒËÛÂÚÒˇ ÚÓÎ¸ÍÓ ÔÓ ÏËÌÛÒÛ
        Con := ObjZav[jmp.Obj].Neighbour[3]; //---------------- ·ÂÂÏ ÍÓÌÌÂÍÚÓ Á‡ ÏËÌÛÒÓÏ
        ObjZav[jmp.Obj].bParam[10] := true; //------------- ÂÒÚ¸ ÔÂ‚˚È ÔÓıÓ‰ Ú‡ÒÒËÓ‚ÍË
        ObjZav[jmp.Obj].bParam[11] := true; //------------- ÂÒÚ¸ ‚ÚÓÓÈ ÔÓıÓ‰ Ú‡ÒÒËÓ‚ÍË
        ObjZav[jmp.Obj].bParam[12] := false; //--------------------- ÔÓ¯ÂÒÚÌ‡ˇ ÌÂ ‚ ÔÎ˛ÒÂ
        ObjZav[jmp.Obj].bParam[13] := false; //-------------------- ÔÓ¯ÂÒÚÌ‡ˇ ÌÂ ‚ ÏËÌÛÒÂ
        result := trNextStep;
      end else
      begin //------------------------------------------ ÌÂÚ ÒÚÂÎÓÍ ‚ ÔÛÚË Ë Ò·‡Ò˚‚‡˛˘Ëı
        con := ObjZav[jmp.Obj].Neighbour[1]; //-------------------- ÍÓÌÌÂÍÚÓ ÔÂÂ‰ ‚ıÓ‰ÓÏ
        result := trBreak; //----------------------------------------- ÓÚÍ‡ÚËÚ¸ ÓÚ ÒÚÂÎÍË
      end;
    end;

    2 :
    begin //---------------------------------- ÔÓ¯ÂÒÚÌ˚È ÔÓıÓ‰ ÔÓ ÒÚÂÎÍÂ ÒÓ ÒÚÓÓÌ˚ "+"
      ObjZav[jmp.Obj].bParam[12] := true; //------------ œÓÏÂÚËÚ¸ ÔÓıÓ‰ ÔÓ ¯ÂÒÚË Ò ÔÎ˛Ò‡
      Con := ObjZav[jmp.Obj].Neighbour[1]; //----------- ÍÓÌÌÂÍÚÓ ÒÓ ÒÚÓÓÌ˚ ‚ıÓ‰‡ Ì‡ ÓÒ¸
      case Con.TypeJmp of  //--------------------------------------------- ÚËÔ˚ ÍÓÌÌÂÍÚÓ‡
        LnkRgn : result := trStop; //--------------------------- ÍÓÌÂ˜Ì˚È ÍÓÌÌÂÍÚÓ ‡ÈÓÌ‡
        LnkEnd : result := trStop; //--------------------------- ÍÓÌÂ˜Ì˚È ÍÓÌÌÂÍÚÓ ÒÚÓÍË
        else result := trNextStep;
      end;
    end;

    3 :
    begin //--------------------------------------------- ÔÓ¯ÂÒÚÌ˚È ÔÓıÓ‰ ÒÓ ÒÚÓÓÌ˚ "-"
      ObjZav[jmp.Obj].bParam[13] := true; //----------- œÓÏÂÚËÚ¸ ÔÓıÓ‰ ÔÓ ¯ÂÒÚË Ò ÏËÌÛÒ‡
      Con := ObjZav[jmp.Obj].Neighbour[1];//------------ ÍÓÌÌÂÍÚÓ ÒÓ ÒÚÓÓÌ˚ ‚ıÓ‰‡ Ì‡ ÓÒ¸
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd : result := trStop;
        else  result := trNextStep;
      end;
    end;
  end;
end;
//========================================================================================
function StepStrelZavTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//----------------------------------------- ÔÓıÓ‰ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË ÔÓ‚ÂÍÂ Á‡‚ËÒËÏÓÒÚÂÈ
var
  k : integer;
begin
  result := trNextStep;
  case Con.Pin of
    1 :
    begin //-------------------------ÔÓÚË‚Ó¯ÂÒÚÌ˚È ‚ıÓ‰, ÔÓ‚ÂËÚ¸ ÔÓ ÏÛÌÛÒÛ ÒÚÂÎÍË
      if MarhTracert[Group].VP > 0 then //ÂÒÎË ÂÒÚ¸ ÒÚÂÎÍ‡ ‚ ÔÛÚË ‚ ÔÓÂÁ‰ÌÓÏ Ï‡¯ÛÚÂ
      begin //--------------------------------------------- ÂÒÚ¸ ÒÔËÒÓÍ ÒÚÂÎÓÍ ‚ ÔÛÚË
        for k := 1 to 4 do
        if (ObjZav[MarhTracert[Group].VP].ObjConstI[k] = jmp.Obj) and//ÂÒÎË ÒÚ.‚ ÔÛÚË
        ObjZav[MarhTracert[Group].VP].ObjConstB[k+1] then //ÔËÁÌ‡Í ‰Ó·Ó‡ Ú‡ÒÒ˚ ÔÓ +
        begin //------------------------------ ÔÓ‚ÂËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÒÚÂÎÍË ÔÓ ÏËÌÛÒÛ
          if ObjZav[jmp.Obj].bParam[10] and ObjZav[jmp.Obj].bParam[11]
          then exit;
        end;
      end;

      if ObjZav[jmp.Obj].bParam[10] and not ObjZav[jmp.Obj].bParam[11] then
      begin
        con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
        exit;
      end else
      if ObjZav[jmp.Obj].bParam[10] and ObjZav[jmp.Obj].bParam[11] then
      begin
        con := ObjZav[jmp.Obj].Neighbour[3];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
        exit;
      end
      else result := trStop;
    end;

    2 :
    begin
      if ObjZav[jmp.Obj].bParam[12]  then
      begin
        con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end
      else result := trStop;
    end;

    3 :
    begin
      if ObjZav[jmp.Obj].bParam[13] then
      begin
        con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end
      else result := trStop;
    end;
  end;
end;
//========================================================================================
function StepStrelCheckTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------ ¯‡„ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË ÔÓ‚ÂÍÂ ‚‡Ê‰Â·ÌÓÒÚÂÈ ÔÓ Ú‡ÒÒÂ Ï‡¯ÛÚ‡
var
  zak : boolean;
  o : integer;
begin
  result := trNextStep;
  //------------------ ÒÌ‡˜‡Î‡ ÔÓ‚ÂËÚ¸ Á‡Ï˚Í‡ÌËÂ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ ÒÓ ÒÚÂÎÍÓÈ ‚ ÔÛÚË
  if not CheckOtpravlVP(jmp.Obj,Group) then result := trBreak;

  //------------------------------------ ÚÂÔÂ¸ ÔÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÛÚË ˜ÂÂÁ ¬Á ÒÚÂÎÍË
  if not CheckOgrad(jmp.Obj,Group) then result := trBreak;

  if ObjZav[jmp.Obj].ObjConstB[6] then //------------------ ÂÒÎË ÒÚÂÎÍ‡ "‰‡Î¸Ìˇˇ" ËÁ Ô‡˚
  zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[16] //-------- ÔËÁÌ‡Í Á‡Í˚ÚËˇ ‰Îˇ ÌÂÂ
  else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[17]; //------ ËÌ‡˜Â ÔËÁÌ‡Í ÓÚÒ˛‰‡

  if ObjZav[jmp.Obj].bParam[16] or zak then //----------- ÂÒÎË ÔÓ ÒÚÂÎÍÂ Á‡Í˚ÚÓ ‰‚ËÊÂÌËÂ
  begin
    result := trBreak;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,119, ObjZav[jmp.Obj].Liter,1);  //------- —ÚÂÎÍ‡ $ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
    InsMsg(Group,jmp.Obj,119);
    MarhTracert[Group].GonkaStrel := false;
  end;

  case Con.Pin of
    1 : //-------------------------------------------------- ‚ıÓ‰ Ì‡ ÒÚÂÎÍÛ ˜ÂÂÁ ÚÓ˜ÍÛ 1
    begin
      if not ObjZav[jmp.Obj].ObjConstB[11] then
      begin //-------------------------- ÒÚÂÎÍ‡ ÌÂ Ò·‡Ò˚‚‡˛˘‡ˇ ËÎË ÓÒÚˇÍË ÌÂ ‡Á‚ÂÌÛÚ˚
        if ObjZav[jmp.Obj].ObjConstB[6] then    //------------------- ÂÒÎË ÒÚÂÎÍ‡ ‰‡Î¸Ìˇˇ
        zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34]
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33];

        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin //---------------------------- ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453);//---- —ÚÂÎÍ‡ $ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          MarhTracert[Group].GonkaStrel := false;
        end;
      end;

      if (not MarhTracert[Group].Povtor and //------------ ÌÂ ÔÓ‚ÚÓÌÓÂ Á‡‰‡ÌËÂ Ï‡¯ÛÚ‡ Ë
      (ObjZav[jmp.Obj].bParam[10] and //---------------------- ÔÂ‚˚È ÔÓıÓ‰ Ú‡ÒÒËÓ‚ÍË Ë
      not ObjZav[jmp.Obj].bParam[11])) or //------------- ÌÂ ‚ÚÓÓÈ ÔÓıÓ‰ Ú‡ÒÒËÓ‚ÍË ËÎË

      (MarhTracert[Group].Povtor and  //--------------------- ÔÓ‚ÚÓÌÓÂ Á‡‰‡ÌËÂ Ï‡¯ÛÚ‡ Ë
      (ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] and //---------------------- ÂÒÚ¸ œ” Ë
      not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7])) then//---- ÌÂÚ Ã” (ÒÚ. Ë‰ÂÚ ‚ +)
      begin
        if not NegStrelki(jmp.Obj,true,Group)
        then result := trBreak;//------------------------------------------ ÌÂ„‡·‡ËÚÌÓÒÚ¸

        if ObjZav[jmp.Obj].bParam[1] then //--------------------------------- ÂÒÎË ÂÒÚ¸ œ 
        begin
          if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] then //--------- ÂÒÎË Ì‡ Ï‡ÍÂÚÂ
          begin //------------------------------ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
            if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then //---- ÂÒÎË ÒÓÓ·˘. ÓÔÂ.
            begin //---------------------- œÓ‚ÚÓËÚ¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ ‰Îˇ ÎË‰ËÛ˛˘ÂÈ ÒÚÂÎÍË
              if ObjZav[ObjZav[jmp.Obj].BaseObject].iParam[3]=jmp.Obj then //ÓÚ Ï‡ÍÂÚ‡
              begin
                result := trBreak;
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
                InsWar(Group,jmp.Obj,120); //------------------------- —ÚÂÎÍ‡ $ Ì‡ Ï‡ÍÂÚÂ
              end;
            end else
            begin
              if not MarhTracert[Group].Dobor then
              begin
                ObjZav[ObjZav[jmp.Obj].BaseObject].iParam[3] := jmp.Obj;
                ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
              end;
              result := trBreak;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
              InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);//--------- —ÚÂÎÍ‡ $ Ì‡ Ï‡ÍÂÚÂ
            end;
          end;
        end else
        begin
          if not MarhTracert[Group].Povtor and not MarhTracert[Group].Dobor then
          inc(MarhTracert[Group].GonkaList);//-- Û‚ÂÎË˜ËÚ¸ Ò˜ÂÚ ÔÂÂ‚Ó‰ËÏ˚ı ÒÚÂÎÓÍ Ú‡ÒÒ˚
          if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] then
          begin //--------------------------------------= ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚‡Ê‰Â·ÌÓÒÚ¸
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,136, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);

            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,136);
            //—ÚÂÎÍ‡ $ Ì‡ Ï‡ÍÂÚÂ. œÂÂ‰ ÛÒÚ‡ÌÓ‚ÍÓÈ Ï‡¯ÛÚ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ÔÂÂ‚Â‰ÂÌ‡ ‚ ÔÎ˛Ò

            MarhTracert[Group].GonkaStrel := false;
          end;

          if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[21] then //----Á‡Ï˚Í‡ÌËÂ ÒÂÍˆËË
          begin
            o := GetStateSP(1,jmp.Obj);
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,82, ObjZav[o].Liter,1);
            InsMsg(Group,o,82); //-------------------------------------  ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
            MarhTracert[Group].GonkaStrel := false;
          end;

          if ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstB[3] and//ÂÒÎË Ì‡‰Ó ÔÓ‚ÂˇÚ¸ Ã—œ Ë
          not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[20] then //..... Ë‰ÂÚ ‚˚‰ÂÊÍ‡ Ã—œ
          begin
            InsArcNewMsg(ObjZav[ID_Obj].BaseObject,392+$4000,1);
            ShowShortMsg(392,LastX,LastY,ObjZav[ObjZav[ID_Obj].BaseObject].Liter);
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,392, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,392);// »‰ÂÚ ‚˚‰ÂÊÍ‡ ‚ÂÏÂÌË ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËˇ ÒÚÂÎÍË
            MarhTracert[Group].GonkaStrel := false;
          end;



          if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[4] then //------ Á‡Ï˚Í‡ÌËÂ ‚ ı‚ÓÒÚÂ
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,80, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,80); //------------ —ÚÂÎÍ‡ $ Á‡ÏÍÌÛÚ‡
            MarhTracert[Group].GonkaStrel := false;
          end;

          if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[22] then //------ Á‡ÌˇÚËÂ ËÁ —œ
          begin
            o := GetStateSP(2,jmp.Obj);
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[o].Liter,1);
            InsMsg(Group,o,83); //---------------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
            MarhTracert[Group].GonkaStrel := false;
          end;

          if ObjZav[jmp.Obj].bParam[18] then
          begin //---------------------------------------- ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,121, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);

            //-------------------- —ÚÂÎÍ‡ $ ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ (‚ Ï‡¯ÛÚÂ ÔÓ ÔÎ˛ÒÛ)
            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,121);

            MarhTracert[Group].GonkaStrel := false;
          end;

          if MarhTracert[Group].Povtor then
          begin //---------------------------------- ÔÓ‚ÂÍ‡ ÔÓ‚ÚÓÌÓÈ ÛÒÚ‡ÌÓ‚ÍË Ï‡¯ÛÚ‡
            if not ObjZav[jmp.Obj].bParam[2] then //------------------------------- ÌÂÚ Ã 
            begin
              result := trBreak;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
              InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81); //------ —ÚÂÎÍ‡ $ ·ÂÁ ÍÓÌÚÓÎˇ
              MarhTracert[Group].GonkaStrel := false;
            end;
          end else
          begin //-------------------------------- ÔÓ‚ÂÍ‡ ÔÂ‚Ë˜ÌÓÈ Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡
            if not ObjZav[jmp.Obj].bParam[2] and  //----------------------------- ÌÂÚ Ã  Ë
            not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] then  //-------------- ÌÂÚ œ”
            begin
              result := trBreak;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
              InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81); //------ —ÚÂÎÍ‡ $ ·ÂÁ ÍÓÌÚÓÎˇ
              MarhTracert[Group].GonkaStrel := false;
            end;
          end;
        end;

        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] then
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,80, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,80);
          MarhTracert[Group].GonkaStrel := false;
        end
        else  con := ObjZav[jmp.Obj].Neighbour[2];

        if result = trBreak then exit;

        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
        exit;
      end else //-------------------------------------------------- ÒÚÂÎÍ‡ ÌÂ Ë‰ÂÚ ‚ ÔÎ˛Ò
      if (not MarhTracert[Group].Povtor and //------------------- ÌÂ ÔÓ‚ÚÓ Ï‡¯ÛÚ‡ Ë ...
      (ObjZav[jmp.Obj].bParam[10] and //------------------------------ ÔÂ‚˚È ÔÓıÓ‰ Ë ...
      ObjZav[jmp.Obj].bParam[11])) or //---------------------------- ‚ÚÓÓÈ ÔÓıÓ‰ ËÎË ...
      (MarhTracert[Group].Povtor and  //------------------------------------- ÔÓ‚ÚÓ Ë ...
      (not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] and  //-------------- ÌÂÚ œ” Ë ...
      ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7])) then //---------------------- ÂÒÚ¸ Ã”
      begin
        if  not NegStrelki(jmp.Obj,false,Group) then result := trBreak; //------ ÌÂ„‡·‡ËÚ

        if ObjZav[jmp.Obj].bParam[2] then //-------------------------------------- ÂÒÎË Ã 
        begin
          if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] then //----- ÂÒÚ¸ ÒÚ.Ì‡ Ï‡ÍÂÚÂ
          begin //------------------------------ ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
            if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then  //-------- ÒÓÓ·˘ËÚ¸ ƒ—œ
            begin //---------------------- œÓ‚ÚÓËÚ¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ ‰Îˇ ÎË‰ËÛ˛˘ÂÈ ÒÚÂÎÍË
              if ObjZav[ObjZav[jmp.Obj].BaseObject].iParam[3] = jmp.Obj then //--- ˝Ú‡ ÒÚ
              begin
                result := trBreak;
                inc(MarhTracert[Group].WarCount);
                MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
                GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
                InsWar(Group,ObjZav[jmp.Obj].BaseObject,120); //------ —ÚÂÎÍ‡ $ Ì‡ Ï‡ÍÂÚÂ
              end;
            end else //---------------------------------------------- ÌÂ Ì‡‰Ó ÒÓÓ·˘‡Ú¸ ƒ—œ
            begin
              if not MarhTracert[Group].Dobor then  //------------------- ÌÂ ÌÛÊÂÌ "‰Ó·Ó"
              begin
                ObjZav[ObjZav[jmp.Obj].BaseObject].iParam[3] := jmp.Obj; //----- Á‡ÔÓÏÌËÚ¸
                ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true; //-----  ÂÒÚ¸ Ï‡ÍÂÚ
              end;
              result := trBreak;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
              InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
            end;
          end;
        end else //---------------------------------------------------------------- ÌÂÚ Ã 
        begin
          if not MarhTracert[Group].Povtor and //--------------- ÌÂ ÔÓ‚ÚÓ Ï‡¯ÛÚ‡ Ë ...
          not MarhTracert[Group].Dobor //-------------------------------------- ÌÂ "‰Ó·Ó"
          then inc(MarhTracert[Group].GonkaList);//--- Û‚ÂÎË˜ËÚ¸ ˜ËÒÎÓ ÔÂÂ‚Ó‰ËÏ˚ı ÒÚÂÎÓÍ

          if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] then
          begin //--------------------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚‡Ê‰Â·ÌÓÒÚ¸
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,137, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);

            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,137);
            //—ÚÂÎÍ‡ $ Ì‡ Ï‡ÍÂÚÂ.œÂÂ‰ ÛÒÚ‡ÌÓ‚ÍÓÈ Ï‡¯ÛÚ‡ ‰ÓÎÊÌ‡ ·˚Ú¸ ÔÂÂ‚Â‰ÂÌ‡ ‚ ÏËÌÛÒ

            MarhTracert[Group].GonkaStrel := false;
          end;

          if ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstB[3] and//ÂÒÎË Ì‡‰Ó ÔÓ‚ÂˇÚ¸ Ã—œ Ë
          not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[20] then //..... Ë‰ÂÚ ‚˚‰ÂÊÍ‡ Ã—œ
          begin
            InsArcNewMsg(ObjZav[ID_Obj].BaseObject,392+$4000,1);
            ShowShortMsg(392,LastX,LastY,ObjZav[ObjZav[ID_Obj].BaseObject].Liter);
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,392, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,392);// »‰ÂÚ ‚˚‰ÂÊÍ‡ ‚ÂÏÂÌË ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËˇ ÒÚÂÎÍË
            MarhTracert[Group].GonkaStrel := false;
          end;

          if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[21] then //---- Á‡Ï˚Í‡ÌËÂ ËÁ —œ
          begin
            o := GetStateSP(1,jmp.Obj);
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,82, ObjZav[o].Liter,1); InsMsg(Group,o,82);//--- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
            MarhTracert[Group].GonkaStrel := false;
          end else
          if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[4] or ObjZav[jmp.Obj].bParam[4] then
          begin //---------------------------------------------------- ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËÂ
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,80, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,80); //------------ —ÚÂÎÍ‡ $ Á‡ÏÍÌÛÚ‡
            MarhTracert[Group].GonkaStrel := false;
          end else
          if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[22] then //------- Á‡ÌˇÚÓÒÚ¸ —œ
          begin
            o := GetStateSP(2,jmp.Obj);
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[o].Liter,1);
            InsMsg(Group,o,83); //---------------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
            MarhTracert[Group].GonkaStrel := false;
          end else
          if ObjZav[jmp.Obj].bParam[18] then
          begin //---------------------------------------- ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,159, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);

            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,159);
            //------------------- —ÚÂÎÍ‡ $ ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ (‚ Ï‡¯ÛÚÂ ÔÓ ÏËÌÛÒÛ)

            MarhTracert[Group].GonkaStrel := false;
          end;

          if MarhTracert[Group].Povtor then
          begin //---------------------------------- ÔÓ‚ÂÍ‡ ÔÓ‚ÚÓÌÓÈ ÛÒÚ‡ÌÓ‚ÍË Ï‡¯ÛÚ‡
            if not ObjZav[jmp.Obj].bParam[1] then //------------------------------- ÌÂÚ œ 
            begin
              result := trBreak;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
              InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81); //------ —ÚÂÎÍ‡ $ ·ÂÁ ÍÓÌÚÓÎˇ
              MarhTracert[Group].GonkaStrel := false;
            end;
          end else
          begin //-------------------------------- ÔÓ‚ÂÍ‡ ÔÂ‚Ë˜ÌÓÈ Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡
            if not ObjZav[jmp.Obj].bParam[1] and  //------------------------------- ÌÂÚ œ 
            not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] then
            begin
              result := trBreak;
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
              InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81);
              MarhTracert[Group].GonkaStrel := false;
            end;
          end;
        end;

        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] then //------------------- ÂÒÚ¸ œ”
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,80, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,80);  //------------- —ÚÂÎÍ‡ $ Á‡ÏÍÌÛÚ‡
          MarhTracert[Group].GonkaStrel := false;
        end;

        con := ObjZav[jmp.Obj].Neighbour[3]; //------------ ‚˚ıÓ‰ ËÁ ÒÚÂÎÍË ÔÓ ÓÚÍÎÓÌÂÌË˛
        if result = trBreak then exit;

        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else  result := trNextStep;
        end;
        exit;
      end
      else result := trStop;
    end;

    2 : //------------------------------------------------ ‚ıÓ‰ ˜ÂÂÁ ÔˇÏÛ˛ ‚ÂÚÍÛ ÒÚÂÎÍË
    begin
      if  not NegStrelki(jmp.Obj,true,Group) then result := trBreak; //--------- ÌÂ„‡·‡ËÚ

      if ObjZav[jmp.Obj].bParam[1] then //----------------------------------- ÂÒÎË ÂÒÚ¸ œ 
      begin
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] then
        begin //-------------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
          begin //------------------------ œÓ‚ÚÓËÚ¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ ‰Îˇ ÎË‰ËÛ˛˘ÂÈ ÒÚÂÎÍË
            if ObjZav[ObjZav[jmp.Obj].BaseObject].iParam[3] = jmp.Obj then
            begin
              result := trBreak;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
              InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
            end;
          end else
          begin
            if not MarhTracert[Group].Dobor then
            begin
              ObjZav[ObjZav[jmp.Obj].BaseObject].iParam[3] := jmp.Obj;
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
            end;
            result := trBreak;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
            InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
          end;
        end;
      end else
      begin
        if not MarhTracert[Group].Povtor and not MarhTracert[Group].Dobor
        then inc(MarhTracert[Group].GonkaList); //---- Û‚ÂÎË˜ËÚ¸ ˜ËÒÎÓ ÔÂÂ‚Ó‰ËÏ˚ı ÒÚÂÎÓÍ

        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] then
        begin //----------------------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚‡Ê‰Â·ÌÓÒÚ¸
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,136, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,136);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[21] then  //----- Á‡Ï˚Í‡ÌËÂ ËÁ —œ
        begin
          o := GetStateSP(1,jmp.Obj);
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,82, ObjZav[o].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,82);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstB[3] and//ÂÒÎË Ì‡‰Ó ÔÓ‚ÂˇÚ¸ Ã—œ Ë
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[20] then //..... Ë‰ÂÚ ‚˚‰ÂÊÍ‡ Ã—œ
        begin
          InsArcNewMsg(ObjZav[ID_Obj].BaseObject,392+$4000,1);
          ShowShortMsg(392,LastX,LastY,ObjZav[ObjZav[ID_Obj].BaseObject].Liter);
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,392, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,392);//-- »‰ÂÚ ‚˚‰ÂÊÍ‡ ‚ÂÏÂÌË ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËˇ ÒÚÂÎÍË
          MarhTracert[Group].GonkaStrel := false;
        end;

        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[4] then  //----------- ‰ÓÔ. Á‡Ï˚Í‡ÌËÂ
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,80, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,80);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[22] then  //-------- Á‡ÌˇÚÓÒÚ¸ —œ
        begin
          o := GetStateSP(2,jmp.Obj);
          result := trBreak; inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,83, ObjZav[o].Liter,1); InsMsg(Group,o,83);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if ObjZav[jmp.Obj].bParam[18] then
        begin //------------------------------------------ ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,121, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,121);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if MarhTracert[Group].Povtor then
        begin //------------------------------------ ÔÓ‚ÂÍ‡ ÔÓ‚ÚÓÌÓÈ ÛÒÚ‡ÌÓ‚ÍË Ï‡¯ÛÚ‡
          if not ObjZav[jmp.Obj].bParam[2] then //--------------------------------- ÌÂÚ Ã 
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81);
            MarhTracert[Group].GonkaStrel := false;
          end;
        end else
        begin //---------------------------------- ÔÓ‚ÂÍ‡ ÔÂ‚Ë˜ÌÓÈ Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡
          if not ObjZav[jmp.Obj].bParam[2] and
          not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] then
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81);
            MarhTracert[Group].GonkaStrel := false;
          end;
        end;
      end;

      if (not MarhTracert[Group].Povtor and //---------------------------- ÌÂ ÔÓ‚ÚÓ Ë ...
      ObjZav[jmp.Obj].bParam[12]) or //----------------- ‡ÍÚË‚ËÁËÓ‚‡Ì ‡‚ÚÓ‚ÓÁ‚‡Ú ËÎË ...

      (MarhTracert[Group].Povtor and //-------------------------------------- ÔÓ‚ÚÓ Ë ...
      ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] and  //----------------------- œ” Ë ...
      not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7]) then  //------------------ ÌÂÚ Ã”
      begin
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] then //-------------------- ÌÂÚ Ã”
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,80, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,80); //-------------- —ÚÂÎÍ‡ $ Á‡ÏÍÌÛÚ‡
          MarhTracert[Group].GonkaStrel := false;
        end else
        if not ObjZav[jmp.Obj].bParam[1] and //------------------------- ÂÒÎË ÌÂÚ œ  Ë ...
        not ObjZav[jmp.Obj].bParam[2] and //--------------------------------- ÌÂÚ Ã  Ë ...
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] then //---------------- ÌÂÚ œ”...
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81);//----------- —ÚÂÎÍ‡ $ ·ÂÁ ÍÓÌÚÓÎˇ
          MarhTracert[Group].GonkaStrel := false;
        end;

        con := ObjZav[jmp.Obj].Neighbour[1]; //---------------- ‚˚ıÓ‰ ˜ÂÂÁ ‚ıÓ‰ (ÚÓ˜ÍÛ 1)

        if result = trBreak then exit;

        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else  result := trNextStep;
        end;
      end
      else result := trStop;
    end;

    3 : //----------------------------------------------- ‚ıÓ‰ Ì‡ ÒÚÂÎÍÛ ˜ÂÂÁ ÓÚÍÎÓÌÂÌËÂ
    begin
      if ObjZav[jmp.Obj].ObjConstB[11] then//----ÒÚÂÎÍ‡ Ò·‡Ò˚‚‡˛˘‡ˇ Ë ÓÒÚˇÍË ‡Á‚ÂÌÛÚ˚
      begin
        if ObjZav[jmp.Obj].ObjConstB[6] //-------------------------------- ÒÚÂÎÍ‡ ‰‡Î¸Ìˇˇ
        //----------------------- ÚÓ„‰‡ ‚ÁˇÚ¸ Á‡Í˚ÚËÂ ËÁ FR4 ·ÎËÊÌÂÈ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó
        then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33]
        //----------------------- ËÌ‡˜Â ‚ÁˇÚ¸ Á‡Í˚ÚËÂ ËÁ FR4 ‰‡Î¸ÌÂÈ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34];

        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin //---------------------------- ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453);//------- —ÚÂÎÍ‡ $ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊ.
          MarhTracert[Group].GonkaStrel := false;
        end;
      end;

      if  not NegStrelki(jmp.Obj,false,Group)
      then result := trBreak; //------------------------------------------- ÌÂ„‡·‡ËÚÌÓÒÚ¸

      if ObjZav[jmp.Obj].bParam[2] then //----------------------------------- ÂÒÎË ÂÒÚ¸ Ã 
      begin
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] then
        begin //-------------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
          begin //------------------------ œÓ‚ÚÓËÚ¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ ‰Îˇ ÎË‰ËÛ˛˘ÂÈ ÒÚÂÎÍË
            if ObjZav[ObjZav[jmp.Obj].BaseObject].iParam[3] = jmp.Obj then
            begin
              result := trBreak;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
              InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
            end;
          end else
          begin
            if not MarhTracert[Group].Dobor then
            begin
              ObjZav[ObjZav[jmp.Obj].BaseObject].iParam[3] := jmp.Obj;
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
            end;
            result := trBreak;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
            InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);//----------- —ÚÂÎÍ‡ $ Ì‡ Ï‡ÍÂÚÂ
          end;
        end;
      end else //------------------------------------------------------------- ÂÒÎË ÌÂÚ Ã 
      begin
        if not MarhTracert[Group].Povtor and not MarhTracert[Group].Dobor
        then inc(MarhTracert[Group].GonkaList);//------Û‚ÂÎË˜ËÚ¸ ˜ËÒÎÓ ÔÂÂ‚Ó‰ËÏ˚ı ÒÚÂÎÓÍ

        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] then
        begin //----------------------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚‡Ê‰Â·ÌÓÒÚ¸
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,137, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,137);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[21] then //--------- Á‡Ï˚Í‡ÌËÂ —œ
        begin
          o := GetStateSP(1,jmp.Obj);
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,82, ObjZav[o].Liter,1);
          InsMsg(Group,o,82);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstB[3] and//ÂÒÎË Ì‡‰Ó ÔÓ‚ÂˇÚ¸ Ã—œ Ë
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[20] then //..... Ë‰ÂÚ ‚˚‰ÂÊÍ‡ Ã—œ
        begin
          InsArcNewMsg(ObjZav[ID_Obj].BaseObject,392+$4000,1);
          ShowShortMsg(392,LastX,LastY,ObjZav[ObjZav[ID_Obj].BaseObject].Liter);
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,392, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,392); //- »‰ÂÚ ‚˚‰ÂÊÍ‡ ‚ÂÏÂÌË ‰ÓÔÓÎÌËÚ. Á‡Ï˚Í‡ÌËˇ ÒÚÂÎÍË
          MarhTracert[Group].GonkaStrel := false;
        end;

        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[4] or  ObjZav[jmp.Obj].bParam[4] then
        begin  //---------------------------------------------------------- ‰ÓÔ. Á‡Ï˚Í‡ÌËÂ
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,80, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,80);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[22] then //--------- Á‡ÌˇÚÓÒÚ¸ —œ
        begin
          o := GetStateSP(2,jmp.Obj);
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,83, ObjZav[o].Liter,1);
          InsMsg(Group,o,83);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if ObjZav[jmp.Obj].bParam[18] then //------------- ÒÚÂÎÍ‡ ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,159, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,159);
          MarhTracert[Group].GonkaStrel := false;
        end;

        if MarhTracert[Group].Povtor then //-------- ÔÓ‚ÂÍ‡ ÔÓ‚ÚÓÌÓÈ ÛÒÚ‡ÌÓ‚ÍË Ï‡¯ÛÚ‡
        begin
          if not ObjZav[jmp.Obj].bParam[1] then
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81);
            MarhTracert[Group].GonkaStrel := false;
          end;
        end else
        begin //---------------------------------- ÔÓ‚ÂÍ‡ ÔÂ‚Ë˜ÌÓÈ Ú‡ÒÒËÓ‚ÍË Ï‡¯ÛÚ‡
          if not ObjZav[jmp.Obj].bParam[1] and //---------------------------- ÌÂÚ œ  Ë ...
          not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] then //----------------- ÌÂÚ Ã”
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81); //-------- —ÚÂÎÍ‡ $ ·ÂÁ ÍÓÌÚÓÎˇ
            MarhTracert[Group].GonkaStrel := false;
          end;
        end;
      end;

      if (not MarhTracert[Group].Povtor and //------------------- ÌÂ ÔÓ‚ÚÓ Ï‡¯ÛÚ‡ Ë ...
      ObjZav[jmp.Obj].bParam[13]) or //------------ ÔÓ¯ÂÒÚÌ‡ˇ ‚ Ï‡¯ÛÚÂ ‚ ÏËÌÛÒÂ ËÎË ...

      (MarhTracert[Group].Povtor and //----------------------------- ÔÓ‚ÚÓ Ï‡¯ÛÚ‡ Ë ...
      not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] and //------- ÌÂÚ œ” ‚ ı‚ÓÒÚÂ Ë ...
      ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7]) then  //------------- ÂÒÚ¸ Ã” ‚ ı‚ÓÒÚÂ
      begin
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] then //---------- ÂÒÎË ‚ ı‚ÓÒÚÂ œ”
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,80, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,80);
          MarhTracert[Group].GonkaStrel := false;
        end else  //------------------------------------------------- ÂÒÎË ‚ ı‚ÓÒÚÂ ÌÂÚ œ”
        if not ObjZav[jmp.Obj].bParam[1] and  //----------------------------- ÌÂÚ œ  Ë ...
        not ObjZav[jmp.Obj].bParam[2] and  //-------------------------------- ÌÂÚ Ã  Ë ...
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] then //---------- ÌÂÚ œ” ‚ ı‚ÓÒÚÂ
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81); //------------ ÒÚÂÎÍ‡ ·ÂÁ ÍÓÌÚÓÎˇ
          MarhTracert[Group].GonkaStrel := false;
        end;

        con := ObjZav[jmp.Obj].Neighbour[1]; //------------ ‚˚ıÓ‰ËÏ ËÁ ÒÚÂÎÍË ˜ÂÂÁ Ú˜Í 1

        if result = trBreak then exit;

        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else  result := trNextStep;
        end;
      end
      else result := trStop;
    end;
  end;
end;
//========================================================================================
function StepStrelZamykTrassa(var Con : TOZNeighbour; const Lvl :TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//--------------------------------ÔÓÈÚË ˜ÂÂÁ ÒÚÂÎÍÛ ‚Ó ‚ÂÏˇ Á‡Ï˚Í‡ÌËˇ ˝ÎÂÏÂÌÚÓ‚ Ú‡ÒÒ˚
var
  p,mk : boolean;
begin
  result := trNextStep;
  case Con.Pin of
    1 :
    begin
      p := false; mk := false;
      if ObjZav[ObjZav[jmp.Obj].UpdateObject].bParam[2] and
      not ObjZav[ObjZav[jmp.Obj].UpdateObject].bParam[9] then
      begin //--------------------------------------------------------- ÌÂÚ Á‡Ï˚Í‡ÌËˇ Ë –Ã
        if ObjZav[jmp.Obj].bParam[10] then
        begin
          if ObjZav[jmp.Obj].bParam[11] then
          begin //-------------------------------------------------- Ú‡ÒÒËÓ‚Í‡ ÔÓ ÏËÌÛÒÛ
            mk := true;
            p := false;
          end else
          begin //--------------------------------------------------- Ú‡ÒÒËÓ‚Í‡ ÔÓ ÔÎ˛ÒÛ
            p := true;
            mk := false;
          end;
        end;
      end else //--------------------------------------------------- ÂÒÚ¸ Á‡Ï˚Í‡ÌËÂ ËÎË –Ã
      begin
        if ObjZav[jmp.Obj].bParam[1] and not ObjZav[jmp.Obj].bParam[2] then
        begin //--------------------------------------------------- ÂÒÚ¸ ÍÓÌÚÓÎ¸ ÔÓ ÔÎ˛ÒÛ
          p := true;
          mk := false;
        end else
        if not ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[2] then
        begin //-------------------------------------------------- ÂÒÚ¸ ÍÓÌÚÓÎ¸ ÔÓ ÏËÌÛÒÛ
          mk := true;
          p := false;
        end;
      end;

      if p and //--------------------------------------------------------- ÂÒÎË ÔÎ˛Ò Ë ...
      not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] then //--------------------- ÌÂÚ Ã”
      begin
        con := ObjZav[jmp.Obj].Neighbour[2]; //------------------ ‚˚ıÓ‰ËÏ ËÁ ÒÚÂÎÍË ÔˇÏÓ

        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;

        if result = trNextStep then
        begin
          if not ObjZav[jmp.Obj].ObjConstB[1] then //--------------------- ÌÂ Ò·‡Ò˚‚‡˛˘‡ˇ
          begin
            inc(MarhTracert[Group].StrCount);
            MarhTracert[Group].StrTrace[MarhTracert[Group].StrCount] := jmp.Obj;
            MarhTracert[Group].PolTrace[MarhTracert[Group].StrCount,1] := true;
            MarhTracert[Group].PolTrace[MarhTracert[Group].StrCount,2] := false;
          end;
          ObjZav[jmp.Obj].bParam[6] := true;   //-------------------------------------- œ”
          ObjZav[jmp.Obj].bParam[7] := false;  //-------------------------------------- Ã”
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := true;   //------------------- œ”
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := false;  //------------------- Ã”
          ObjZav[jmp.Obj].bParam[10] := false; //---------------- ÌÂ 1-˚È ÔÓıÓ‰ ÔÓ Ú‡ÒÒÂ
          ObjZav[jmp.Obj].bParam[11] := false; //---------------- ÌÂ 2-ÓÈ ÔÓıÓ‰ ÔÓ Ú‡ÒÒÂ
          ObjZav[jmp.Obj].bParam[12] := false; //--------- ÔÓ¯ÂÒÚ‡ˇ ÌÂ ‚ ÔÎ˛ÒÂ ÔÓ  Ú‡ÒÒÂ
          ObjZav[jmp.Obj].bParam[13] := false; //-------- ÔÓ¯ÂÒÚÌ‡ˇ ÌÂ ‚ ÏËÌÛÒÂ ÔÓ Ú‡ÒÒÂ
          ObjZav[jmp.Obj].bParam[14] := true;  //------------------------- ÔÓ„. Á‡Ï˚Í‡ÌËÂ

          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[14] := true;//-------- ÔÓ„. Á‡Ï˚Í‡ÌËÂ
          ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart;//-------- ÔÓÏÌË ËÌ‰ÂÍÒ
        end;
        exit;
      end else
      if mk and not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] then
      begin
        con := ObjZav[jmp.Obj].Neighbour[3];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;

        if result = trNextStep then
        begin
          if not ObjZav[jmp.Obj].ObjConstB[1] then
          begin
            inc(MarhTracert[Group].StrCount);
            MarhTracert[Group].StrTrace[MarhTracert[Group].StrCount] := jmp.Obj;
            MarhTracert[Group].PolTrace[MarhTracert[Group].StrCount,1] := false;
            MarhTracert[Group].PolTrace[MarhTracert[Group].StrCount,2] := true;
          end;
          ObjZav[jmp.Obj].bParam[6] := false;  //-------------------------------------- œ”
          ObjZav[jmp.Obj].bParam[7] := true;   //-------------------------------------- Ã”
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := false; //-------------------- œ”
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := true;  //-------------------- Ã”

          ObjZav[jmp.Obj].bParam[10] := false; //-------------- ÌÂ ÔÂ‚˚È ÔÓıÓ‰ ÔÓ Ú‡ÒÒÂ
          ObjZav[jmp.Obj].bParam[11] := false; //-------------- ÌÂ ‚ÚÓÓÈ ÔÓıÓ‰ ÔÓ Ú‡ÒÒÂ
          ObjZav[jmp.Obj].bParam[12] := false; //----------- Ò·ÓÒ ‡ÍÚË‚ÌÓÒÚË ‡‚ÚÓ‚ÓÁ‚‡Ú‡
          ObjZav[jmp.Obj].bParam[13] := false; //--------------- Ò·ÓÒ ÔÓ¯ÂÒÚÌÓÈ ‚ ÏËÌÛÒÂ
          ObjZav[jmp.Obj].bParam[14] := true;  //------------------ ‚˚‰‡Ú¸ ÔÓ„. Á‡Ï˚Í‡ÌËÂ
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[14] := true;  //------ ÔÓ„. Á‡Ï˚Í‡ÌËÂ
          ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart; //------ÔÓÏÌËÚ¸ Ì‡˜‡ÎÓ
        end;
        exit;
      end
      else result := trStop;
    end;

    2 :   //------------------------------------------------------ ‚ıÓ‰ ˜ÂÂÁ ÔˇÏÛ˛ ‚ÂÚÍÛ
    begin
      if ObjZav[ObjZav[jmp.Obj].UpdateObject].bParam[2] and  //------- —œ ÌÂ Á‡ÏÍÌÛÚ Ë ...
      not ObjZav[ObjZav[jmp.Obj].UpdateObject].bParam[9] then  //------------------ ÌÂÚ –Ã
      begin
        if ObjZav[jmp.Obj].bParam[12] //-------------- ÌÂÚ ÔÓ¯ÂÒÚÌÓÈ Ú‡ÒÒËÓ‚ÍË ÔÓ ÔÎ˛ÒÛ
        then result := trNextStep; //----------------------------------------- Ë‰ÚË ‰‡Î¸¯Â
      end
      else //------------------------------------------------------- ÂÒÚ¸ Á‡Ï˚Í‡ÌËÂ ËÎË –Ã
      if ObjZav[jmp.Obj].bParam[1] and //----------------------------------- ÂÒÚ¸ œ  Ë ...
      not ObjZav[jmp.Obj].bParam[2] //--------------------------------------------- ÌÂÚ Ã 
      then result := trNextStep;  //------------------------------------------ Ë‰ÚË ‰‡Î¸¯Â

      if result = trNextStep then //------------------------------------- ÂÒÎË Ë‰ÚË ‰‡Î¸¯Â
      begin
        con := ObjZav[jmp.Obj].Neighbour[1]; //---------------- ‚˚ıÓ‰ ˜ÂÂÁ ‚ıÓ‰ (ÚÓ˜Í‡ 1)
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else
            ObjZav[jmp.Obj].bParam[6] := true;   //------------------------------ ÌÛÊÂÌ œ”
            ObjZav[jmp.Obj].bParam[7] := false;  //--------------------------- ÌÂ ÌÛÊÂÌ Ã”
            ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := true;  //------------------ œ”
            ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := false; //------------------ Ã”
            ObjZav[jmp.Obj].bParam[10] := false; //------------ ÌÂ ÔÂ‚˚È ÔÓıÓ‰ ÔÓ Ú‡ÒÒÂ
            ObjZav[jmp.Obj].bParam[11] := false; //------------ ÌÂ ‚ÚÓÓÈ ÔÓıÓ‰ ÔÓ Ú‡ÒÒÂ
            ObjZav[jmp.Obj].bParam[12] := false; //------- ÌÂÚ ÔÓ¯ÂÒÚÌÓÈ ‚ ÔÎ˛ÒÂ ‚ Ú‡ÒÒÂ
            ObjZav[jmp.Obj].bParam[13] := false; //------ ÌÂÚ ÔÓ¯ÂÒÚÌÓÈ ‚ ÏËÌÛÒÂ ‚ Ú‡ÒÒÂ
            ObjZav[jmp.Obj].bParam[14] := true;  //----------------------- ÔÓ„. Á‡Ï˚Í‡ÌËÂ
            ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[14] := true; //----- ÔÓ„. Á‡Ï˚Í‡ÌËÂ
            ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart; //--- ÔÓÏÌËÚ¸ Ì‡˜‡ÎÓ
        end;
      end;
    end;

    3 : //----------------------------------------------------- ‚ıÓ‰ ÒÓ ÒÚÓÓÌ˚ ÓÚÍÎÓÌÂÌËˇ
    begin
      if ObjZav[ObjZav[jmp.Obj].UpdateObject].bParam[2] and //------ÌÂÚ Á‡Ï˚Í‡ÌËˇ —œ Ë ...
      not ObjZav[ObjZav[jmp.Obj].UpdateObject].bParam[9] then //------------------- ÌÂÚ –Ã
      begin
        if ObjZav[jmp.Obj].bParam[13] then  //------------------ ÔÓ¯ÂÒÚÌ‡ˇ ÌÛÊÌ‡ ‚ ÏËÌÛÒÂ
        result := trNextStep; //---------------------------------------------- Ë‰ÚË ‰‡Î¸¯Â
      end
      else //------------------------------------------------------- ÂÒÚ¸ Á‡Ï˚Í‡ÌËÂ ËÎË –Ã
      if not ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[2] then//ÌÂÚ œ , ÂÒÚ¸ Ã 
      result := trNextStep;  //--------------------------- ÒÚÂÎÍ‡ ÔÓ ÏËÌÛÒÛ - Ë‰ÚË ‰‡Î¸¯Â

      if result = trNextStep then
      begin
        con := ObjZav[jmp.Obj].Neighbour[1]; //---------------- ‚˚ıÓ‰ ˜ÂÂÁ ‚ıÓ‰ (ÚÓ˜Í‡ 1)
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else
            ObjZav[jmp.Obj].bParam[6] := false; //---------------------------- ÌÂ ÌÛÊÂÌ œ”
            ObjZav[jmp.Obj].bParam[7] := true;  //------------------------------- Ã” ÌÛÊÂÌ
            ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := false; //------------------ œ”
            ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := true;  //------------------ Ã”
            ObjZav[jmp.Obj].bParam[10] := false; //------------ ÌÂ ÔÂ‚˚È ÔÓıÓ‰ ÔÓ Ú‡ÒÒÂ
            ObjZav[jmp.Obj].bParam[11] := false; //------------ ÌÂ ‚ÚÓÓÈ ÔÓıÓ‰ ÔÓ Ú‡ÒÒÂ
            ObjZav[jmp.Obj].bParam[12] := false; //------- ÌÂÚ ÔÓ¯ÂÒÚÌÓÈ ‚ ÔÎ˛ÒÂ ‚ Ú‡ÒÒÂ
            ObjZav[jmp.Obj].bParam[13] := false; //------ ÌÂÚ ÔÓ¯ÂÒÚÌÓÈ ‚ ÏËÌÛÒÂ ‚ Ú‡ÒÒÂ
            ObjZav[jmp.Obj].bParam[14] := true;  //----------------------- ÔÓ„. Á‡Ï˚Í‡ÌËÂ
            ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[14] := true;//------ ÔÓ„. Á‡Ï˚Í‡ÌËÂ
            ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart;
        end;
      end;
    end;
  end;
end;
//========================================================================================
function StepStrelSignalCirc(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------------- ¯‡„ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË ÔÓ‚ÂÍÂ "ÒË„Ì‡Î¸ÌÓÈ ÒÚÛÌ˚"
var
  k : integer;
  zak : boolean;
begin
  result := trNextStep;
  //------------------ œÓ‚ÂËÚ¸ Á‡Ï˚Í‡ÌËÂ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ ÒÓ ÒÚÂÎÍÓÈ ‚ ÔÛÚË
  if not SignCircOtpravlVP(jmp.Obj,Group) then result := trStop;
  //----------------------------------- œÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÛÚË ˜ÂÂÁ ¬Á ÒÚÂÎÍË

  if not SignCircOgrad(jmp.Obj,Group) then result := trStop; //--- Œ„‡Ê‰ÂÌËÂ ÔÛÚË

  if ObjZav[jmp.Obj].ObjConstB[6]
  then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[16]
  else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[17];

  if ObjZav[jmp.Obj].bParam[16] or zak then
  begin //------------------------------------------- ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,119, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,119);
  end;

  if not (ObjZav[jmp.Obj].bParam[1] xor ObjZav[jmp.Obj].bParam[2]) then
  begin //------------------------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
    result := trStop;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
    InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81);
  end else
  if not SigCircNegStrelki(jmp.Obj,ObjZav[jmp.Obj].bParam[1],Group)
  then result := trStop; //---------------------------------------- ÌÂ„‡·‡ËÚÌÓÒÚ¸

  case Con.Pin of
    1 :
    begin
      //------- ÔÓ‚ÂËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÔÓ ÏÛÌÛÒÛ ÒÚÂÎÍË ‚ ÔÛÚË ‚ ÔÓÂÁ‰ÌÓÏ Ï‡¯ÛÚÂ
      if MarhTracert[Group].VP > 0 then
      begin //----------------------------------------- ÂÒÚ¸ ÒÔËÒÓÍ ÒÚÂÎÓÍ ‚ ÔÛÚË
        for k := 1 to 4 do
        if (ObjZav[MarhTracert[Group].VP].ObjConstI[k] = jmp.Obj) and // ËÌ‰ÂÍÒ ÒÚÂÎÍË ‚ ÔÛÚË
        ObjZav[MarhTracert[Group].VP].ObjConstB[k+1] then          // ÔËÁÌ‡Í ‰Ó·Ó‡ Ú‡ÒÒ˚ ÔÓ ÔÎ˛ÒÛ
        begin // ÔÓ‚ÂËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÒÚÂÎÍË ÔÓ ÏËÌÛÒÛ
          if not ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[2] then
          begin
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,482, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,482);
          end;
        end;
      end;

      if not ObjZav[jmp.Obj].ObjConstB[11] then
      begin //-------------------- ÒÚÂÎÍ‡ ÌÂ Ò·‡Ò˚‚‡˛˘‡ˇ ËÎË ÓÒÚˇÍË ÌÂ ‡Á‚ÂÌÛÚ˚
        if ObjZav[jmp.Obj].ObjConstB[6]
        then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33]
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34];

        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin //---------------------- ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453);
        end;
      end;

      if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
      not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
      begin //-------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
        ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
      end;

      //---------------------------------------------- ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
      if ObjZav[jmp.Obj].bParam[1] then con := ObjZav[jmp.Obj].Neighbour[2]
      else //------------------------------------------ ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
      if ObjZav[jmp.Obj].bParam[2] then con := ObjZav[jmp.Obj].Neighbour[3]
      else result := trStop; //------------------------------ ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      if result <> trStop then
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,241, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,241);
          result := trStop;
        end;
      end;
    end;

    2 :
    begin
      if ObjZav[jmp.Obj].bParam[1] then
      begin //------------------------------------------ ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
        begin //-------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
        end;
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin //----------------------------------------- ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        result := trStop;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);//---- —ÚÂÎÍ‡ $ ÌÂ ÔÓ Ï‡¯ÛÚÛ
      end
      else result := trStop; //------------------------------ ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
      Con := ObjZav[jmp.Obj].Neighbour[1];

      if result <> trStop then
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,242, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,242); //ÕÂÚ Ï‡¯ÛÚÓ‚ ÔÓ + ÒÚÂÎÍË $
          result := trStop;
        end;
      end;
    end;

    3 :
    begin
      if ObjZav[jmp.Obj].ObjConstB[11] then
      begin //------------------------------ ÒÚÂÎÍ‡ Ò·‡Ò˚‚‡˛˘‡ˇ Ë ÓÒÚˇÍË ‡Á‚ÂÌÛÚ˚
        if ObjZav[jmp.Obj].ObjConstB[6]
        then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33]
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34];

        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin //------------------------ ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453); //—ÚÂÎÍ‡ $ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
        end;
      end;

      if ObjZav[jmp.Obj].bParam[1] then
      begin //-------------------------------------------- ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        result := trStop;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160); //----- —ÚÂÎÍ‡ $ ÌÂ ÔÓ Ï‡¯ÛÚÛ
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin //------------------------------------------- ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
        begin //---------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
        end;
      end
      else result := trStop; //-------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      Con := ObjZav[jmp.Obj].Neighbour[1];
      if result <> trStop then
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,243, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,243);
          result := trStop;
        end;
      end;
    end;
  end;
end;
//========================================================================================
function StepStrelOtmenaMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//---------------------------------- ÔÓıÓ‰ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË ÔÓ‚ÂÍÂ ‰Îˇ ÓÚÏÂÌ˚ Ï‡¯ÛÚ‡
var
  o : integer;
begin
  result := trNextStep;
  case Con.Pin of
    1 :
    begin
      if ObjZav[ObjZav[jmp.Obj].UpdateObject].bParam[2] and
      not ObjZav[ObjZav[jmp.Obj].UpdateObject].bParam[9] then
      begin //----------------------------------------------------- ÌÂÚ Á‡Ï˚Í‡ÌËˇ Ë –Ã
        if ObjZav[jmp.Obj].bParam[6] then
        begin
          con := ObjZav[jmp.Obj].Neighbour[2];
          case Con.TypeJmp of
            LnkRgn : result := trStop;
            LnkEnd : result := trStop;
            else  result := trNextStep;
          end;
          if result = trNextStep then
          begin
            ObjZav[jmp.Obj].bParam[6] := false; //------------------------------------- œ”
            ObjZav[jmp.Obj].bParam[7] := false; //------------------------------------- Ã”
            o := 0;

            if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] > 0)
            and (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] <> jmp.Obj) then
            o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8]
            else
            if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] > 0) and
            (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] <> jmp.Obj) then
            o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9];

            if (o > 0) then
            begin //--------------------- ÔÓÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‰Îˇ ÒÔ‡ÂÌÌÓÈ ÒÚÂÎÍË
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := ObjZav[o].bParam[6]; // œ”
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := ObjZav[o].bParam[7]; // Ã”
            end else
            begin //-------------------------------- Ò·ÓÒËÚ¸ „ÓÌÍÛ ÒÚÂÎÓÍ ‚ Ó·˙ÂÍÚÂ ’—
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := false; // œ”
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := false; // Ã”
            end;

            ObjZav[jmp.Obj].bParam[10] := false; //--------------- Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[11] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[12] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[13] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[14] := false; // ÔÓ„. Á‡Ï˚Í‡ÌËÂ
            SetPrgZamykFromXStrelka(jmp.Obj);
            ObjZav[jmp.Obj].iParam[1]  := 0;
          end;
          exit;
        end else
        if ObjZav[jmp.Obj].bParam[7] then
        begin
          con := ObjZav[jmp.Obj].Neighbour[3];
          case Con.TypeJmp of
            LnkRgn : result := trStop;
            LnkEnd : result := trStop;
            else  result := trNextStep;
          end;

          if result = trNextStep then
          begin
            ObjZav[jmp.Obj].bParam[6] := false; // œ”
            ObjZav[jmp.Obj].bParam[7] := false; // Ã”
            o := 0;

            if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] > 0) and
            (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] <> jmp.Obj)
            then  o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8]
            else
            if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] > 0) and
            (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] <> jmp.Obj)
            then o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9];

            if (o > 0) then
            begin // ÔÓÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‰Îˇ ÒÔ‡ÂÌÌÓÈ ÒÚÂÎÍË
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := ObjZav[o].bParam[6]; // œ”
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := ObjZav[o].bParam[7]; // Ã”
            end else
            begin // Ò·ÓÒËÚ¸ „ÓÌÍÛ ÒÚÂÎÓÍ ‚ Ó·˙ÂÍÚÂ ’—
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := false; // œ”
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := false; // Ã”
            end;
            ObjZav[jmp.Obj].bParam[10] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[11] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[12] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[13] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[14] := false; // ÔÓ„. Á‡Ï˚Í‡ÌËÂ
            SetPrgZamykFromXStrelka(jmp.Obj);
            ObjZav[jmp.Obj].iParam[1]  := 0;
          end;
          exit;
        end
        else result := trStop;
      end else
      begin // ≈ÒÚ¸ Á‡Ï˚Í‡ÌËÂ ËÎË –Ã - ÔÓÈÚË ÔÓ ËÏÂ˛˘ÂÏÛÒˇ ÔÓÎÓÊÂÌË˛ ÒÚÂÎÍË
        if ObjZav[jmp.Obj].bParam[1] and not ObjZav[jmp.Obj].bParam[2] then
        begin // ÔÓÈÚË ÔÓ ÔÎ˛ÒÛ ÒÚÂÎÍË
          con := ObjZav[jmp.Obj].Neighbour[2];
          case Con.TypeJmp of
            LnkRgn : result := trStop;
            LnkEnd : result := trStop;
            else result := trNextStep;
          end;

          if result = trNextStep then
          begin
            ObjZav[jmp.Obj].bParam[6] := false; // œ”
            ObjZav[jmp.Obj].bParam[7] := false; // Ã”
            o := 0;
            if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] > 0) and
            (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] <> jmp.Obj)
            then  o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8]
            else
            if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] > 0) and
            (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] <> jmp.Obj)
            then  o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9];

            if (o > 0) then
            begin // ÔÓÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‰Îˇ ÒÔ‡ÂÌÌÓÈ ÒÚÂÎÍË
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := ObjZav[o].bParam[6]; // œ”
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := ObjZav[o].bParam[7]; // Ã”
            end else
            begin // Ò·ÓÒËÚ¸ „ÓÌÍÛ ÒÚÂÎÓÍ ‚ Ó·˙ÂÍÚÂ ’—
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := false; // œ”
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := false; // Ã”
            end;
            ObjZav[jmp.Obj].bParam[10] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[11] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[12] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[13] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[14] := false; // ÔÓ„. Á‡Ï˚Í‡ÌËÂ
            SetPrgZamykFromXStrelka(jmp.Obj);
            ObjZav[jmp.Obj].iParam[1]  := 0;
          end;
          exit;
        end else
        if not ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[2] then
        begin // ÔÓÈÚË ÔÓ ÏËÌÛÒÛ ÒÚÂÎÍË
          con := ObjZav[jmp.Obj].Neighbour[3];
          case Con.TypeJmp of
            LnkRgn : result := trStop;
            LnkEnd : result := trStop;
            else  result := trNextStep;
          end;

          if result = trNextStep then
          begin
            ObjZav[jmp.Obj].bParam[6] := false; // œ”
            ObjZav[jmp.Obj].bParam[7] := false; // Ã”
            o := 0;

            if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] > 0) and
            (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] <> jmp.Obj)
            then  o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8]
            else
            if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] > 0) and
            (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] <> jmp.Obj)
            then  o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9];

            if (o > 0) then
            begin // ÔÓÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‰Îˇ ÒÔ‡ÂÌÌÓÈ ÒÚÂÎÍË
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := ObjZav[o].bParam[6]; // œ”
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := ObjZav[o].bParam[7]; // Ã”
            end else
            begin // Ò·ÓÒËÚ¸ „ÓÌÍÛ ÒÚÂÎÓÍ ‚ Ó·˙ÂÍÚÂ ’—
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := false; // œ”
              ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := false; // Ã”
            end;
            ObjZav[jmp.Obj].bParam[10] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[11] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[12] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[13] := false; // Ú‡ÒÒ‡
            ObjZav[jmp.Obj].bParam[14] := false; // ÔÓ„. Á‡Ï˚Í‡ÌËÂ
            SetPrgZamykFromXStrelka(jmp.Obj);
            ObjZav[jmp.Obj].iParam[1]  := 0;
          end;
          exit;
        end
        else result := trStop; // ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ - ‰‡Î¸¯Â ÌÂ ıÓ‰ËÚ¸
      end;
    end;

    2 :
    begin
      con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd : result := trStop;
        else result := trNextStep;
      end;

      if result = trNextStep then
      begin
        ObjZav[jmp.Obj].bParam[6] := false; // œ”
        ObjZav[jmp.Obj].bParam[7] := false; // Ã”
        o := 0;

        if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] > 0) and
        (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] <> jmp.Obj)
        then o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8]
        else
        if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] > 0) and
        (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] <> jmp.Obj)
        then  o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9];

        if (o > 0) then
        begin // ÔÓÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‰Îˇ ÒÔ‡ÂÌÌÓÈ ÒÚÂÎÍË
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := ObjZav[o].bParam[6]; // œ”
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := ObjZav[o].bParam[7]; // Ã”
        end else
        begin // Ò·ÓÒËÚ¸ „ÓÌÍÛ ÒÚÂÎÓÍ ‚ Ó·˙ÂÍÚÂ ’—
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := false; // œ”
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := false; // Ã”
        end;

        ObjZav[jmp.Obj].bParam[10] := false; // Ú‡ÒÒ‡
        ObjZav[jmp.Obj].bParam[11] := false; // Ú‡ÒÒ‡
        ObjZav[jmp.Obj].bParam[12] := false; // Ú‡ÒÒ‡
        ObjZav[jmp.Obj].bParam[13] := false; // Ú‡ÒÒ‡
        ObjZav[jmp.Obj].bParam[14] := false; // ÔÓ„. Á‡Ï˚Í‡ÌËÂ
        SetPrgZamykFromXStrelka(jmp.Obj);
        ObjZav[jmp.Obj].iParam[1]  := 0;
      end;
    end;

    3 :
    begin
      con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd : result := trStop;
        else result := trNextStep;
      end;

      if result = trNextStep then
      begin
        ObjZav[jmp.Obj].bParam[6] := false; // œ”
        ObjZav[jmp.Obj].bParam[7] := false; // Ã”
        o := 0;
        if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] > 0) and
        (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8] <> jmp.Obj)
        then  o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[8]
        else
        if (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] > 0) and
        (ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9] <> jmp.Obj)
        then o := ObjZav[ObjZav[jmp.Obj].BaseObject].ObjConstI[9];

        if (o > 0) then
        begin // ÔÓÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ „ÓÌÍË ‰Îˇ ÒÔ‡ÂÌÌÓÈ ÒÚÂÎÍË
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := ObjZav[o].bParam[6]; // œ”
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := ObjZav[o].bParam[7]; // Ã”
        end else
        begin // Ò·ÓÒËÚ¸ „ÓÌÍÛ ÒÚÂÎÓÍ ‚ Ó·˙ÂÍÚÂ ’—
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[6] := false; // œ”
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[7] := false; // Ã”
        end;

        ObjZav[jmp.Obj].bParam[10] := false; // Ú‡ÒÒ‡
        ObjZav[jmp.Obj].bParam[11] := false; // Ú‡ÒÒ‡
        ObjZav[jmp.Obj].bParam[12] := false; // Ú‡ÒÒ‡
        ObjZav[jmp.Obj].bParam[13] := false; // Ú‡ÒÒ‡
        ObjZav[jmp.Obj].bParam[14] := false; // ÔÓ„. Á‡Ï˚Í‡ÌËÂ
        SetPrgZamykFromXStrelka(jmp.Obj);
        ObjZav[jmp.Obj].iParam[1]  := 0;
      end;
    end;
  end;
end;
//========================================================================================
function StepStrelRazdelSign(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//----------------------------------- ÔÓıÓ‰ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË ‡Á‰ÂÎ¸ÌÓÏ ÓÚÍ˚ÚËË ÒË„Ì‡Î‡
var
  zak : boolean;
  k : integer;
begin
  result := trNextStep;
  // œÓ‚ÂËÚ¸ Á‡Ï˚Í‡ÌËÂ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ ÒÓ ÒÚÂÎÍÓÈ ‚ ÔÛÚË
  if not SignCircOtpravlVP(jmp.Obj,Group) then result := trStop;

  // œÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÛÚË ˜ÂÂÁ ¬Á ÒÚÂÎÍË
  if not SignCircOgrad(jmp.Obj,Group) then result := trStop; // Œ„‡Ê‰ÂÌËÂ ÔÛÚË

  if ObjZav[jmp.Obj].ObjConstB[6] then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[16]
  else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[17];

  if ObjZav[jmp.Obj].bParam[16] or zak then
  begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,119, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,119);
  end;

  if not (ObjZav[jmp.Obj].bParam[1] xor ObjZav[jmp.Obj].bParam[2]) then
  begin // ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
    result := trStop;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
    InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81);
  end else
  if not SigCircNegStrelki(jmp.Obj,ObjZav[jmp.Obj].bParam[1],Group)
  then result := trStop; // ÌÂ„‡·‡ËÚÌÓÒÚ¸

  case Con.Pin of
    1 :
    begin
      // ÔÓ‚ÂËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÔÓ ÏÛÌÛÒÛ ÒÚÂÎÍË ‚ ÔÛÚË ‚ ÔÓÂÁ‰ÌÓÏ Ï‡¯ÛÚÂ
      if MarhTracert[Group].VP > 0 then
      begin // ÂÒÚ¸ ÒÔËÒÓÍ ÒÚÂÎÓÍ ‚ ÔÛÚË
        for k := 1 to 4 do
        if (ObjZav[MarhTracert[Group].VP].ObjConstI[k] = jmp.Obj) and // ËÌ‰ÂÍÒ ÒÚÂÎÍË ‚ ÔÛÚË
        ObjZav[MarhTracert[Group].VP].ObjConstB[k+1] then          // ÔËÁÌ‡Í ‰Ó·Ó‡ Ú‡ÒÒ˚ ÔÓ ÔÎ˛ÒÛ
        begin // ÔÓ‚ÂËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÒÚÂÎÍË ÔÓ ÏËÌÛÒÛ
          if not ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[2] then
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,482, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,ObjZav[jmp.Obj].BaseObject,482);
          end;
        end;
      end;

      if not ObjZav[jmp.Obj].ObjConstB[11] then
      begin // ÒÚÂÎÍ‡ ÌÂ Ò·‡Ò˚‚‡˛˘‡ˇ ËÎË ÓÒÚˇÍË ÌÂ ‡Á‚ÂÌÛÚ˚
        if ObjZav[jmp.Obj].ObjConstB[6]
        then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33]
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34];

        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453);
        end;
      end;

      if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
      not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
      begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
        ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
      end;

      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        ObjZav[jmp.Obj].bParam[10] := true;
        ObjZav[jmp.Obj].bParam[11] := false;// +
        con := ObjZav[jmp.Obj].Neighbour[2];
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        ObjZav[jmp.Obj].bParam[10] := true;
        ObjZav[jmp.Obj].bParam[11] := true; // -
        con := ObjZav[jmp.Obj].Neighbour[3];
      end
      else  result := trStop; // ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      if result <> trStop then
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,241, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,241);
          result := trStop;
        end;
      end;
    end;

    2 :
    begin
      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
        begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
        end;
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        result := trStop;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
      end
      else  result := trStop; // ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      Con := ObjZav[jmp.Obj].Neighbour[1];
      if result <> trStop then ObjZav[jmp.Obj].bParam[12] := true; // +

      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,242, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,242);
          result := trStop;
        end;
      end;
    end;

    3 :
    begin
      if ObjZav[jmp.Obj].ObjConstB[11] then
      begin // ÒÚÂÎÍ‡ Ò·‡Ò˚‚‡˛˘‡ˇ Ë ÓÒÚˇÍË ‡Á‚ÂÌÛÚ˚
        if ObjZav[jmp.Obj].ObjConstB[6]
        then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33]
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34];

        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453);
        end;
      end;

      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        result := trStop;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
        begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
        end;
      end
      else result := trStop;// ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      Con := ObjZav[jmp.Obj].Neighbour[1];
      if result <> trStop then ObjZav[jmp.Obj].bParam[13] := true; // -
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,243, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,243);
          result := trStop;
        end;
      end;
    end;
  end;
end;
//========================================================================================
function StepStrelAutoTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------ ÔÓıÓ‰ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË ÓÚÍ˚ÚËË ÒË„Ì‡Î‡ Ì‡ ‡‚ÚÓ‰ÂÈÒÚ‚ËÂ
var
  zak : boolean;
begin
  result := trNextStep;
  //-------------------------- œÓ‚ÂËÚ¸ Á‡Ï˚Í‡ÌËÂ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ ÒÓ ÒÚÂÎÍÓÈ ‚ ÔÛÚË
  if not SignCircOtpravlVP(jmp.Obj,Group) then result := trStop;

  // œÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÛÚË ˜ÂÂÁ ¬Á ÒÚÂÎÍË
  if not SignCircOgrad(jmp.Obj,Group) then result := trStop; // Œ„‡Ê‰ÂÌËÂ ÔÛÚË

  if ObjZav[jmp.Obj].ObjConstB[6]
  then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[16]
  else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[17];

  if ObjZav[jmp.Obj].bParam[16] or zak then
  begin //--------------------------------------------------- ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
    result := trStop;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,119, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,119);
  end;

  if not (ObjZav[jmp.Obj].bParam[1] xor ObjZav[jmp.Obj].bParam[2]) then
  begin //--------------------------------------------------------- ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
    result := trStop;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
    InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81);
  end else
  if not SigCircNegStrelki(jmp.Obj,ObjZav[jmp.Obj].bParam[1],Group)
  then result := trStop; //------------------------------------------------ ÌÂ„‡·‡ËÚÌÓÒÚ¸

  case Con.Pin of
    1 :
    begin
      if not ObjZav[jmp.Obj].ObjConstB[11] then
      begin //-------------------------- ÒÚÂÎÍ‡ ÌÂ Ò·‡Ò˚‚‡˛˘‡ˇ ËÎË ÓÒÚˇÍË ÌÂ ‡Á‚ÂÌÛÚ˚
        if ObjZav[jmp.Obj].ObjConstB[6]
        then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33]
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34];

        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin //---------------------------- ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453);
        end;
      end;

      if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
      not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
      begin //---------------------------------- ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
        ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
        result := trStop;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,120);
      end;

      if ObjZav[jmp.Obj].bParam[1]
      then con := ObjZav[jmp.Obj].Neighbour[2]  //------------ ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
      else
      if ObjZav[jmp.Obj].bParam[2]
      then  con := ObjZav[jmp.Obj].Neighbour[3]//------------ ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
      else result := trStop; //------------------------------------ ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      if result <> trStop then
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,241, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,241);
          result := trStop;
        end;
      end;
    end;

    2 :
    begin
      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
        begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,120);
        end;
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        result := trStop;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
      end
      else result := trStop; // ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      Con := ObjZav[jmp.Obj].Neighbour[1];
      if result <> trStop then
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,242, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,242);
          result := trStop;
        end;
      end;
    end;

    3 :
    begin
      if ObjZav[jmp.Obj].ObjConstB[11] then
      begin // ÒÚÂÎÍ‡ Ò·‡Ò˚‚‡˛˘‡ˇ Ë ÓÒÚˇÍË ‡Á‚ÂÌÛÚ˚
        if ObjZav[jmp.Obj].ObjConstB[6]
        then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33]
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34];

        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453);
        end;
      end;

      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        result := trStop;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
        begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,120);
        end;
      end
      else  result := trStop;// ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      Con := ObjZav[jmp.Obj].Neighbour[1];
      if result <> trStop then
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,243, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,243);
          result := trStop;
        end;
      end;
    end;
  end;
end;
//========================================================================================
function StepStrelPovtorRazdel(var Con : TOZNeighbour;const Lvl :TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//----------------------------------- ÔÓ‚ÂÍ‡ ‰Îˇ ÔÓ‚ÚÓÌÓ„Ó ÓÚÍ˚ÚËˇ ‚ ‡Á‰ÂÎ¸ÌÓÏ ÂÊËÏÂ
var
  k : integer;
  zak : boolean;
begin
  result := trNextStep;
  if ObjZav[jmp.Obj].ObjConstB[6]
  then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[16]
  else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[17];

  if ObjZav[jmp.Obj].bParam[16] or zak then
  begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ‰‚ËÊÂÌËˇ
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,119, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,119);
  end;

  if not (ObjZav[jmp.Obj].bParam[1] xor ObjZav[jmp.Obj].bParam[2]) then
  begin // ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
    result := trStop;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,81, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
    InsMsg(Group,ObjZav[jmp.Obj].BaseObject,81);
  end else
  if not SigCircNegStrelki(jmp.Obj,ObjZav[jmp.Obj].bParam[1],Group)
  then result := trStop; // ÌÂ„‡·‡ËÚÌÓÒÚ¸

  case Con.Pin of
    1 :
    begin
      // ÔÓ‚ÂËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÔÓ ÏÛÌÛÒÛ ÒÚÂÎÍË ‚ ÔÛÚË ‚ ÔÓÂÁ‰ÌÓÏ Ï‡¯ÛÚÂ
      if MarhTracert[Group].VP > 0 then
      begin // ÂÒÚ¸ ÒÔËÒÓÍ ÒÚÂÎÓÍ ‚ ÔÛÚË
        for k := 1 to 4 do
        if (ObjZav[MarhTracert[Group].VP].ObjConstI[k] = jmp.Obj) and // ËÌ‰ÂÍÒ ÒÚÂÎÍË ‚ ÔÛÚË
        ObjZav[MarhTracert[Group].VP].ObjConstB[k+1] then          // ÔËÁÌ‡Í ‰Ó·Ó‡ Ú‡ÒÒ˚ ÔÓ ÔÎ˛ÒÛ
        begin // ÔÓ‚ÂËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÒÚÂÎÍË ÔÓ ÏËÌÛÒÛ
          if not ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[2] then
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,482, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,482);
          end;
        end;
      end;

      if not ObjZav[jmp.Obj].ObjConstB[11] then
      begin // ÒÚÂÎÍ‡ ÌÂ Ò·‡Ò˚‚‡˛˘‡ˇ ËÎË ÓÒÚˇÍË ÌÂ ‡Á‚ÂÌÛÚ˚
        if ObjZav[jmp.Obj].ObjConstB[6]
        then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33]
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34];

        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453);
        end;
      end;

      if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
      not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
      begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
        ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,120);
      end;

      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        if not ObjZav[jmp.Obj].bParam[6] then
        begin // ÒÚÂÎÍ‡ ÌÂ ÔÓ Ï‡¯ÛÚÛ
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
        end else
        begin
          ObjZav[jmp.Obj].bParam[10] := true;
          ObjZav[jmp.Obj].bParam[11] := false;// +
          con := ObjZav[jmp.Obj].Neighbour[2];
        end;
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        if not ObjZav[jmp.Obj].bParam[7] then
        begin // ÒÚÂÎÍ‡ ÌÂ ÔÓ Ï‡¯ÛÚÛ
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
        end else
        begin
          ObjZav[jmp.Obj].bParam[10] := true;
          ObjZav[jmp.Obj].bParam[11] := true; // -
                  con := ObjZav[jmp.Obj].Neighbour[3];
        end;
      end
      else result := trStop;// ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      // œÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÛÚË ˜ÂÂÁ ¬Á ÒÚÂÎÍË
      if not SignCircOgrad(jmp.Obj,Group) then result := trStop; // Œ„‡Ê‰ÂÌËÂ ÔÛÚË

      if result <> trStop then
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,241, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,241);
          result := trStop;
        end;
      end;
    end;

    2 :
    begin
      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        if not ObjZav[jmp.Obj].bParam[6] then
        begin // ÒÚÂÎÍ‡ ÌÂ ÔÓ Ï‡¯ÛÚÛ
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
        end;

        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
        begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
        end;
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        result := trStop;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
      end
      else  result := trStop; // ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      Con := ObjZav[jmp.Obj].Neighbour[1];
      // œÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÛÚË ˜ÂÂÁ ¬Á ÒÚÂÎÍË
      if not SignCircOgrad(jmp.Obj,Group)
      then result := trStop; // Œ„‡Ê‰ÂÌËÂ ÔÛÚË

      if result <> trStop then  ObjZav[jmp.Obj].bParam[12] := true; // +

      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,242, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,242);
          result := trStop;
        end;
      end;
    end;

    3 :
    begin
      if ObjZav[jmp.Obj].ObjConstB[11] then
      begin // ÒÚÂÎÍ‡ Ò·‡Ò˚‚‡˛˘‡ˇ Ë ÓÒÚˇÍË ‡Á‚ÂÌÛÚ˚
        if ObjZav[jmp.Obj].ObjConstB[6]
        then zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[33]
        else zak := ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[34];
        if ObjZav[jmp.Obj].bParam[17] or zak then
        begin // ÒÚÂÎÍ‡ Á‡Í˚Ú‡ ‰Îˇ ÔÓÚË‚Ó¯ÂÒÚÌÓ„Ó ‰‚ËÊÂÌËˇ
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,453, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,453);
        end;
      end;

      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÔÎ˛ÒÂ
        result := trStop;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
        InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÓÚÍÎÓÌˇ˛˘‡ˇ ÒÚÂÎÍ‡ ‚ ÏËÌÛÒÂ
        if not ObjZav[jmp.Obj].bParam[7] then
        begin // ÒÚÂÎÍ‡ ÌÂ ÔÓ Ï‡¯ÛÚÛ
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,160, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,160);
        end;

        if ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[19] and
        not ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] then
        begin // ÒÚÂÎÍ‡ Ì‡ Ï‡ÍÂÚÂ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
          ObjZav[ObjZav[jmp.Obj].BaseObject].bParam[27] := true;
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,120, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsWar(Group,ObjZav[jmp.Obj].BaseObject,120);
        end;
      end
      else  result := trStop; // ÌÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ

      Con := ObjZav[jmp.Obj].Neighbour[1];
      // œÓ‚ÂËÚ¸ Ó„‡Ê‰ÂÌËÂ ÔÛÚË ˜ÂÂÁ ¬Á ÒÚÂÎÍË
      if not SignCircOgrad(jmp.Obj,Group) then result := trStop; // Œ„‡Ê‰ÂÌËÂ ÔÛÚË

      if result <> trStop then ObjZav[jmp.Obj].bParam[13] := true; // -

      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,243, ObjZav[ObjZav[jmp.Obj].BaseObject].Liter,1);
          InsMsg(Group,ObjZav[jmp.Obj].BaseObject,243);
          result := trStop;
        end;
      end;
    end;
  end;
end;
//========================================================================================
function StepStrelFindIzvest(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//-------------------------------------------- ÔÓıÓ‰ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË Ò·ÓÍÂ ËÁ‚ÂÒÚËÚÂÎˇ
begin
  result := trNextStep;
  if not (ObjZav[jmp.Obj].bParam[1] xor ObjZav[jmp.Obj].bParam[2]) then
  begin // ≈ÒÎË ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ - ÔÂ‚‡Ú¸ Ò·ÓÍÛ ËÁ‚ÂÒÚËÚÂÎˇ
    result := trStop;
    exit;
  end;
  case Con.Pin of
    1 :
    begin
      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÔÓ ÔÎ˛ÒÛ
        con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else  result := trNextStep;
        end;
        exit;
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÔÓ ÏËÌÛÒÛ
        con := ObjZav[jmp.Obj].Neighbour[3];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
        exit;
      end
      else  result := trStop;
    end;

    2 :
    begin
      if ObjZav[jmp.Obj].bParam[1]  then
      begin // ÔÓ ÔÎ˛ÒÛ
        con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end
      else  result := trStop;
    end;

    3 :
    begin
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÔÓ ÏËÌÛÒÛ
        con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end
      else result := trStop;
    end;
  end;
end;
//========================================================================================
function StepStrelFindIzvStrel(var Con : TOZNeighbour; const Lvl :TTracertLevel;Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------- ÔÓıÓ‰ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË ÔÓ‚ÂÍÂ ÌÂÁ‡ÏÍÌÛÚ˚ı ÔÂ‰Ï‡¯ÛÚÌ˚ı ÒÚÂÎÓÍ
var
  zak : boolean;
  o,j,k : integer;
begin
  result := trNextStep;
  if not (ObjZav[jmp.Obj].bParam[1] xor ObjZav[jmp.Obj].bParam[2]) then
  begin // ≈ÒÎË ÒÚÂÎÍ‡ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ - ÔÂ‚‡Ú¸ Ò·ÓÍÛ ËÁ‚ÂÒÚËÚÂÎˇ
    result := trStop;
    exit;
  end;

  o := ObjZav[jmp.Obj].BaseObject;
  zak := false;

  if Rod = MarshP then
  begin // ÔÓ‚ÂËÚ¸ Á‡Ï˚Í‡ÌËÂ ÒÚÂÎÍË (‚ ÔÛÚË) ‚ Ï‡¯ÛÚÂ ÓÚÔ‡‚ÎÂÌËˇ Ò ÔÛÚË
    for j := 14 to 19 do
    begin
      if ObjZav[ObjZav[o].ObjConstI[j]].TypeObj = 41 then
      begin // ÍÓÌÚÓÎ¸ Ï‡¯ÛÚ‡ ÓÚÔ‡‚ÎÂÌËˇ Ò ÔÛÚË ÒÓ ÒÚÂÎÍÓÈ ‚ ÔÛÚË
        if ObjZav[ObjZav[o].ObjConstI[j]].BaseObject = Marhtracert[Group].ObjStart then
        begin // ÒÚÂÎÍ‡ Á‡Ï˚Í‡ÂÚÒˇ ‚ ÔÓÂÁ‰ÌÓÏ Ï‡¯ÛÚÂ Í‡Í Óı‡ÌÌ‡ˇ
          zak := true;
          break;
        end;
      end;
    end;
  end;

  if not zak then
  begin // ÔÓ‚ÂËÚ¸ ËÒÍÎ˛˜ÂÌËÂ ÔÂÂ‚Ó‰‡ ÒÚÂÎÍË
    k := ObjZav[jmp.Obj].UpdateObject;
    if not (ObjZav[ObjZav[o].ObjConstI[12]].bParam[1] or // –Á—
    ObjZav[jmp.Obj].bParam[5] or     // ÔËÁÌ‡Í ÔÂÂ‚Ó‰‡ Óı‡ÌÌÓÈ
    not ObjZav[k].bParam[2] or       // Á‡Ï˚Í‡ÌËÂ ËÁ —œ
    ObjZav[o].bParam[18] or          // ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ FR4
    ObjZav[jmp.Obj].bParam[18]) then // ‚˚ÍÎ˛˜ÂÌ‡ ËÁ ÛÔ‡‚ÎÂÌËˇ –Ã-ƒ—œ
    Marhtracert[Group].IzvStrNZ := true;
  end;

  case Con.Pin of
    1 :
    begin
      if ObjZav[jmp.Obj].bParam[1] then
      begin // ÔÓ ÔÎ˛ÒÛ
        con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
        exit;
      end else
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÔÓ ÏËÌÛÒÛ
        con := ObjZav[jmp.Obj].Neighbour[3];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
        exit;
      end
      else result := trStop;
    end;

    2 :
    begin
      if ObjZav[jmp.Obj].bParam[1]  then
      begin // ÔÓ ÔÎ˛ÒÛ
        con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end
      else result := trStop;
    end;

    3 :
    begin
      if ObjZav[jmp.Obj].bParam[2] then
      begin // ÔÓ ÏËÌÛÒÛ
        con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else  result := trNextStep;
        end;
      end
      else result := trStop;
    end;
  end;
end;
//========================================================================================
function StepStrelPovtorMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//------------------------------------ ÔÓıÓ‰ ˜ÂÂÁ ÒÚÂÎÍÛ ÔË ÔÓ‚ÚÓÌÓÏ Á‡‰‡ÌËË Ï‡¯ÛÚ‡
begin
  result := trNextStep;
  if not ObjZav[jmp.Obj].bParam[14] then
  begin //------------------------------------------------------ ‡ÁÛ¯ÂÌ‡ Ú‡ÒÒ‡ Ï‡¯ÛÚ‡
    if (MarhTracert[Group].MsgCount > 10) or (MarhTracert[Group].MsgCount = 0) then
    MarhTracert[Group].MsgCount := 1;
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,228, ObjZav[MarhTracert[Group].ObjStart].Liter,1);
    result := trStop;
    InsMsg(Group,MarhTracert[Group].ObjStart,228);
  end else
  case Con.Pin of
    1 :
    begin
      if ObjZav[jmp.Obj].bParam[6] and
      not ObjZav[jmp.Obj].bParam[7] then
      begin
        inc(MarhTracert[Group].StrCount);
        MarhTracert[Group].StrTrace[MarhTracert[Group].StrCount]   := jmp.Obj;
        MarhTracert[Group].PolTrace[MarhTracert[Group].StrCount,1] := true;
        MarhTracert[Group].PolTrace[MarhTracert[Group].StrCount,2] := false;
        con := ObjZav[jmp.Obj].Neighbour[2];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else  result := trNextStep;
        end;
      end else
      if not ObjZav[jmp.Obj].bParam[6] and ObjZav[jmp.Obj].bParam[7] then
      begin
        inc(MarhTracert[Group].StrCount);
        MarhTracert[Group].StrTrace[MarhTracert[Group].StrCount]   := jmp.Obj;
        MarhTracert[Group].PolTrace[MarhTracert[Group].StrCount,1] := false;
        MarhTracert[Group].PolTrace[MarhTracert[Group].StrCount,2] := true;
        con := ObjZav[jmp.Obj].Neighbour[3];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end
      else result := trStop;
    end;

    2 :
    begin
      if ObjZav[jmp.Obj].bParam[6]  then
      begin
        con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end
      else result := trStop;
    end;

    3 :
    begin
      if ObjZav[jmp.Obj].bParam[7] then
      begin
        con := ObjZav[jmp.Obj].Neighbour[1];
        case Con.TypeJmp of
          LnkRgn : result := trStop;
          LnkEnd : result := trStop;
          else result := trNextStep;
        end;
      end
      else result := trStop;
    end;
  end;
end;
//========================================================================================
function StepSvetoforFindTrace(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//----------------------------------------------------- ¯‡„ ˜ÂÂÁ ÒË„Ì‡Î ÔË ÔÓËÒÍÂ Ú‡ÒÒ˚
begin
  if ObjZav[Con.Obj].RU = ObjZav[MarhTracert[Group].ObjStart].RU then
  begin //------------------------------ œÓ‰ÓÎÊËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË Ò‚ÓÈ ‡ÈÓÌ ÛÔ‡‚ÎÂÌËˇ
    if ObjZav[jmp.Obj].ObjConstB[1] then result := trRepeat //-----  ÍÓÌÂˆ Ú‡ÒÒËÓ‚ÍË
    else
    if Con.Pin = 1 then //------------------------ ÂÒÎË ‚Ó¯ÎË Ì‡ ÒË„Ì‡Î ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 1
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2]; //------- ‚˚ıÓ‰ÌÓÈ ÍÓÌÌÂÍÚÓ ·ÂÂÚÒˇ ÓÚ ÚÓ˜ÍË 2
      case Con.TypeJmp of
        LnkRgn : result := trRepeat; //----------- Ì‡ÚÍÌÛÎËÒ¸ Ì‡ ÍÓÌÂˆ ‡ÈÓÌ‡ - ÓÚÍ‡ÚËÚ¸Òˇ
        LnkEnd : result := trRepeat; //----------- Ì‡ÚÍÌÛÎËÒ¸ Ì‡ ÍÓÌÂˆ ÒÚÓÍË - ÓÚÍ‡ÚËÚ¸Òˇ
        else result := trNextStep;
      end;
    end else //-------------------------------------------------- ‚Ó¯ÎË ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 2
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1]; //---------------- ‚˚ıÓ‰ÌÓÈ ÍÓÌÌÂÍÚÓ ‚ ÚÓ˜ÍÂ 1
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
        else result := trNextStep;
      end;
    end;
  end
  else result := trRepeat;
end;
//========================================================================================
function StepSvetoforContTrace(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//---------------------------------------------------- ÔÓ‰ÎÂÌËÂ Ú‡ÒÒ˚ Á‡ ÛÍ‡Á‡ÌÌ˚È ÍÓÌÂˆ
var
  i,j,k : integer;
begin
  if ObjZav[Con.Obj].RU = ObjZav[MarhTracert[Group].ObjStart].RU then
  begin //------------------------------ œÓ‰ÓÎÊËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË Ò‚ÓÈ ‡ÈÓÌ ÛÔ‡‚ÎÂÌËˇ
    //----------------------------------- ÂÒÎË ÌÂÎ¸Áˇ ‰‡Î¸¯Â, ÒÏÂÌ‡ Ì‡Ô‡‚ÎÂÌËˇ ◊/Õ, ÚÛÔËÍ
    if ObjZav[jmp.Obj].ObjConstB[1] then  result := trEndTrace
    else
    if Con.Pin = 1 then
    begin //-------------------------------------------------------------- œÓÔÛÚÌ˚È ÒË„Ì‡Î
      if (((Rod = MarshM) and ObjZav[jmp.Obj].ObjConstB[7]) or//--- Ï‡ÌÂ‚ Ë ÍÓÌÂˆ Ú.1 ËÎË
      ((Rod = MarshP) and ObjZav[jmp.Obj].ObjConstB[5])) and //--------- ÔÓÂÁ‰ Ë ÍÓÌÂˆ Ú.1
                                                                 //----------------- » ...
      (ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] or //--- ·ÎÓÍ STAN ËÎË DSP
      ObjZav[jmp.Obj].bParam[18] or //----------------------------------------  ËÎË –Ã(Ã»)
                                        //---------------------------------------  ËÎË ...
      (ObjZav[jmp.Obj].ObjConstB[2] and //----------------- ‚ÓÁÏÓÊÌÓ Ì‡˜‡ÎÓ ÔÓÂÁ‰Ì˚ı Ë ...
      (ObjZav[jmp.Obj].bParam[3] or ObjZav[jmp.Obj].bParam[4] or //----- —1 ËÎË —2 ËÎË ...
      ObjZav[jmp.Obj].bParam[8] or ObjZav[jmp.Obj].bParam[9])) or //---- Õ ÓÚ STAN ËÎË œœ–
                                            //------------------------------------ ËÎË ...
      (ObjZav[jmp.Obj].ObjConstB[3] and  //-------------- ‚ÓÁÏÓÊÌÓ Ì‡˜‡ÎÓ Ï‡ÌÂ‚Ó‚˚ı Ë ...
      (ObjZav[jmp.Obj].bParam[1] or ObjZav[jmp.Obj].bParam[2] or //--- Ã—1 ËÎË Ã—2 ËÎË ...
      ObjZav[jmp.Obj].bParam[6] or ObjZav[jmp.Obj].bParam[7]))) then //--- ÕÃ STAN ËÎË Ãœ–
      result := trEndTrace //------ «‡‚Â¯ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ ÂÒÎË ÔÓÔÛÚÌ˚È ‚ÔÂÂ‰Ë ÛÊÂ ÓÚÍ˚Ú
      else
      case Rod of
        MarshP : //----------------------------------------------------- œŒ≈«ƒÕ€≈ œŒœ”“Õ€≈
        begin
          if ObjZav[jmp.Obj].ObjConstB[16] and //------------ ÌÂÚ ÒÍ‚ÓÁÌ˚ı Ï‡¯ÛÚÓ‚ Ë ...
          ObjZav[jmp.Obj].ObjConstB[2] then //------------------- ‚ÓÁÏÓÊÌÓ Ì‡˜‡ÎÓ ÔÓÂÁ‰Ì˚ı
          result := trEndTrace //-------------------------------- Ó·Ì‡ÛÊÂÌ ÍÓÌÂˆ Ï‡¯ÛÚ‡
          else
          if ObjZav[jmp.Obj].ObjConstB[5] then
          begin //----------- ÂÒÚ¸ ÍÓÌÂˆ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡ ‚ ÚÓ˜ÍÂ 1 Ò‚ÂÚÓÙÓ‡ ( Û ‚ıÓ‰‡)
            MarhTracert[Group].FullTail := true; //-------- ÔÓÎÌÓÚ‡ ‰Ó·Ó‡ ı‚ÓÒÚ‡ Ï‡¯ÛÚ‡
            MarhTracert[Group].FindNext := true; //------ ÔÓ‚ÂÍ‡ ‚ÓÁÏÓÊÌÓÒÚË ÔÓ‰ÓÎÊÂÌËˇ
            if ObjZav[jmp.Obj].ObjConstB[2] //------------------- ‚ÓÁÏÓÊÌÓ Ì‡˜‡ÎÓ ÔÓÂÁ‰Ì˚ı
            then
            begin
              result := trEnd;     //-------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË Ù‡„ÏÂÌÚ‡
              MarhTracert[Group].ObjEnd := jmp.Obj; // ÔÂÂÌÓÒ ÍÓÌˆ‡ ÔÓÂÁ‰ÌÓ„Ó Ì‡ ÔÓÔÛÚÌ˚È
            end
            else result := trEndTrace; //------------------------ Ó·Ì‡ÛÊÂÌ ÍÓÌÂˆ Ï‡¯ÛÚ‡
          end
          else result := trNextStep; //----- ÌÂÚ ÍÓÌˆ‡ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡ Û Ò‚ÂÚÓÙÓ‡,Ë‰ÚË
        end;

        MarshM : //--------------------------------------------------- Ã¿Õ≈¬–Œ¬€≈ œŒœ”“Õ€≈
        begin
          if ObjZav[jmp.Obj].ObjConstB[7] then //----- ÂÒÚ¸ ÍÓÌÂˆ Ï‡ÌÂ‚Ó‚˚ı ‚ Ú.1 ÒË„Ì‡Î‡
          begin
            MarhTracert[Group].FullTail := true; //------------------------ ÔÓÎÌÓÚ‡ ‰Ó·Ó‡
            MarhTracert[Group].FindNext := true; //----- ÔÓ‚ÂËÚ¸ ‚ÓÁÏÓÊÌÓÒÚ¸ ÔÓ‰ÓÎÊÂÌËˇ
            if ObjZav[jmp.Obj].ObjConstB[3] //----------------- ‚ÓÁÏÓÊÌÓ Ì‡˜‡ÎÓ Ï‡ÌÂ‚Ó‚˚ı
            then
            begin
              result := trEnd;  //----------------------------  ÓÌÂˆ Ú‡ÒÒËÓ‚ÍË Ù‡„ÏÂÌÚ‡
              MarhTracert[Group].ObjEnd := jmp.Obj;
            end
            else result := trEndTrace;
          end
          else result := trNextStep; //---- ÌÂÚ ÍÓÌˆ‡ Ï‡ÌÂ‚Ó‚˚ı ‚ Ú.1 - ¯‡„‡Ú¸ ‰‡Î¸¯Â
        end;

        else result := trEnd; //------ Ó¯Ë·Ó˜Ì˚È ÚËÔ Ï‡¯ÛÚ‡ - Á‡ÍÓÌ˜ËÚ¸ ÔÓËÒÍ Ú‡ÒÒ˚
      end;

      if result = trNextStep then //-------------------------- ÂÒÎË Ì‡‰Ó ¯‡„‡Ú¸ ‰‡Î¸¯Â
      begin
        Con := ObjZav[jmp.Obj].Neighbour[2]; //- ‡ÒÒÏÓÚËÏ ÍÓÌÌÂÍÚÓ Á‡ ÒË„Ì‡ÎÓÏ (Ú2)
        case Con.TypeJmp of
          LnkRgn : result := trStop; //----------------------- ÍÓÌÂˆ ‡ÈÓÌ‡ ÛÔ‡‚ÎÂÌËˇ
          LnkEnd : result := trStop; //----------------------------- ÍÓÌÂˆ Ú‡ÒÒËÓ‚ÍË
        end;
      end;
    end else
    begin //------------------------ ¬ÒÚÂ˜Ì˚È ÒË„Ì‡Î (‚Ó¯ÎË Ì‡ ÒË„Ì‡Î ÒÓ ÒÚÓÓÌ˚ Ú.2)
      case Rod of
        MarshP : //-------------------------- ¬—“–≈◊Õ€≈ ÒË„Ì‡Î˚ ÔË ÔÓÂÁ‰Ì˚ı -------------
        begin
          if ObjZav[jmp.Obj].ObjConstB[5] //---- œÓÂÁ‰ÌÓÈ ÍÓÌÂˆ ÂÒÚ¸ ‚ Ú.1 Á‡ ÒË„Ì‡ÎÓÏ
          then result := {trEndPlus} trNextStep //- ÂÒÚ¸ ÍÓÌÂˆ Ï‡¯ÛÚ‡, Á‡ ÒË„Ì‡ÎÓÏ Ì‡‰Ó ÔÓ‚ÂËÚ¸
          else //-------------------------------------- ÂÒÎË ÔÓÂÁ‰ÌÓ„Ó ÍÓÌˆ‡ ÌÂÚ ‚ Ú.1
          begin
            if ObjZav[jmp.Obj].Neighbour[1].TypeJmp = 0 then //------------ ÒÓÒÂ‰‡ ÌÂÚ
            result := trStop //-------------------- ŒÚÍ‡Á ÂÒÎË ÌÂÚ ÔÓÂÁ‰ÌÓ„Ó ËÁ ÚÛÔËÍ‡
            else result := trNextStep; //-------------------------------- ËÌ‡˜Â ¯‡„‡Ú¸
          end;
        end;

        MarshM : //------------------------- ¬—“–≈◊Õ€≈ —»√Õ¿À€ ÔË Ï‡ÌÂ‚‡ı---------------
        begin
          if ObjZav[jmp.Obj].ObjConstB[8] //ÂÒÎË Ï‡ÌÂ‚˚ ÓÍÓÌ˜ÂÌ˚ ÔÂÂ‰ ÒË„Ì‡ÎÓÏ ÚÓ ÍÓÌÂˆ
          then
          begin
            result := trEndTrace;
            if jmp.Pin = 1  then jmp := ObjZav[jmp.Obj].Neighbour[2]
            else jmp := ObjZav[jmp.Obj].Neighbour[1];
          end
          else
            if ObjZav[jmp.Obj].ObjConstB[7]//ÂÒÎË ÍÓÌÂˆ Ï‡ÌÂ‚Ó‚ ‚ Ú.1 (Á‡ ‚ÒÚÂ˜Ì˚Ï ÒË„Ì.)
            then result := trNextStep //----------------------------  ÚÓ ÔÓ‰ÓÎÊ‡ÂÏ ‰‡Î¸¯Â
            else
            begin
              j :=  MarhTracert[Group].Counter;
              for i := 0 to j do
              begin
                k := MarhTracert[Group].ObjTrace[j-1];
                if (ObjZav[k].TypeObj = 3) or (ObjZav[k].TypeObj = 4) then
                begin
                  MarhTracert[Group].ObjEnd := k;
                  break;
                end else
                begin
                  MarhTracert[Group].ObjTrace[j] := 0;
                  dec(MarhTracert[Group].Counter);
                end;
              end;
              result := trEnd; //------------------------------------------- ËÌ‡˜Â ÒÚÓÔ
            end;

        end;

        else result := trEnd; //------------------ Ï‡¯ÛÚ ÌÂÔÓÌˇÚÌ˚È, ÌÂ Ú‡ÒÒËÓ‚‡Ú¸
      end;

      if result = trNextStep then //------------------------- ÂÒÎË ÌÛÊÌÓ ¯‡„‡Ú¸ ‰‡Î¸¯Â
      begin
        Con := ObjZav[jmp.Obj].Neighbour[1]; //----- ‡ÒÒÏ‡ÚË‚‡ÂÚÒˇ ÍÓÌÌÂÍÚÓ ÚÓ˜ÍË 1
        case Con.TypeJmp of
          LnkRgn : result := trRepeat;
          LnkEnd : result := trRepeat;
          LnkFull : result := trNextStep;
          LnkNecentr : result := trEndTrace;
        end;
      end;

      if result = trEndPlus then  result := trEndTrace; //--- ÌÓ‚‡ˇ ‚ÒÚ‡‚Í‡ @@@@@@@@@@@@

    end;
  end
  else result := trEndTrace;//«‡‚Â¯ËÚ¸ Ú‡ÒÒËÓ‚ÍÛ Ï‡¯ÛÚ‡ ÂÒÎË ‰Û„ÓÈ ‡ÈÓÌ ÛÔ‡‚ÎÂÌËˇ
end;
//========================================================================================
function StepSvetoforZavTrace(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//-------------------------------------------------------- ÔÓ‚ÂÍ‡ Á‡‚ËÒËÏÓÒÚÂÈ ÔÓ Ú‡ÒÒÂ
begin
  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      LnkNecentr : result := trEndTrace;
      else result := trNextStep;
    end;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      LnkNecentr : result := trEndTrace;
      else result := trNextStep;
    end;
  end;
end;
//========================================================================================
function StepSvetoforCheckTrace(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//---------------------------------------------- ÔÓ‚ÂÍ‡ ‚‡Ê‰Â·ÌÓÒÚÂÈ ÔÓ Ú‡ÒÒÂ Ï‡¯ÛÚ‡
begin
  result := trNextStep;
  if (ObjZav[jmp.Obj].bParam[12] or  //--------------------- ·ÎÓÍËÓ‚Í‡ ‚ STAN ËÎË ...
  ObjZav[jmp.Obj].bParam[13]) and //--------------------------- ·ÎÓÍËÓ‚Í‡ ‚ DSP Ë ...
  (jmp.Obj <> MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter]) // ÌÂ ÔÓÒÎÂ‰ÌËÈ
  then
  begin //------------------------------------ Á‡·ÎÓÍËÓ‚‡Ì Ò‚ÂÚÓÙÓ ‚ ÒÂÂ‰ËÌÂ Ú‡ÒÒ˚
    result := trBreak;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,123, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,123); //----------------------------- —‚ÂÚÓÙÓ $ Á‡·ÎÓÍËÓ‚‡Ì
    MarhTracert[Group].GonkaStrel := false;
  end;

  if ObjZav[jmp.Obj].bParam[18] and //------------------------------- ÂÒÎË –Ã (ËÎË Ã»)
  (jmp.Obj <> MarhTracert[Group].ObjTrace[MarhTracert[Group].Counter]) then //- ‚ÌÛÚË
  begin //--------------------------- Ò‚ÂÚÓÙÓ Ì‡ ÏÂÒÚÌÓÏ ÛÔ‡‚ÎÂÌËË ‚ ÒÂÂ‰ËÌÂ Ú‡ÒÒ˚
    result := trBreak;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,232, ObjZav[jmp.Obj].Liter,1);//------- —Ë„Ì‡Î $ Ì‡ ÏÂÒÚÌÓÏ ÛÔ‡‚ÎÂÌËË
    InsMsg(Group,jmp.Obj,232);
    MarhTracert[Group].GonkaStrel := false;
  end;

  if Con.Pin = 1 then //-------------------------------------- ‚Ó¯ÎË ‚ ÔÓÔÛÚÌ˚È ÒË„Ì‡Î
  begin //----------------------------------------------------- ¬‡Ê‰Â·ÌÓÒÚË ÔÓÔÛÚÌÓ„Ó
    if ((not ObjZav[jmp.Obj].ObjConstB[5] and (Rod = MarshP)) or//ÌÂÚ œ-ÍÓÌˆ‡ ‚ Ú1 ËÎË
    (not ObjZav[jmp.Obj].ObjConstB[7] and (Rod = MarshM))) and //ÌÂÚ Ã-ÍÓÌˆ‡ ‚ Ú1 Ë
    (ObjZav[jmp.Obj].bParam[1] or ObjZav[jmp.Obj].bParam[2] or  //---- Ã—1 ËÎË Ã—2 ËÎË
    ObjZav[jmp.Obj].bParam[3] or ObjZav[jmp.Obj].bParam[4]) then //--------- —1 ËÎË —2
    begin
      result := trBreak;
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,114, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,114);  //----------------------- ŒÚÍ˚Ú ‚‡Ê‰Â·Ì˚È ÒË„Ì‡Î $
      MarhTracert[Group].GonkaStrel := false;
    end;

    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;

    if MarhTracert[Group].FindTail //----------- ÂÒÎË ÒÓÁ‰‡ÌÓ ÒÓÓ·˘ÂÌËÂ Ó ÍÓÌˆÂ Ú‡ÒÒ˚
    then MarhTracert[Group].TailMsg := ' ‰Ó '+ ObjZav[jmp.Obj].Liter;
  end else
  begin //------- ÂÒÎË ‚Ó¯ÎË ‚Ó ‚ÒÚÂ˜Ì˚È ÒË„Ì‡Î, ÚÓ ÔÓÒÏÓÚ ‚‡Ê‰Â·ÌÓÒÚÂÈ ‚ÒÚÂ˜ÌÓ„Ó
    if ObjZav[jmp.Obj].bParam[1] or   //---------------------------------- Ã—1 ËÎË ...
    ObjZav[jmp.Obj].bParam[2] or   //------------------------------------- Ã—2 ËÎË ...
    ObjZav[jmp.Obj].bParam[3] or   //-------------------------------------- —1 ËÎË ...
    ObjZav[jmp.Obj].bParam[4] then //---------------------------------------------- —2
    begin
      result := trBreak;
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,114, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,114);  //----------------------- ŒÚÍ˚Ú ‚‡Ê‰Â·Ì˚È ÒË„Ì‡Î $
      MarhTracert[Group].GonkaStrel := false;
    end;

    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;

    if MarhTracert[Group].FindTail then //----------------------- ÂÒÎË Ì‡È‰ÂÌ ı‚ÓÒÚ Ú‡ÒÒ˚
    begin
      if (ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 5) and (jmp.Pin = 1)
      then //---------------------------------------------- ÂÒÎË ÍÓÌÂˆ Ì‡ ÔÓÔÛÚÌÓÏ ÒË„Ì‡ÎÂ
       MarhTracert[Group].TailMsg := ' ‰Ó '+ ObjZav[jmp.Obj].Liter
      else
        if ObjZav[MarhTracert[Group].ObjEnd].ObjConstB[3] and (Rod = MarshM) then
        MarhTracert[Group].TailMsg := ' Á‡ '+ ObjZav[jmp.Obj].Liter
        else
        if ObjZav[MarhTracert[Group].ObjEnd].ObjConstB[2] and (Rod = MarshP) then
        MarhTracert[Group].TailMsg := ' Á‡ '+ ObjZav[jmp.Obj].Liter
        else
        begin
          result := trBreak;
        end;
//        MarhTracert[Group].TailMsg := ' ‰Ó '+ ObjZav[jmp.Obj].Liter;
    end;
  end;
end;
//========================================================================================
function StepSvetoforZamykTrace(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//------------------- Á‡Ï˚Í‡ÌËÂ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡, Ò·Ó ÔÓÎÓÊÂÌËÈ ÓÚÍÎÓÌˇ˛˘Ëı ÒÚÂÎÓÍ Ú‡ÒÒ˚
begin
  if Con.Pin = 1 then  //--------------------------------------------- ÔÓÔÛÚÌ˚È ÒË„Ì‡Î
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      if MarhTracert[Group].FindTail //---------------------- ÂÒÎË Ì‡È‰ÂÌ ÍÓÌÂˆ Ú‡ÒÒ˚
      then MarhTracert[Group].TailMsg := ' ‰Ó '+ ObjZav[jmp.Obj].Liter;

      //---------------------------------- ‡ÁÌÂÒÚË ÔËÁÌ‡ÍË Ì‡˜‡Î‡ ‚ ÔÓÔÛÚÌ˚Â ÒË„Ì‡Î˚
      if ObjZav[MarhTracert[Group].ObjStart].bParam[7] then //Ï‡ÌÂ‚Ó‚˚È ÔËÁÌ‡Í Ú‡ÒÒ
      begin
        if ObjZav[jmp.Obj].ObjConstB[3] then //---------------- ÂÒÚ¸ Ï‡ÌÂ‚Ó‚ÓÂ Ì‡˜‡ÎÓ
        begin
          MarhTracert[Group].SvetBrdr := jmp.Obj;//ÒÏÂÌËÚ¸ ËÌ‰ÂÍÒ „‡ÌËˆ˚ ·ÎÓÍ-Û˜‡ÒÚÍ‡
          ObjZav[jmp.Obj].bParam[7] := true;  //----------------------------------- ÕÃ
          ObjZav[jmp.Obj].bParam[14] := true; //---------------------- ÔÓ„. Á‡Ï˚Í‡ÌËÂ
          ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart; // ËÌ‰ÂÍÒ Ï‡¯ÛÚ‡
        end;
      end else

      if ObjZav[MarhTracert[Group].ObjStart].bParam[9] then //- ÔÓÂÁ‰ÌÓÈ ÔËÁÌ‡Í Ú‡ÒÒ
      begin
        if ObjZav[jmp.Obj].ObjConstB[2] then //------------------ ÂÒÚ¸ ÔÓÂÁ‰ÌÓÂ Ì‡˜‡ÎÓ
        begin
          MarhTracert[Group].SvetBrdr := jmp.Obj;//ÒÏÂÌËÚ¸ ËÌ‰ÂÍÒ „‡ÌËˆ˚ ·ÎÓÍ-Û˜‡ÒÚÍ‡
          ObjZav[jmp.Obj].bParam[8] := true;  //------------------------------------ Õ
          ObjZav[jmp.Obj].bParam[14] := true; //----------- ÛÒÚ‡ÌÓ‚ËÚ¸ ÔÓ„. Á‡Ï˚Í‡ÌËÂ
          ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart; // ËÌ‰ÂÍÒ Ï‡¯ÛÚ‡
        end;
      end;
    end;
  end else //--------------------------------- ‚Ó¯ÎË ‚Ó ‚ÒÚÂ˜Ì˚È ÒË„Ì‡Î (ÓÚ ÚÓ˜ÍË “2)
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      LnkNecentr : result := trEndTrace;
      else  result := trNextStep;
    end;

    if MarhTracert[Group].FindTail then
    begin
      if ObjZav[MarhTracert[Group].ObjEnd].TypeObj = 5 then //-- ÂÒÎË ÍÓÌÂˆ Ì‡ ÒË„Ì‡ÎÂ
      MarhTracert[Group].TailMsg := ' ‰Ó '+ ObjZav[jmp.Obj].Liter
      else MarhTracert[Group].TailMsg := ' Á‡ '+ ObjZav[jmp.Obj].Liter;
    end;

    ObjZav[jmp.Obj].bParam[14] := true;  //--------------------------- ÔÓ„. Á‡Ï˚Í‡ÌËÂ
    ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart; //------ ËÌ‰ÂÍÒ Ï‡¯ÛÚ‡
  end;
end;
//========================================================================================
function StepSignalCirc(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//------------------------ —Ë„Ì‡Î¸Ì‡ˇ ÒÚÛÌ‡ (ÔÓ‚ÚÓÌÓÂ ÓÚÍ˚ÚËÂ ÒË„Ì‡Î‡, ÓÚÏÂÌ‡ Ï‡¯ÛÚ‡)
begin
  result := trNextStep;
  if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then
  begin //------------------------------------------------------ Á‡·ÎÓÍËÓ‚‡Ì Ò‚ÂÚÓÙÓ
    if not((ObjZav[jmp.Obj].ObjConstB[5] and (Rod = MarshP) and (Con.Pin = 1)) or
    (ObjZav[jmp.Obj].ObjConstB[6] and (Rod = MarshP) and (Con.Pin = 2)) or
    (ObjZav[jmp.Obj].ObjConstB[7] and (Rod = MarshM) and (Con.Pin = 1)) or
    (ObjZav[jmp.Obj].ObjConstB[8] and (Rod = MarshM) and (Con.Pin = 2))) then
    begin
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,123, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,123);   //------------------------- —‚ÂÚÓÙÓ $ Á‡·ÎÓÍËÓ‚‡Ì
    end;
  end else
  if ObjZav[jmp.Obj].bParam[18] then
  begin //--------------------------------------------- Ò‚ÂÚÓÙÓ Ì‡ ÏÂÒÚÌÓÏ ÛÔ‡‚ÎÂÌËË
    if not((ObjZav[jmp.Obj].ObjConstB[5] and (Rod = MarshP) and (Con.Pin = 1)) or
    (ObjZav[jmp.Obj].ObjConstB[6] and (Rod = MarshP) and (Con.Pin = 2)) or
    (ObjZav[jmp.Obj].ObjConstB[7] and (Rod = MarshM) and (Con.Pin = 1)) or
    (ObjZav[jmp.Obj].ObjConstB[8] and (Rod = MarshM) and (Con.Pin = 2))) then
    begin
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,232, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,232); //-------------------- —Ë„Ì‡Î $ Ì‡ ÏÂÒÚÌÓÏ ÛÔ‡‚ÎÂÌËË
    end;
  end
  else result := trNextStep;

  if Con.Pin = 1 then
  begin //----------------------------------------------------- ¬‡Ê‰Â·ÌÓÒÚË ÔÓÔÛÚÌÓ„Ó
    case Rod of
      MarshP :
      begin
        if ObjZav[jmp.Obj].ObjConstB[5] then //------------------------------- ÂÒÎË —2
        begin
          if ObjZav[jmp.Obj].bParam[5] and //----------------------- Ó„ÌÂ‚ÓÂ Ë ÌÂÚ ...
          not (ObjZav[jmp.Obj].bParam[1] or ObjZav[jmp.Obj].bParam[2] or// Ã—1 ËÎË Ã—2
          ObjZav[jmp.Obj].bParam[3] or ObjZav[jmp.Obj].bParam[4]) then //ËÎË —1 ËÎË —2
          begin //--------------------- Ã‡¯ÛÚ ÌÂ ÔËÍ˚Ú Á‡ÔÂ˘‡˛˘ËÏ Ó„ÌÂÏ ÔÓÔÛÚÌÓ„Ó
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,115, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,115); //- Ã‡¯ÛÚ ÌÂ Ó„‡Ê‰ÂÌ! ÕÂËÒÔ‡‚ÂÌ Á‡ÔÂ˘‡˛˘ËÈ
          end;
          result := trEndTrace;
        end;

        if ObjZav[jmp.Obj].ObjConstB[19] then
        begin //---------------  ÓÓÚÍËÈ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ ‰Îˇ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡
          if not ObjZav[jmp.Obj].bParam[4] then
          begin //------------------------------------------------------ Á‡Í˚Ú ÒË„Ì‡Î
            result := trStop;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,391, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,391); //----------------------------- —Ë„Ì‡Î $ Á‡Í˚Ú
          end;
        end;
      end;

      MarshM :
      begin
        if ObjZav[jmp.Obj].ObjConstB[7] then   //- ‚ÓÁÏÓÊÂÌ Ï‡ÌÂ‚Ó‚˚È ÍÓÌÂˆ ‚ ÚÓ˜ÍÂ 1
        begin
          if ObjZav[jmp.Obj].bParam[5] and not //----------------------- Ó„ÌÂ‚ÓÂ Ë ÌÂÚ
          (ObjZav[jmp.Obj].bParam[1] or ObjZav[jmp.Obj].bParam[2] or //Ã—1 ËÎË Ã—2 ËÎË
          ObjZav[jmp.Obj].bParam[3] or ObjZav[jmp.Obj].bParam[4]) then //--- —1 ËÎË —2
          begin //--------------------- Ã‡¯ÛÚ ÌÂ ÔËÍ˚Ú Á‡ÔÂ˘‡˛˘ËÏ Ó„ÌÂÏ ÔÓÔÛÚÌÓ„Ó
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,115, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,115); //- Ã‡¯ÛÚ ÌÂ Ó„‡Ê‰ÂÌ! ÕÂËÒÔ‡‚ÂÌ Á‡ÔÂ˘‡˛˘ËÈ
          end;
          result := trEndTrace;
        end;

        if ObjZav[jmp.Obj].ObjConstB[20] then
        begin //-------------  ÓÓÚÍËÈ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ ‰Îˇ Ï‡ÌÂ‚Ó‚Ó„Ó Ï‡¯ÛÚ‡
          if not ObjZav[jmp.Obj].bParam[2] then //---------------------------- ÌÂÚ Ã—2
          begin //------------------------------------------------------ Á‡Í˚Ú ÒË„Ì‡Î
            result := trStop;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,391, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,391);
          end;
        end;
      end;

      else result := trEnd;
    end;

    Con := ObjZav[jmp.Obj].Neighbour[2]; //-------------- ÍÓÌÌÂÍÚÓ ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 2
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end else
  begin //---------------------------------------- ¬‡Ê‰Â·ÌÓÒÚË ‚ÒÚÂ˜ÌÓ„Ó ‚Ó¯ÎË ‚ Ú.2
    if ObjZav[jmp.Obj].ObjConstB[6] and (Rod = MarshP) //‚ÓÁÏÓÊÂÌ ÍÓÌÂˆ ÔÓÂÁ‰Ì˚ı ‚ Ú.2
    then result := trStop
    else
    if ObjZav[jmp.Obj].ObjConstB[8] and (Rod =MarshM)//‚ÓÁÏÓÊÂÌ ÍÓÌÂˆ Ï‡ÌÂ‚Ó‚˚ı ‚ Ú.2
    then result := trStop
    else
    if ObjZav[jmp.Obj].bParam[1] or   //------------------------------------------ Ã—1
    ObjZav[jmp.Obj].bParam[2] or   //--------------------------------------------- Ã—2
    ObjZav[jmp.Obj].bParam[3] or   //---------------------------------------------- —1
    ObjZav[jmp.Obj].bParam[4] then //---------------------------------------------- —2
    begin
      result := trStop;
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,114, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,114); //------------------------ ŒÚÍ˚Ú ‚‡Ê‰Â·Ì˚È ÒË„Ì‡Î $
    end;

    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end;
end;
//========================================================================================
function StepSigOtmenaMarh(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//-------------------------------------- ŒÚÏÂÌ‡ Ï‡¯ÛÚ‡, Á‡ÏÍÌÛÚÓ„Ó –ÂÎÂ "«" ËÎË ÒÂ‚ÂÓÏ
begin
  result := trNextStep;
  if Con.Pin = 1 then
  begin //------------------------------------------------------------ ÔÓÔÛÚÌ˚È ÒË„Ì‡Î
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn :
      begin
        ObjZav[jmp.Obj].bParam[14] := false;
        result := trEnd;
      end;

      LnkEnd :
      begin
        ObjZav[jmp.Obj].bParam[14] := false;
        result := trStop;
      end;
      else result := trNextStep;
    end;

    if result = trNextStep then
    begin     //----------------------- Ì‡ÈÚË ı‚ÓÒÚ ‰‡ÌÌÓÈ Í‡ÚÂ„ÓËË Ï‡¯ÛÚ‡
      if Rod = MarshM then
      begin // Ï‡ÌÂ‚Ó‚˚È
        if ObjZav[jmp.Obj].ObjConstB[7] then result := trStop
        else ObjZav[jmp.Obj].bParam[14] := false;
      end else
      if Rod = MarshP then
      begin // ÔÓÂÁ‰ÌÓÈ
        if ObjZav[jmp.Obj].ObjConstB[5] then result := trStop
        else ObjZav[jmp.Obj].bParam[14] := false;
      end;
    end;
  end else
  begin // ‚ÒÚÂ˜Ì˚È ÒË„Ì‡Î
    ObjZav[jmp.Obj].bParam[14] := false;
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;      // Ì‡ÈÚË ı‚ÓÒÚ ‰‡ÌÌÓÈ Í‡ÚÂ„ÓËË Ï‡¯ÛÚ‡
      else   // Ì‡ÈÚË ı‚ÓÒÚ ‰‡ÌÌÓÈ Í‡ÚÂ„ÓËË Ï‡¯ÛÚ‡
      if Rod = MarshM then
      begin // Ï‡ÌÂ‚Ó‚˚È
        if ObjZav[jmp.Obj].ObjConstB[8]
        then result := trStop
        else result := trNextStep;
      end else
      if Rod = MarshP then
      begin // ÔÓÂÁ‰ÌÓÈ
        if ObjZav[jmp.Obj].ObjConstB[6]
        then result := trStop
        else result := trNextStep;
      end;
    end;
  end;
end;
//========================================================================================
function StepSigAutoPovtorRazdel(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//------------------ ÔÓıÓ‰ ÔË ‡‚ÚÓ‰ÂÈÒÚ‚ËË, ‡Á‰ÂÎ¸ÌÓÏ ÓÚÍ˚ÚËË ËÎË ÔÓ‚ÚÓÂ ‚ ‡Á‰ÂÎ¸ÌÓÏ
begin
  result := trNextStep;
  if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then
  begin // Á‡·ÎÓÍËÓ‚‡Ì Ò‚ÂÚÓÙÓ
    if not((ObjZav[jmp.Obj].ObjConstB[5] and (Rod = MarshP) and (Con.Pin = 1)) or
    (ObjZav[jmp.Obj].ObjConstB[6] and (Rod = MarshP) and (Con.Pin = 2)) or
    (ObjZav[jmp.Obj].ObjConstB[7] and (Rod = MarshM) and (Con.Pin = 1)) or
    (ObjZav[jmp.Obj].ObjConstB[8] and (Rod = MarshM) and (Con.Pin = 2))) then
    begin
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,123, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,123);
    end;
  end else
  if ObjZav[jmp.Obj].bParam[18] then
  begin // Ò‚ÂÚÓÙÓ Ì‡ ÏÂÒÚÌÓÏ ÛÔ‡‚ÎÂÌËË
    if not((ObjZav[jmp.Obj].ObjConstB[5] and (Rod = MarshP) and (Con.Pin = 1)) or
    (ObjZav[jmp.Obj].ObjConstB[6] and (Rod = MarshP) and (Con.Pin = 2)) or
    (ObjZav[jmp.Obj].ObjConstB[7] and (Rod = MarshM) and (Con.Pin = 1)) or
    (ObjZav[jmp.Obj].ObjConstB[8] and (Rod = MarshM) and (Con.Pin = 2))) then
    begin
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,232, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,232);
    end;
  end
  else result := trNextStep;

  if Con.Pin = 1 then
  begin // ¬‡Ê‰Â·ÌÓÒÚË ÔÓÔÛÚÌÓ„Ó
    case Rod of
      MarshP :
      begin
        if ObjZav[jmp.Obj].ObjConstB[5] then
        begin
          if ObjZav[jmp.Obj].bParam[5] and not
          (ObjZav[jmp.Obj].bParam[1] or
          ObjZav[jmp.Obj].bParam[2] or
          ObjZav[jmp.Obj].bParam[3] or
          ObjZav[jmp.Obj].bParam[4]) then // o
          begin // Ã‡¯ÛÚ ÌÂ ÔËÍ˚Ú Á‡ÔÂ˘‡˛˘ËÏ Ó„ÌÂÏ ÔÓÔÛÚÌÓ„Ó
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,115, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,115);
          end;
          result := trEndTrace;
        end else
        begin
          if ObjZav[jmp.Obj].bParam[1] or ObjZav[jmp.Obj].bParam[2] or ObjZav[jmp.Obj].bParam[6] or ObjZav[jmp.Obj].bParam[7] or ObjZav[jmp.Obj].bParam[21] then
          begin // ÓÚÍ˚Ú ‚‡Ê‰Â·Ì˚È ÒË„Ì‡Î
            result := trStop;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,114, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,114);
          end;
        end;

        if ObjZav[jmp.Obj].ObjConstB[19] then
        begin //  ÓÓÚÍËÈ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ ‰Îˇ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡
          if not ObjZav[jmp.Obj].bParam[4] then
          begin // Á‡Í˚Ú ÒË„Ì‡Î
            result := trStop;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,391, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,391);
          end;
        end;
      end;

      MarshM :
      begin
        if ObjZav[jmp.Obj].ObjConstB[7] then
        begin
          if ObjZav[jmp.Obj].bParam[5] and
          not (ObjZav[jmp.Obj].bParam[1] or
          ObjZav[jmp.Obj].bParam[2] or
          ObjZav[jmp.Obj].bParam[3] or
          ObjZav[jmp.Obj].bParam[4]) then // o
          begin // Ã‡¯ÛÚ ÌÂ ÔËÍ˚Ú Á‡ÔÂ˘‡˛˘ËÏ Ó„ÌÂÏ ÔÓÔÛÚÌÓ„Ó
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,115, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,115);
          end;
          result := trEndTrace;
        end else
        begin
          if ObjZav[jmp.Obj].bParam[3] or
          ObjZav[jmp.Obj].bParam[4] or
          ObjZav[jmp.Obj].bParam[8] or
          ObjZav[jmp.Obj].bParam[9] or
          ObjZav[jmp.Obj].bParam[21] then
          begin // ÓÚÍ˚Ú ‚‡Ê‰Â·Ì˚È ÒË„Ì‡Î
            result := trStop;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,114, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,114);
          end;
        end;

        if ObjZav[jmp.Obj].ObjConstB[20] then
        begin //  ÓÓÚÍËÈ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ ‰Îˇ Ï‡ÌÂ‚Ó‚Ó„Ó Ï‡¯ÛÚ‡
          if not ObjZav[jmp.Obj].bParam[2] then
          begin // Á‡Í˚Ú ÒË„Ì‡Î
            result := trStop;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,391, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,391);
          end;
        end;
      end;
      else result := trEnd;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd : result := trStop;
      end;
    end;
  end else
  begin // ¬‡Ê‰Â·ÌÓÒÚË ‚ÒÚÂ˜ÌÓ„Ó
    if ObjZav[jmp.Obj].bParam[1] or   // Ã—1
    ObjZav[jmp.Obj].bParam[2] or   // Ã—2
    ObjZav[jmp.Obj].bParam[3] or   // —1
    ObjZav[jmp.Obj].bParam[4] then // —2
    begin
      result := trStop;
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,114, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,114);
    end;

    case Rod of
      MarshP : if ObjZav[jmp.Obj].ObjConstB[6] then result := trEndTrace;
      MarshM : if ObjZav[jmp.Obj].ObjConstB[8] then result := trEndTrace;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trStop;
        LnkEnd :
        begin
          // Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          result := trEnd;
          InsMsg(Group,jmp.Obj,77);
        end;
      end;
    end;
  end;
end;
//========================================================================================
function StepSigFindIzvest(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//--------------------------------------------- ÔÓıÓ‰ ˜ÂÂÁ ÒË„Ì‡Î ÔË ÔÓËÒÍÂ ËÁ‚ÂÒÚËÚÂÎˇ
begin
  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else  result := trNextStep;
    end;
  end else
  begin //---------------------------------------- ÔÓ‚ÂËÚ¸ ÛÒÎÓ‚Ëˇ ‰Îˇ ÔÓÔÛÚÌÓ„Ó ÒË„Ì‡Î‡
    if ObjZav[jmp.Obj].bParam[2] or ObjZav[jmp.Obj].bParam[4] then  //---- Ò‚ÂÚÓÙÓ ÓÚÍ˚Ú
    inc(MarhTracert[Group].IzvCount)
    else
    if ObjZav[jmp.Obj].bParam[6] or
    ObjZav[jmp.Obj].bParam[7] or
    ObjZav[jmp.Obj].bParam[1] then
    begin //---------- ‚ÓÁ·ÛÊ‰ÂÌ ÔËÁÌ‡Í Ï‡ÌÂ‚Ó‚Ó„Ó Ì‡˜‡Î‡ ËÎË ÒË„Ì‡Î Ì‡ ‚˚‰ÂÊÍÂ ‚ÂÏÂÌË
      if not ObjZav[jmp.Obj].bParam[2] then
      begin //------------------------------------------------------------ Ò‚ÂÚÓÙÓ Á‡Í˚Ú
        result := trStop;
        exit;
      end;
      inc(MarhTracert[Group].IzvCount);
    end else
    if ObjZav[jmp.Obj].bParam[8] or
    ObjZav[jmp.Obj].bParam[9] or
    ObjZav[jmp.Obj].bParam[3] then
    begin //------------ ‚ÓÁ·ÛÊ‰ÂÌ ÔËÁÌ‡Í ÔÓÂÁ‰ÌÓ„Ó Ì‡˜‡Î‡ ËÎË ÒË„Ì‡Î Ì‡ ‚˚‰ÂÊÍÂ ‚ÂÏÂÌË
      if not ObjZav[jmp.Obj].bParam[4] then
      begin //------------------------------------------------------------ Ò‚ÂÚÓÙÓ Á‡Í˚Ú
        result := trStop;
        exit;
      end;
      inc(MarhTracert[Group].IzvCount);
    end;
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end;
end;
//========================================================================================
function StepSigFindIzvStrel(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
//----------- ÔÓıÓ‰ ˜ÂÂÁ ÒË„Ì‡Î ÔË ÔÓËÒÍÂ ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÓÍ Ì‡ ÔÂ‰Ï‡¯ÛÚÌÓÏ Û˜‡ÒÚÍÂ
begin
  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end else
  begin // ÔÓ‚ÂËÚ¸ ÛÒÎÓ‚Ëˇ ‰Îˇ ÔÓÔÛÚÌÓ„Ó ÒË„Ì‡Î‡
    if ((Rod = MarshM) and ObjZav[jmp.Obj].ObjConstB[3]) or
    ((Rod = MarshP) and (ObjZav[jmp.Obj].ObjConstB[2] or ObjZav[jmp.Obj].bParam[2])) then
    begin // Ò‚ÂÚÓÙÓ Ó„‡ÌË˜Ë‚‡ÂÚ ÔÂ‰Ï‡¯ÛÚÌ˚È Û˜‡ÒÚÓÍ
      result := trStop;
      exit;
    end
    else Con := ObjZav[jmp.Obj].Neighbour[1];

    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end;
end;
//========================================================================================
function StepSigPovtorMarh(var Con :TOZNeighbour; const Lvl :TTracertLevel; Rod :Byte;
Group :Byte; jmp :TOZNeighbour) : TTracertResult;
//--------------------- ‘ÛÌÍˆËˇ ÔÓıÓ‰‡ ˜ÂÂÁ ÒË„Ì‡Î ÔË ÍÓÏ‡Ì‰Â ÔÓ‚ÚÓÌÓÈ ‚˚‰‡˜Ë Ï‡¯ÛÚ‡
//------------------------------------ Con - ÍÓÌÌÂÍÚÓ, Ò ÍÓÚÓÓ„Ó Ú‡ÒÒ‡ ÔË¯Î‡ Ì‡ ÒË„Ì‡Î
//----------------------------------------------------- Lvl - ËÒÔÓÎÌˇÂÏ˚È ˝Ú‡Ô Ú‡ÒÒËÓ‚ÍË
//------------------------------------------------------- Rod - ‚Ë‰ Ú‡ÒÒËÛÂÏÓ„Ó Ï‡¯ÛÚ‡
//-------------------------------------------------------- Group - ÌÓÏÂ Ì‡·Ë‡ÂÏÓÈ Ú‡ÒÒ˚
//------------------------------------- jmp - ÒÓÒÂ‰, ÓÚ ÍÓÚÓÓ„Ó Ú‡ÒÒ˚ ÔË¯Î‡ Ì‡ Ò‚ÂÚÓÙÓ
//--- ‘”Õ ÷»ﬂ ¬Œ«¬–¿Ÿ¿≈“ –≈«”À‹“¿“ œ–Œ’Œ∆ƒ≈Õ»ﬂ ◊≈–≈« —»√Õ¿À »« ¬Œ«ÃŒ∆ÕŒ√Œ Õ¿¡Œ–¿ ¬¿–»¿Õ“Œ¬
var
  old_con : TOZNeighbour;
begin
  result := trNextStep; //------------ ËÁÌ‡˜‡Î¸ÌÓ Ò˜ËÚ‡ÂÚÒˇ, ˜ÚÓ Ú‡ÒÒ‡ ‰ÓÎÊÌ‡ Ë‰ÚË ‰‡Î¸¯Â
  old_con := Con;
  //------------------------------------ ÔÓ‚ÂˇÂÏ Ì‡ÎË˜ËÂ ÍÓÌˆÓ‚ Ï‡¯ÛÚÓ‚ ÔÂÂ‰ ÒË„Ì‡ÎÓÏ
  if Con.Pin = 1 then //-------------- ÂÒÎË ‚Ó¯ÎË Ì‡ ÒË„Ì‡Î ‚ ÚÓ˜ÍÂ 1 (ÔÓ‚ÂÍ‡ ÔÓÔÛÚÌÓ„Ó)
  begin
    case Rod of
      MarshP : //-------------------------------------------------- ‰Îˇ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡
        if ObjZav[jmp.Obj].ObjConstB[5] //------------- ÂÒÎË ‚ ÚÓ˜ÍÂ 1 ÂÒÚ¸ ÍÓÌÂˆ ÔÓÂÁ‰Ì˚ı
        then result := trEndTrace; //---------------------- ÚÓ„‰‡ ÂÁÛÎ¸Ú‡Ú = ÍÓÌÂˆ Ú‡ÒÒ˚
      MarshM : //------------------------------------------------ ‰Îˇ Ï‡ÌÂ‚Ó‚Ó„Ó Ï‡¯ÛÚ‡
        if ObjZav[jmp.Obj].ObjConstB[7] //----------- ÂÒÎË ‚ ÚÓ˜ÍÂ 1 ÂÒÚ¸ ÍÓÌÂˆ Ï‡ÌÂ‚Ó‚˚ı
        then result := trEndTrace; //---------------------- ÚÓ„‰‡ ÂÁÛÎ¸Ú‡Ú = ÍÓÌÂˆ Ú‡ÒÒ˚
      else  result := trEnd;    //---------------- ‰Îˇ ÌÓÔÂ‰ÂÎÂÌÌ˚ı Ï‡¯ÛÚÓ‚ Ò‡ÁÛ ÍÓÌÂˆ
    end;

    if result = trNextStep then //- ÂÒÎË ‚ ÚÓ˜ÍÂ 1 ÌÂ ·˚ÎÓ ÓÒÚ‡ÌÓ‚‡, Ë Ú‡ÒÒ‡ ÔÓ‰ÓÎÊ‡ÂÚÒˇ
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2]; //- ÔÓÎÛ˜ËÚ¸ ÌÓ‚˚È ÍÓÌÌÂÍÚÓ ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 2
      case Con.TypeJmp of
        LnkRgn : result := trStop; //----------------- ÂÒÎË ÔÓıÓ‰ ‚ ‰Û„ÓÈ ‡ÈÓÌ, ÚÓ ÒÚÓÔ
        LnkEnd : result := trStop; //---------------------- ÂÒÎË ÍÓÌÌÂÍÚÓ ÚÛÔËÍ‡, ÚÓ ÒÚÓÔ
      end;
    end;
  end else //--------- ÂÒÎË ‚Ó¯ÎË Ì‡ ÒË„Ì‡Î ‚ ÚÓ˜ÍÂ 2 ÔÓ‚ÂˇÂÏ Ì‡ÎË˜ËÂ ÍÓÌˆÓ‚ Á‡ ÒË„Ì‡ÎÓÏ
  begin
    case Rod of
      MarshP :
        if ObjZav[jmp.Obj].ObjConstB[5] or ObjZav[jmp.Obj].ObjConstB[6]
        then result := trEndTrace;//------------------------------ Ã ÍÓÌÂˆ ‚ ÚÓ˜ÍÂ 1 ËÎË 2

      MarshM :
        if ObjZav[jmp.Obj].ObjConstB[7] or ObjZav[jmp.Obj].ObjConstB[8]
        then result := trEndTrace;//------------------------------ œ ÍÓÌÂˆ ‚ ÚÓ˜ÍÂ 1 ËÎË 2
    end;
  end;
  Con := old_con;
  if result = trNextStep then //---------------------------- ÂÒÎË ÔÓ‰ÓÎÊ‡ÂÚÒˇ Ú‡ÒÒËÓ‚Í‡
  begin
    if Con.Pin = 1 then Con := ObjZav[jmp.Obj].Neighbour[2]
    else Con := ObjZav[jmp.Obj].Neighbour[1];

    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd :
      begin  //---------------------------------------------------- Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
        InsMsg(Group,jmp.Obj,77);
        result := trEnd;
      end;
    end;
  end;

end;
//========================================================================================
function StepSPforFindTrace(var Con:TOZNeighbour; const Lvl:TTracertLevel; Rod:Byte;
Group:Byte;jmp:TOZNeighbour):TTracertResult;
//--------------------------------------------- ÔÓıÓ‰ ˜ÂÂÁ —œ ÔË ÔÓËÒÍÂ Ú‡ÒÒ˚ Ï‡¯ÛÚ‡
begin
  if Con.Pin = 1 then  //------------------------------ ‚˚¯ÎË Ì‡ ÒÂÍˆË˛ ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 1
  begin
    case Rod of
      MarshP :
        if ObjZav[jmp.Obj].ObjConstB[1]   //---- ÂÒÎË ÂÒÚ¸ ÔÓÂÁ‰Ì˚Â ‚ Ì‡Ô‡‚ÎÂÌËË 1->2
        then result := trNextStep
        else result := trRepeat;

      MarshM :
        if ObjZav[jmp.Obj].ObjConstB[3]   //-- ÂÒÎË ÂÒÚ¸ Ï‡ÌÂ‚Ó‚˚Â ‚ Ì‡Ô‡‚ÎÂÌËË 1->2
        then result := trNextStep
        else result := trRepeat;

      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end else
  begin
    case Rod of
      MarshP :
        if ObjZav[jmp.Obj].ObjConstB[2]  //--------- ÂÒÎË ÂÒÚ¸ ÔÓÂÁ‰Ì˚Â ‚ Ì‡Ô‡‚ÎÂÌËË 2->1
        then result := trNextStep
        else result := trRepeat;

      MarshM :
        if ObjZav[jmp.Obj].ObjConstB[4]   //------ ÂÒÎË ÂÒÚ¸ Ï‡ÌÂ‚Ó‚˚Â ‚ Ì‡Ô‡‚ÎÂÌËË 2->1
        then result := trNextStep
        else result := trRepeat;

      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end;
end;
//========================================================================================
function StepSPforContTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if Con.Pin = 1 then
  begin
    case Rod of
      MarshP :
        if ObjZav[jmp.Obj].ObjConstB[1]  //--------- ÂÒÎË ÂÒÚ¸ ÔÓÂÁ‰Ì˚Â ‚ Ì‡Ô‡‚ÎÂÌËË 1->2
        then result := trNextStep
        else result := trStop;

      MarshM :
        if ObjZav[jmp.Obj].ObjConstB[3] //-------- ÂÒÎË ÂÒÚ¸ Ï‡ÌÂ‚Ó‚˚Â ‚ Ì‡Ô‡‚ÎÂÌËË 1->2
        then result := trNextStep
        else result := trEnd;

      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trStop;
      end;
    end;
    if result = trEnd then  MarhTracert[Group].ObjLast := jmp.Obj;
  end else
  begin
    case Rod of
      MarshP :
        if ObjZav[jmp.Obj].ObjConstB[2]then //-------ÂÒÎË ÂÒÚ¸ ÔÓÂÁ‰Ì˚Â ‚ Ì‡Ô‡‚ÎÂÌËË 2->1
        result := trNextStep
        else result := trStop;

      MarshM :
        if ObjZav[jmp.Obj].ObjConstB[4]//--------- ÂÒÎË ÂÒÚ¸ Ï‡ÌÂ‚Ó‚˚Â ‚ Ì‡Ô‡‚ÎÂÌËË 2->1
        then result := trNextStep
        else result := trEnd;

      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trStop;
      end;
    end;

    if result = trEnd then  MarhTracert[Group].ObjLast := jmp.Obj;

  end;
end;
//========================================================================================
function StepSPforZavTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end;
end;
//========================================================================================
function StepSPforCheckTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  tail : boolean;
  k : integer;
begin
  result := trNextStep;

  if not ObjZav[jmp.Obj].bParam[2] or //--------------------------------- ÂÒÎË "«" ËÎË ...
  (not MarhTracert[Group].Povtor and //------------- ÌÂÚ ÔËÁÌ‡Í‡ ÔÓ‚ÚÓÌÓÈ ÔÓ‚ÂÍË Ë ...
  (ObjZav[jmp.Obj].bParam[14] or //-------------------- ÂÒÚ¸ ÔÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ ËÎË ...
  not ObjZav[jmp.Obj].bParam[7])) then //------ ÔÂ‰‚‡ËÚÂÎ¸ÌÓÂ Á‡Ï˚Í‡ÌËÂ STAN ÛÒÚ‡ÌÓ‚ÎÂÌÓ
  begin
    result := trBreak;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,82); //---------------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
    MarhTracert[Group].GonkaStrel := false;
  end;

  if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then //- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
  begin
    result := trBreak;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,134, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,134); //--------------------------- ”˜‡ÒÚÓÍ $ Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
    MarhTracert[Group].GonkaStrel := false;
  end;

  //""""""""""""""""""""""""""""""" œ–Œ¬≈–»“‹ ¬¬≈ƒ≈ÕÕ€≈ Œ√–¿Õ»◊≈Õ»ﬂ """"""""""""""""""""""

  if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then //--- ÂÒÎË ›Î. Úˇ„‡
  begin
    if ObjZav[jmp.Obj].bParam[24] or ObjZav[jmp.Obj].bParam[27] then //----- «‡Í˚Ú ‰Îˇ ›“
    begin
      inc(MarhTracert[Group].WarCount);
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
      InsWar(Group,jmp.Obj,462); //------------------ «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
    end else
    if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
    begin
      if ObjZav[jmp.Obj].bParam[25] or ObjZav[jmp.Obj].bParam[28] then//«‡Í˚Ú ‰Îˇ ›“=
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,467);//------ «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓÒÚ. ÚÓÍ‡ ÔÓ $
      end;

      if ObjZav[jmp.Obj].bParam[26] or ObjZav[jmp.Obj].bParam[29] then//--- «‡Í˚Ú ‰Îˇ ›“~
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,472); //---- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÂÂÏ. ÚÓÍ‡ ÔÓ $
      end;
    end;
  end;

  if ObjZav[jmp.Obj].bParam[3] then //------------------------------------------------- –»
  begin
    result := trBreak;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,84, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,84); //----------- ¬˚ÔÓÎÌˇÂÚÒˇ ËÒÍÛÒÒÚ‚ÂÌÌÓÂ ‡ÁÏ˚Í‡ÌËÂ Û˜‡ÒÚÍ‡ $
    MarhTracert[Group].GonkaStrel := false;
  end;

  if not ObjZav[jmp.Obj].bParam[5] then //--------------------------------------------- Ã»
  begin
    result := trBreak;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,85, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,85);  //---------------------------- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
    MarhTracert[Group].GonkaStrel := false;
  end;

  case Rod of
    MarshP :
    begin
      if not ObjZav[jmp.Obj].bParam[1] then //-------------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
      begin
        result := trBreak;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
        InsMsg(Group,jmp.Obj,83);   //------------------------------------ ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
        MarhTracert[Group].GonkaStrel := false;
      end;
    end;

    MarshM :
    begin
      if not ObjZav[jmp.Obj].bParam[1] then //----------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡ —œ
      begin
        if ObjZav[jmp.Obj].ObjConstB[5] then  //---------------------------------- ÂÒÎË —œ
        begin
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,83); //------------------------------------ ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
          MarhTracert[Group].GonkaStrel := false;
        end else
        begin
          tail := false;

          for k := 1 to MarhTracert[Group].CIndex do
          if MarhTracert[Group].hTail = MarhTracert[Group].ObjTrace[k] then
          begin
            tail := true;
            break;
          end;

          if tail then  //-------------------------------------------- ÂÒÎË ÍÓÌÂˆ Ï‡¯ÛÚ‡
          begin
            MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83); //---------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
            result := trEnd;
          end else  //--------------------------------------- ÂÒÎË ÌÂ ‚ ÍÓÌˆÂ Ï‡¯ÛÚ‡
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83); //---------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
            result := trBreak;
            MarhTracert[Group].GonkaStrel := false;
          end;
        end;
      end;
    end;

    else
      result := trStop;
      exit; //------------------------------------ ÂÒÎË ÌÂ ÔÓÌˇÚÌ˚È Ï‡¯ÛÚ, ÚÓ ÔÂÍ‡ÚËÚ¸
  end;

  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end;
end;
//========================================================================================
function StepSPforZamykTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if not ObjZav[jmp.Obj].bParam[1] and    //--------------------- ÂÒÎË Á‡ÌˇÚ Û˜‡ÒÚÓÍ Ë ...
  not ObjZav[jmp.Obj].ObjConstB[5] and    //------------------------ ˝ÚÓÚ Û˜‡ÒÚÓÍ ”œ Ë ...
  (Rod = MarshM) then //----------------------------------------------- Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
  begin //---------------- ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ ‚ Ï‡ÌÂ‚Ó‚ÓÏ Ï‡¯ÛÚÂ Ó Á‡ÌˇÚÓÒÚË Û˜‡ÒÚÍ‡
    MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ ObjZav[jmp.Obj].Liter;
    MarhTracert[Group].FindTail := false;
  end;

  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      if ObjZav[jmp.Obj].bParam[2]
      then ObjZav[jmp.Obj].bParam[14] := true; //------------------------- ÔÓ„. Á‡Ï˚Í‡ÌËÂ

      ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart; //---------- ËÌ‰ÂÍÒ Ì‡˜‡Î‡
      ObjZav[jmp.Obj].iParam[2] := MarhTracert[Group].SvetBrdr; //------- ËÌ‰ÂÍÒ Ò‚ÂÚÓÙÓ‡

      if not ObjZav[jmp.Obj].ObjConstB[5] and //---------------------------- ÂÒÎË ”œ Ë ...
      (Rod = MarshM) then //------------------------------------------- Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
      begin //-------------------------------------------- ‰Îˇ ”œ ‚ Ï‡ÌÂ‚‡ı ‚ÓÁ·Û‰ËÚ¸ 1 Ã
        ObjZav[jmp.Obj].bParam[15] := true;  //--------------------------------------- 1 Ã
        ObjZav[jmp.Obj].bParam[16] := false; //--------------------------------------- 2 Ã
      end else
      begin //----------------------------------------------------------- ËÌ‡˜Â Ò·ÓÒ  ÃÓ‚
        ObjZav[jmp.Obj].bParam[15] := false; //--------------------------------------- 1 Ã
        ObjZav[jmp.Obj].bParam[16] := false; //--------------------------------------- 2 Ã
      end;
    end;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      if ObjZav[jmp.Obj].bParam[2] //--------------------- ÂÒÎË ÌÂÚ "«" ËÁ ÂÎÂÈÌ˚ı ‰‡ÌÌ˚ı
      then ObjZav[jmp.Obj].bParam[14] := true;  //---- ÚÓ ÛÒÚ‡ÌÓ‚ËÚ¸ ÔÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ

      ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart; //---------- ËÌ‰ÂÍÒ Ì‡˜‡Î‡
      ObjZav[jmp.Obj].iParam[2] := MarhTracert[Group].SvetBrdr; //------- ËÌ‰ÂÍÒ Ò‚ÂÚÓÙÓ‡

      if not ObjZav[jmp.Obj].ObjConstB[5] and (Rod = MarshM) then
      begin //-------------------------------------------- ‰Îˇ ”œ ‚ Ï‡ÌÂ‚‡ı ‚ÓÁ·Û‰ËÚ¸ 2 Ã
        ObjZav[jmp.Obj].bParam[15] := false; //--------------------------------------- 1 Ã
        ObjZav[jmp.Obj].bParam[16] := true;  //--------------------------------------- 2 Ã
      end else
      begin //----------------------------------------------------------------- Ò·ÓÒ  ÃÓ‚
        ObjZav[jmp.Obj].bParam[15] := false; //--------------------------------------- 1 Ã
        ObjZav[jmp.Obj].bParam[16] := false; //--------------------------------------- 2 Ã
      end;
    end;
  end;
end;
//========================================================================================
function StepSPSignalCirc(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  result := trNextStep;

  //""""""""""""""""""""""" Œ¡–¿¡Œ“ ¿ ¬¬≈ƒ≈ÕÕ€’ Œ√–¿Õ»◊≈Õ»… """"""""""""""""""""""""""""""
  if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then //-- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌ.
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,134, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,134); //--------------------------- ”˜‡ÒÚÓÍ $ Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
    result :=  trBreak;
  end;

  if ObjZav[jmp.Obj].ObjConstB[8] or  //----------------- ÂÒÎË ›“ ÔÂÂÏÂÌÌÓ„Ó ÚÓÍ‡ ËÎË ...
  ObjZav[jmp.Obj].ObjConstB[9] then   //------------------------------ ›“ ÔÓÒÚÓˇÌÌÓ„Ó ÚÓÍ‡
  begin
    if ObjZav[jmp.Obj].bParam[24] or //--- ÂÒÎË Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú. ‚ ¿–Ã ƒ—œ ËÎË
    ObjZav[jmp.Obj].bParam[27] then //---------------- Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú. ‚ STAN
    begin
      inc(MarhTracert[Group].WarCount);
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
      InsWar(Group,jmp.Obj,462); //------------------ «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
    end else
    if ObjZav[jmp.Obj].ObjConstB[8] and //------------------------- ‰Îˇ ÒÚ‡ÌˆËË ÒÚ˚ÍÓ‚‡ÌËˇ
    ObjZav[jmp.Obj].ObjConstB[9] then //--- ÂÒÎË ›“ ÔÂÂÏÂÌÌÓ„Ó ÚÓÍ‡ Ë ›“ ÔÓÒÚÓˇÌÌÓ„Ó ÚÓÍ‡
    begin
      if ObjZav[jmp.Obj].bParam[25] or //-------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú. ‚ ¿–Ã ƒ—œ
      ObjZav[jmp.Obj].bParam[28] then //------------ «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú. ‚ STAN
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,467); //-------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÓÒÚÓˇÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
      end;
      if ObjZav[jmp.Obj].bParam[26] or
      ObjZav[jmp.Obj].bParam[29] then //-------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,472); //-------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÂÂÏÂÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
      end;
    end;
  end;

  if ObjZav[jmp.Obj].bParam[3] then //------------------------------------------------- –»
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,84, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,84); //----------- ¬˚ÔÓÎÌˇÂÚÒˇ ËÒÍÛÒÒÚ‚ÂÌÌÓÂ ‡ÁÏ˚Í‡ÌËÂ Û˜‡ÒÚÍ‡ $
  end;

  if not ObjZav[jmp.Obj].bParam[5] then //--------------------------------------------- Ã»
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,85, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,85); //----------------------------- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
  end;

  if Rod = MarshP then
  begin
    if not ObjZav[jmp.Obj].bParam[1] then //---------------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
    begin
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,83); //---------------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
    end;
  end;

  if Con.Pin = 1 then
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[1] then   //----- ÌÂÚ ÔÓÂÁ‰Ì˚ı ‚ Ì‡Ô‡‚ÎÂÌËË 1->2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,161, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,161); //----------------------- ÕÂÚ ÔÓÂÁ‰Ì˚ı Ï‡¯ÛÚÓ‚ ÔÓ $
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[3] then  //---- ÌÂÚ Ï‡ÌÂ‚Ó‚˚ı ‚ Ì‡Ô‡‚ÎÂÌËË 1->2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,162, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,162);  //-------------------- ÕÂÚ Ï‡ÌÂ‚Ó‚˚ı Ï‡¯ÛÚÓ‚ ÔÓ $
        end;

        if not ObjZav[jmp.Obj].bParam[1] then //------------------------ Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
        begin
          if ObjZav[jmp.Obj].bParam[15] then //--------------------------------------- 1 Ã
          begin
            MarhTracert[Group].TailMsg :=' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83); //---------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83);
          end;
        end;
      end;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;

  end else //-------------------------------------------------------- ÂÒÎË ‚Ó¯ÎË ‚ ÚÓ˜ÍÛ 2
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[2] then //-------- ÂÒÎË ÌÂÚ ÔÓÂÁ‰Ì˚ı ‚ Ì‡Ô. 1<-2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,161, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,161);  //---------------------- ÕÂÚ ÔÓÂÁ‰Ì˚ı Ï‡¯ÛÚÓ‚ ÔÓ $
        end;
      end;

      MarshM :
      begin

        if not ObjZav[jmp.Obj].ObjConstB[4] then    //ÂÒÎË ÌÂÚ Ï‡ÌÂ‚Ó‚˚ı ‚ Ì‡Ô‡‚Î. 1<-2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,162, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,162); //--------------------- ÕÂÚ Ï‡ÌÂ‚Ó‚˚ı Ï‡¯ÛÚÓ‚ ÔÓ $
        end;

        if not ObjZav[jmp.Obj].bParam[1] then
        begin //-------------------------------------------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
          if ObjZav[jmp.Obj].bParam[16] then //--------------------------------------- 2 Ã
          begin
            MarhTracert[Group].TailMsg :=' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83);
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83);
          end;
        end;

      end;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end;
end;
//========================================================================================
function StepSPOtmenaMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  sosed : integer;
begin
  if Con.Pin = 1 then  sosed := 2
  else sosed := 1;

  Con := ObjZav[jmp.Obj].Neighbour[sosed];
  case Con.TypeJmp of
    LnkRgn : result := trEnd;
    LnkEnd : result := trStop;
    else  result := trNextStep;
  end;

  if result = trNextStep then
  begin
    ObjZav[jmp.Obj].bParam[14] := false; //------------------------------- ÔÓ„. Á‡Ï˚Í‡ÌËÂ
    ObjZav[jmp.Obj].bParam[8]  := true;  //---------------------------------------- Ú‡ÒÒ‡
    ObjZav[jmp.Obj].iParam[1]  := 0;
    ObjZav[jmp.Obj].iParam[2]  := 0;
    ObjZav[jmp.Obj].bParam[15] := false; //------------------------------------------- 1 Ã
    ObjZav[jmp.Obj].bParam[16] := false; //------------------------------------------- 2 Ã
  end;
end;
//========================================================================================
function StepSPRazdelSign(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  result := trNextStep;
  if not ObjZav[jmp.Obj].bParam[2] then //--------------------------------- Á‡Ï˚Í‡ÌËÂ ÂÒÚ¸
  begin
    if ObjZav[jmp.Obj].ObjConstB[5] then //----------------------------------- ÂÒÎË ˝ÚÓ —œ
    begin //--------------------------------------------------- —œ - ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
      inc(MarhTracert[Group].WarCount);
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
      InsWar(Group,jmp.Obj,82);   //------------------------------------ ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
    end else
    begin //--------------------------------------------------------------------------- ”œ
      case Rod of
        MarshP :
        begin
          if not ObjZav[jmp.Obj].bParam[15] and
          not ObjZav[jmp.Obj].ObjConstB[16] then //------------------------------ ÌÂÚ  ÃÓ‚
          begin //-------------------------------------------------- ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,82); //-------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
          end else
          begin //----------------------------------------------------------- ‚‡Ê‰Â·ÌÓÒÚ¸
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,82); //-------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
          end;
        end;

        MarshM :
        begin
          if Con.Pin = 1 then
          begin
            if ObjZav[jmp.Obj].bParam[15] and
            not ObjZav[jmp.Obj].ObjConstB[16] then //-------------------- ÂÒÚ¸ 1 Ã ÌÂÚ 2 Ã
            begin //------------------------------------------------ ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,82); //------------------------------ ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
            end else
            begin //--------------------------------------------------------- ‚‡Ê‰Â·ÌÓÒÚ¸
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
              InsMsg(Group,jmp.Obj,82); //------------------------------ ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
            end;
          end else
          begin
            if not ObjZav[jmp.Obj].bParam[15] and
            ObjZav[jmp.Obj].ObjConstB[16] then //------------------------ ÂÒÚ¸ 2 Ã ÌÂÚ 1 Ã
            begin //------------------------------------------------ ‚˚‰‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,82); //------------------------------ ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
            end else
            begin //--------------------------------------------------------- ‚‡Ê‰Â·ÌÓÒÚ¸
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
              InsMsg(Group,jmp.Obj,82); //------------------------------ ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
            end;
          end;
        end;

        else
          inc(MarhTracert[Group].MsgCount); //------------------------------- ‚‡Ê‰Â·ÌÓÒÚ¸
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,82); //---------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
      end;
    end;
  end;

  if not ObjZav[jmp.Obj].bParam[7] or
  ObjZav[jmp.Obj].bParam[14] then //-------------------------------- ÔÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,82); //---------------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ
  end;

  if ObjZav[jmp.Obj].bParam[12] or
  ObjZav[jmp.Obj].bParam[13] then //------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ ‚ ¿–Ã ƒ—œ ËÎË ‚ STAN
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,134, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,134);
  end;

  if ObjZav[jmp.Obj].ObjConstB[8] or
  ObjZav[jmp.Obj].ObjConstB[9] then //---------------------- ÂÒÎË Û˜‡ÒÚÓÍ ˝ÎÂÍÚËÙËˆËÓ‚‡Ì
  begin
    if ObjZav[jmp.Obj].bParam[24] or
    ObjZav[jmp.Obj].bParam[27] then //----------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú.
    begin
      inc(MarhTracert[Group].WarCount);         //------------------------- ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
      InsWar(Group,jmp.Obj,462);  //----------------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
    end else
    if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then //----- Ó·Â Úˇ„Ë
    begin
      if ObjZav[jmp.Obj].bParam[25] or
      ObjZav[jmp.Obj].bParam[28] then //------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);       //------------------------- ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,467);//--------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÓÒÚÓˇÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
      end;

      if ObjZav[jmp.Obj].bParam[26] or
      ObjZav[jmp.Obj].bParam[29] then //-------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);       //------------------------- ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,472); //-------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÂÂÏÂÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
      end;
    end;
  end;

  if ObjZav[jmp.Obj].bParam[3] then //------------------------------------------------- –»
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,84, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,84);
  end;

  if not ObjZav[jmp.Obj].bParam[5] then //--------------------------------------------- Ã»
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,85, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,85); //----------------------------- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
  end;

  if Con.Pin = 1 then
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].bParam[1] then //------------------------ Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,83);  //----------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
        end;

        if not ObjZav[jmp.Obj].ObjConstB[1] then //------- ÌÂÚ ÔÓÂÁ‰Ì˚ı ‚ Ì‡Ô‡‚ÎÂÌËË 1->2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,161, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,161); //----------------------- ÕÂÚ ÔÓÂÁ‰Ì˚ı Ï‡¯ÛÚÓ‚ ÔÓ $
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[3] then
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,162, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,162); //--------------------- ÕÂÚ Ï‡ÌÂ‚Ó‚˚ı Ï‡¯ÛÚÓ‚ ÔÓ $
        end;

        if not ObjZav[jmp.Obj].bParam[1] then
        begin //-------------------------------------------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
          if not ObjZav[jmp.Obj].ObjConstB[5] then //---------------------------------- ”œ
          begin
            MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83); //---------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83);
          end;
        end;
      end;
    end;

    if result = trNextStep then
    begin
      ObjZav[jmp.Obj].bParam[8] := false;
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end else
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].bParam[1] then //------------------------ Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,83);
        end;

        if not ObjZav[jmp.Obj].ObjConstB[2] then
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,161, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,161);   //--------------------- ÕÂÚ ÔÓÂÁ‰Ì˚ı Ï‡¯ÛÚÓ‚ ÔÓ $
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[4] then
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,162, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,162); //----------------- ÕÂÚ Ï‡ÌÂ‚Ó‚˚ı Ï‡¯ÛÚÓ‚ ÔÓ $
        end;

        if not ObjZav[jmp.Obj].bParam[1] then
        begin //-------------------------------------------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
          if not ObjZav[jmp.Obj].ObjConstB[5] then //---------------------------------- ”œ
          begin
            MarhTracert[Group].TailMsg :=' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83);
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83);
          end;
        end;
      end;
    end;

    if result = trNextStep then
    begin
      ObjZav[jmp.Obj].bParam[8] := false;
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end;
end;
//========================================================================================
function StepSPPovtorRazdel(var Con : TOZNeighbour; const Lvl : TTracertLevel;
Rod : Byte; Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  result := trNextStep;
  if not ObjZav[jmp.Obj].bParam[2] then //-------------------------------------- Á‡Ï˚Í‡ÌËÂ
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,82);
  end;

  if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then//- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ.
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,134, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,134);  //-------------------------- ”˜‡ÒÚÓÍ $ Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
  end;

  if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then  //-------- ÂÒÎË ›“
  begin
    if ObjZav[jmp.Obj].bParam[24] or
    ObjZav[jmp.Obj].bParam[27] then //----------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú.
    begin
      inc(MarhTracert[Group].WarCount);
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
      InsWar(Group,jmp.Obj,462); //------------------ «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
    end else
    if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
    begin
      if ObjZav[jmp.Obj].bParam[25] or
      ObjZav[jmp.Obj].bParam[28] then //------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,467);
      end;

      if ObjZav[jmp.Obj].bParam[26] or
      ObjZav[jmp.Obj].bParam[29] then //-------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,472);
      end;
    end;
  end;

  if ObjZav[jmp.Obj].bParam[3] then //------------------------------------------------- –»
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,84, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,84);  //---------- ¬˚ÔÓÎÌˇÂÚÒˇ ËÒÍÛÒÒÚ‚ÂÌÌÓÂ ‡ÁÏ˚Í‡ÌËÂ Û˜‡ÒÚÍ‡ $
  end;

  if not ObjZav[jmp.Obj].bParam[5] then //----------------------------------------- Ã»
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,85, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,85);  //---------------------------- ”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
  end;

  if Con.Pin = 1 then //--------------------------------------------- ÂÒÎË ‚Ó¯ÎË ‚ ÚÓ˜ÍÛ 1
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].bParam[1] then //------------------------ Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,83);  //----------------------------------- ”˜‡ÒÚÓÍ $ Á‡ÌˇÚ
        end;

        if not ObjZav[jmp.Obj].ObjConstB[1] then //------- ÌÂÚ ÔÓÂÁ‰Ì˚ı ‚ Ì‡Ô‡‚ÎÂÌËË 1->2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,161, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,161); //--------------------- "ÕÂÚ ÔÓÂÁ‰Ì˚ı Ï‡¯ÛÚÓ‚ ÔÓ $"
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[5] //-------------------------------- ÂÒÎË ˝ÚÓ ”œ
        then ObjZav[jmp.Obj].bParam[15] := true; //----------------------------------- 1ÍÏ

        if not ObjZav[jmp.Obj].ObjConstB[3] then  //---- ÌÂÚ Ï‡ÌÂ‚Ó‚˚ı ‚ Ì‡Ô‡‚ÎÂÌËË 1->2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,162, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,162); //--------------------- ÕÂÚ Ï‡ÌÂ‚Ó‚˚ı Ï‡¯ÛÚÓ‚ ÔÓ $
        end;

        if not ObjZav[jmp.Obj].bParam[1] then
        begin //-------------------------------------------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
          if ObjZav[jmp.Obj].bParam[15] then //--------------------------------------- 1 Ã
          begin
            MarhTracert[Group].TailMsg :=' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83);
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83);
          end;
        end;
      end;
    end;

    if result = trNextStep then
    begin
      ObjZav[jmp.Obj].bParam[8] := false;
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end else //-------------------------------------------------------- ÂÒÎË ‚Ó¯ÎË ‚ ÚÓ˜ÍÛ 2
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].bParam[1] then //------------------------ Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,83);
        end;

        if not ObjZav[jmp.Obj].ObjConstB[2] then
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,161, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,161); //--------------------- "ÕÂÚ ÔÓÂÁ‰Ì˚ı Ï‡¯ÛÚÓ‚ ÔÓ $"
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[5]
        then ObjZav[jmp.Obj].bParam[16] := true;

        if not ObjZav[jmp.Obj].ObjConstB[4] then
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,162, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,162); //------------------- "ÕÂÚ Ï‡ÌÂ‚Ó‚˚ı Ï‡¯ÛÚÓ‚ ÔÓ $"
        end;

        if not ObjZav[jmp.Obj].bParam[1] then
        begin //-------------------------------------------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
          if ObjZav[jmp.Obj].bParam[16] then //--------------------------------------- 1 Ã
          begin
            MarhTracert[Group].TailMsg :=' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83);
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83);
          end;
        end;
      end;
    end;

    if result = trNextStep then
    begin
      ObjZav[jmp.Obj].bParam[8] := false;
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end;
end;
//========================================================================================
//----------------------------------------------------------- Ú‡ÒÒËÓ‚Í‡ ÔË ‡‚ÚÓ‰ÂÈÒÚ‚ËË
function StepSPAutoTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  result := trNextStep;

  if not ObjZav[jmp.Obj].bParam[2] {or not ObjZav[jmp.Obj].bParam[7]} then //--- Á‡Ï˚Í‡ÌËÂ
  exit;
  {
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,82, ObjZav[jmp.Obj].Liter,1); //---------------------- "”˜‡ÒÚÓÍ $ Á‡ÏÍÌÛÚ"
    InsMsg(Group,jmp.Obj,82);
  end;
  }
  if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then //---- «‡Í˚Ú ‰Îˇ ‰‚ËÊ.
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,134, ObjZav[jmp.Obj].Liter,1); //------- "”˜‡ÒÚÓÍ $ Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ"
    InsMsg(Group,jmp.Obj,134);
  end;

  if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then
  begin
    if ObjZav[jmp.Obj].bParam[24] or
    ObjZav[jmp.Obj].bParam[27] then //----------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú.
    begin
      inc(MarhTracert[Group].WarCount);
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
      InsWar(Group,jmp.Obj,462);//------------------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
    end else
    if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
    begin
      if ObjZav[jmp.Obj].bParam[25] or
      ObjZav[jmp.Obj].bParam[28] then //------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,467);
      end;

      if ObjZav[jmp.Obj].bParam[26] or
      ObjZav[jmp.Obj].bParam[29] then //-------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,472);
      end;
    end;
  end;

  if ObjZav[jmp.Obj].bParam[3] then //------------------------------------------------- –»
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,84, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,84);//---------- "¬˚ÔÓÎÌˇÂÚÒˇ ËÒÍÛÒÒÚ‚ÂÌÌÓÂ ‡ÁÏ˚Í‡ÌËÂ Û˜‡ÒÚÍ‡ $"
  end;

  if not ObjZav[jmp.Obj].bParam[5] then //--------------------------------------------- Ã»
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,85, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,85);
  end;

  if Con.Pin = 1 then
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].bParam[1] then //------------------------ Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
        begin
          exit;
          {
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);  //--------------- "”˜‡ÒÚÓÍ $ Á‡ÌˇÚ"
          InsMsg(Group,jmp.Obj,83);
          }
        end;

        if not ObjZav[jmp.Obj].ObjConstB[1] then   //------------------- ÌÂÚ ÔÓÂÁ‰Ì˚ı 1->2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,161, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,161); //--------------------- "ÕÂÚ ÔÓÂÁ‰Ì˚ı Ï‡¯ÛÚÓ‚ ÔÓ $"
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[5] then ObjZav[jmp.Obj].bParam[15] := true;

        if not ObjZav[jmp.Obj].ObjConstB[3] then  //------------------ ÌÂÚ Ï‡ÌÂ‚Ó‚˚ı 1->2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,162, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,162); //------------------- "ÕÂÚ Ï‡ÌÂ‚Ó‚˚ı Ï‡¯ÛÚÓ‚ ÔÓ $"
        end;

        if not ObjZav[jmp.Obj].bParam[1] then
        begin //-------------------------------------------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
          if ObjZav[jmp.Obj].bParam[15] then //--------------------------------------- 1 Ã
          begin
            MarhTracert[Group].TailMsg :=' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83);    //----------------------------- "”˜‡ÒÚÓÍ $ Á‡ÌˇÚ"
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83);    //----------------------------- "”˜‡ÒÚÓÍ $ Á‡ÌˇÚ"
          end;
        end;
      end;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end else
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].bParam[1] then //------------------------ Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
        begin
          exit;
          {
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,83);       //---------------------------- "”˜‡ÒÚÓÍ $ Á‡ÌˇÚ"
          }
        end;
        if not ObjZav[jmp.Obj].ObjConstB[2] then    //---------------- ÌÂÚ ÔÓÂÁ‰Ì˚ı 1 <- 2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,161, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,161);
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[5] then ObjZav[jmp.Obj].bParam[16] := true;

        if not ObjZav[jmp.Obj].ObjConstB[4] then   //--------------- ÌÂÚ Ï‡ÌÂ‚Ó‚˚ı 1 <- 2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,162, ObjZav[jmp.Obj].Liter,1); InsMsg(Group,jmp.Obj,162);
        end;

        if not ObjZav[jmp.Obj].bParam[1] then
        begin //-------------------------------------------------------- Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡
          if ObjZav[jmp.Obj].bParam[16] then //--------------------------------------- 1 Ã
          begin
            MarhTracert[Group].TailMsg :=' Ì‡ Á‡ÌˇÚ˚È Û˜‡ÒÚÓÍ '+ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,83); //-------------------------------- "”˜‡ÒÚÓÍ $ Á‡ÌˇÚ"
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,83, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,83);  //------------------------------- "”˜‡ÒÚÓÍ $ Á‡ÌˇÚ"
          end;
        end;
      end;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end;
end;
//========================================================================================
function StepSPFindIzvest(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if not ObjZav[jmp.Obj].bParam[1] then
  begin //------------------------------------------------------------------ Û˜‡ÒÚÓÍ Á‡ÌˇÚ
    result := trBreak;
    exit;
  end else
  if ObjZav[jmp.Obj].bParam[2] then
  begin //-------------------------------------------------- Û˜‡ÒÚÓÍ ÌÂ Á‡ÏÍÌÛÚ ‚ Ï‡¯ÛÚÂ
    if not((MarhTracert[Group].IzvCount = 0) and (MarhTracert[Group].Rod = MarshM)) then
    begin
      result := trStop;
      exit;
    end;
  end;

  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end;
end;
//========================================================================================
function StepSPFindIzvStrel(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if not ObjZav[jmp.Obj].bParam[1] then
  begin //------------------------------------------------------------------ Û˜‡ÒÚÓÍ Á‡ÌˇÚ
    MarhTracert[Group].IzvStrFUZ := true;
    if ObjZav[jmp.Obj].ObjConstB[5] then
    begin //-------------------------------------------------- ÂÒÎË —œ - ÔÓ‚ÂËÚ¸ ÒÚÂÎÍË
      if ObjZav[jmp.Obj].bParam[2] or
      MarhTracert[Group].IzvStrNZ then //------------------------------ Û˜‡ÒÚÓÍ ÌÂ Á‡ÏÍÌÛÚ
      MarhTracert[Group].IzvStrUZ := true;

      if MarhTracert[Group].IzvStrNZ then //------------------------ ÂÒÚ¸ ÒÚÂÎÍË ‚ Ú‡ÒÒÂ
      begin //------------------- ÒÓÓ·˘ËÚ¸ ÓÔÂ‡ÚÓÛ Ó ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı ÔÂÂ‰ ÒË„Ì‡ÎÓÏ
        result := trStop;
        exit;
      end;
    end else
    begin //-------------------------------- ÂÒÎË ”œ - ÔÓ‚ÂËÚ¸ Ì‡ÎË˜ËÂ ÒÚÂÎÓÍ ÔÓ Ú‡ÒÒÂ
      if MarhTracert[Group].IzvStrNZ then
      begin //---- ÂÒÚ¸ ÒÚÂÎÍË - ÒÓÓ·˘ËÚ¸ ÓÔÂ‡ÚÓÛ Ó ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı ÔÂÂ‰ ÒË„Ì‡ÎÓÏ
        MarhTracert[Group].IzvStrUZ := true;
        result := trStop;
        exit;
      end;
    end;
  end else
  if MarhTracert[Group].IzvStrFUZ then
  begin//-- Û˜‡ÒÚÓÍ Ò‚Ó·Ó‰ÂÌ Ë ·˚Î‡ Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡ ÔÂÂ‰ ÌËÏ-ÌÂ ‚˚‰‡‚‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
    MarhTracert[Group].IzvStrUZ := false;
    result := trStop;
    exit;
  end;

  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end;
end;
//========================================================================================
function StepSPPovtorMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  sosed : integer;
begin

  if Con.Pin = 1 then sosed := 2
  else sosed := 1;

  if not ObjZav[jmp.Obj].bParam[14] and //--------------- ÌÂÚ ÔÓ„‡ÏÏÌÓ„Ó Á‡Ï˚Í‡ÌËˇ Ë ...
  ObjZav[jmp.Obj].bParam[7] then //------------------------ ÌÂÚ ÔÂ‰‚‡ËÚÂÎ¸ÌÓ„Ó Á‡Ï˚Í‡ÌËˇ
  begin //------------------------------------------------------ ‡ÁÛ¯ÂÌ‡ Ú‡ÒÒ‡ Ï‡¯ÛÚ‡
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,228, ObjZav[MarhTracert[Group].ObjStart].Liter,1);
    InsMsg(Group,jmp.Obj,228);
    result := trStop;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[sosed];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end;
end;
//========================================================================================
function StepPutFindTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel; Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if Con.Pin = 1 then //------------------------------------ ÂÒÎË ‚Ó¯ÎË ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 1
  begin
    case Rod of
      MarshP :  //--------------------------------------------------------------- ÔÓÂÁ‰ÌÓÈ
        if ObjZav[jmp.Obj].ObjConstB[1] //------------------------ ÂÒÎË ÂÒÚ¸ ÔÓÂÁ‰Ì˚Â 1->2
        then result := trNextStep //--------------------------- ÔÂÂÈÚË Ì‡ ÒÎÂ‰Û˘ËÈ Ó·˙ÂÍÚ
        else result := trRepeat; //--------------- ÌÂÚ 1->2,  ‚ÓÁ‚‡Ú Í ÔÂ‰˚‰Û˘ÂÈ ÒÚÂÎÍÂ

      MarshM ://--------------------------------------------------------------- Ï‡ÌÂ‚Ó‚˚È
        if ObjZav[jmp.Obj].ObjConstB[3]//----------------------- ÂÒÎË ÂÒÚ¸ Ï‡ÌÂ‚Ó‚˚Â 1->2
        then result := trNextStep //--------------------------- ÔÂÂÈÚË Ì‡ ÒÎÂ‰Û˘ËÈ Ó·˙ÂÍÚ
        else result := trRepeat; //--------------- ÌÂÚ 1->2,  ‚ÓÁ‚‡Ú Í ÔÂ‰˚‰Û˘ÂÈ ÒÚÂÎÍÂ

      else  result := trNextStep; //----------------------- Ï‡¯ÛÚ‡ ÌÂÚ ÔÓ‰ÓÎÊËÚ¸ ‰‡Î¸¯Â
    end;

    if result = trNextStep then  //------------------------------- ÂÒÎË ÔÓ‰ÓÎÊÂÌËÂ ‰‡Î¸¯Â
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2]; //----------------------- ÍÓÌÌÂÍÚÓ Á‡ ÚÓ˜ÍÓÈ 2
      case Con.TypeJmp of
        LnkRgn : result := trRepeat; //-------- ÍÓÌÂˆ ‡ÈÓÌ‡, ‚ÓÁ‚‡Ú Í ÔÂ‰˚‰Û˘ÂÈ ÒÚÂÎÍÂ
        LnkEnd : result := trRepeat;
      end;
    end;
  end else
  begin //---------------------------------------------- ÂÒÎË ‚Ó¯ÎË ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 2
    case Rod of
      MarshP : //------------------------------------------------------- ÂÒÎË ÔÓÂÁ‰ÌÓÈ
        if ObjZav[jmp.Obj].ObjConstB[2]
        then result := trNextStep
        else result := trRepeat;

      MarshM :
        if ObjZav[jmp.Obj].ObjConstB[4]
        then result := trNextStep
        else result := trRepeat;

      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trRepeat;
        LnkEnd : result := trRepeat;
      end;
    end;
  end;
end;
//========================================================================================
function StepPutContTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if Con.Pin = 1 then //--------------------------------- ‚˚¯ÎË Ì‡ ÔÛÚ¸ ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 1
  begin
    case Rod of
      MarshP :
        if ObjZav[jmp.Obj].ObjConstB[1] then result := trNextStep
        else result := trStop;
      MarshM :
        if ObjZav[jmp.Obj].ObjConstB[3] then result := trNextStep
        else result := trStop;
      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[2];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trStop;
      end;
    end;
  end else   //------------------------------------------ ‚˚¯ÎË Ì‡ ÔÛÚ¸ ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 2
  begin
    case Rod of
      MarshP :
        if ObjZav[jmp.Obj].ObjConstB[2] then result := trNextStep
        else result := trStop;

      MarshM :
        if ObjZav[jmp.Obj].ObjConstB[4] then result := trNextStep
        else result := trStop;

      else result := trNextStep;
    end;

    if result = trNextStep then
    begin
      Con := ObjZav[jmp.Obj].Neighbour[1];
      case Con.TypeJmp of
        LnkRgn : result := trEnd;
        LnkEnd : result := trStop;
        LnkNecentr : result := trEndTrace;
      end;
    end;
  end;
end;
//========================================================================================
function StepPutZavTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  sosed : integer;
begin
  if Con.Pin = 1 then sosed := 2
  else sosed := 1;
  Con := ObjZav[jmp.Obj].Neighbour[sosed];
  case Con.TypeJmp of
    LnkRgn : result := trEnd;
    LnkEnd : result := trStop;
    else result := trNextStep;
  end;
end;
//========================================================================================
function StepPutCheckTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  tail,Chi,Ni,ChKM,NKM : boolean;
  k,UTS,sosed,Put : integer;
begin
  if Con.Pin = 1 then sosed := 2
  else sosed := 1;
  Put := jmp.Obj;
  Chi := not ObjZav[Put].bParam[2];
  Ni :=  not ObjZav[Put].bParam[3];
  ChKM := ObjZav[Put].bParam[4];
  NKM :=  ObjZav[Put].bParam[15];
  UTS := ObjZav[Put].BaseObject;
  result := trNextStep;
  //--------------------------------------------------------------- ÂÒÎË ‰Îˇ ÔÛÚË ÂÒÚ¸ ”“—
  if UTS > 0 then
  begin //------------------------------------------------------------------ œÓ‚ÂËÚ¸ ”“—
    case Rod of
      MarshP :
      begin
        if ObjZav[UTS].bParam[2] then
        begin //---------------------------------------------------------- ÛÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,108, ObjZav[Put].Liter,1);
          InsMsg(Group,Put,108);  //---------------------- "”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ"
          MarhTracert[Group].GonkaStrel := false;
        end else
        if not ObjZav[UTS].bParam[1] and not ObjZav[UTS].bParam[3] then
        begin //--------------------------- ÛÔÓ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ Ë ÌÂ ÓÚÍÎ˛˜ÂÌ
          result := trBreak;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,109, ObjZav[Put].Liter,1);
          InsMsg(Group,Put,109);//------- "“ÓÏÓÁÌÓÈ ÛÔÓ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ"
          MarhTracert[Group].GonkaStrel := false;
        end;
      end;

      MarshM :
      begin
        if not ObjZav[UTS].bParam[1] and ObjZav[UTS].bParam[2] and
        not ObjZav[UTS].bParam[3] then
        begin //-------------------------------------------- ÛÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ Ë ÌÂ ‚˚ÍÎ˛˜ÂÌ
          if not ObjZav[Put].bParam[1] then
          begin //------------------------------------------------------------- ÔÛÚ¸ Á‡ÌˇÚ
            if not ObjZav[UTS].bParam[27] then
            begin //------------------------------------------- ÒÓÓ·˘ÂÌËÂ ÌÂ Á‡ÙËÍÒËÓ‚‡ÌÓ
              ObjZav[ObjZav[Put].BaseObject].bParam[27] := true;
              result := trBreak;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,108, ObjZav[Put].Liter,1);
              InsWar(Group,Put,108);  //------------------ "”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ"
            end;
          end else
          begin //---------------------------------------------------------- ÔÛÚ¸ Ò‚Ó·Ó‰ÂÌ
            result := trBreak;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,108, ObjZav[Put].Liter,1);
            InsMsg(Group,Put,108);  //-------------------- "”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ"
            MarhTracert[Group].GonkaStrel := false;
          end;
        end;
      end;
    end;
  end;

  if ObjZav[Put].bParam[12] or ObjZav[Put].bParam[13] then //- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
  begin
    result := trBreak;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,135, ObjZav[Put].Liter,1);
    InsMsg(Group,Put,135); //------------------------------ œÛÚ¸ $ Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
    MarhTracert[Group].GonkaStrel := false;
  end;

  if ObjZav[Put].ObjConstB[8] or ObjZav[Put].ObjConstB[9] then //--------- ÂÒÎË ›“
  begin
    if ObjZav[Put].bParam[24]
    or ObjZav[Put].bParam[27] then //-------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ˝Î.Ú.
    begin
      inc(MarhTracert[Group].WarCount);
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,462, ObjZav[Put].Liter,1);
      InsWar(Group,Put,462); //------------------ «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
    end else
    if ObjZav[Put].ObjConstB[8] and ObjZav[Put].ObjConstB[9] then
    begin
      if ObjZav[Put].bParam[25] or
      ObjZav[Put].bParam[28] then //------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÓÒÚ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,467, ObjZav[Put].Liter,1); InsWar(Group,Put,467);
      end;

      if ObjZav[Put].bParam[26] or
      ObjZav[Put].bParam[29] then //-------------------- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ Ì‡ ÔÂ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,472, ObjZav[Put].Liter,1);
        InsWar(Group,Put,472); //-------------------------  ÓÌÂˆ ÍÓÌÚ‡ÍÚÌÓÈ ÔÓ‰‚ÂÒÍË $
      end;
    end;
  end;

  case Rod of
    MarshP : //---------------------------------------------------- ‰Îˇ ÔÓÂÁ‰ÌÓ„Ó Ï‡¯ÛÚ‡
    begin
      if not MarhTracert[Group].Povtor and   //---------- ÂÒÎË ÌÂ ÔÓ‚ÚÓÌ‡ˇ ÔÓ‚ÂÍ‡ Ë ...
      (ObjZav[Put].bParam[14] or  //--------------- ÔÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ ËÎË ...
      not ObjZav[Put].bParam[7] or //-------- ÔÂ‰‚‡ËÚÂÎ¸ÌÓÂ Á‡Ï˚Í‡ÌËÂ ˜ÂÚÌÓÂ ËÎË ...
      not ObjZav[Put].bParam[11]) then //---------- ÔÂ‰‚‡ËÚÂÎ¸ÌÓÂ Á‡Ï˚Í‡ÌËÂ ÌÂ˜ÂÚÌÓÂ
      begin
        result := trBreak;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,110, ObjZav[Put].Liter,1);
        InsMsg(Group,Put,110);
        MarhTracert[Group].GonkaStrel := false;
      end;

      if not (ObjZav[Put].bParam[1] and ObjZav[Put].bParam[16]) then //- Á‡ÌˇÚÓÒÚ¸ ◊ ËÎË Õ
      begin
        result := trBreak;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,112, ObjZav[Put].Liter,1);
        InsMsg(Group,Put,112); //-------------------------------------------- œÛÚ¸ $ Á‡ÌˇÚ
        MarhTracert[Group].GonkaStrel := false;
      end;

      if Chi or Ni then //------------------------------------------------------ ◊» ËÎË Õ»
      begin
        result := trBreak;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,113, ObjZav[Put].Liter,1);
        InsMsg(Group,Put,113);//------------------ Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        MarhTracert[Group].GonkaStrel := false;
      end;

      if not (ObjZav[Put].bParam[5] and ObjZav[Put].bParam[6]) then //----------- ~Ã»(˜&Ì)
      begin
        result := trBreak;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,111, ObjZav[Put].Liter,1);
        InsMsg(Group,Put,111); //--------------------------- œÛÚ¸ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
        MarhTracert[Group].GonkaStrel := false;
      end;

      //---------------------------------------------------------- ˜ÂÚÌ˚È  Ï‡¯ÛÚ Ì‡ ÔÛÚ¸
      //----------------------------------------------------------------------------------
      if (((Con.Pin = 1) and OddRight) or ((Con.Pin = 2) and (not OddRight))) then
      begin //-----------  ÔÓ‚ÂËÚ¸ ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÒÂÚË ‰Îˇ ˜ÂÚÌÓ„Ó Ì‡Ô‡‚ÎÂÌËˇ
        if ObjZav[Put].ObjConstB[11] then  //--------------------  ÓÌÂˆ ÍÓÌÚ‡ÍÚ.ÔÓ‰‚ÂÒÍË ◊
        begin
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,473, ObjZav[Put].Liter,1);
          InsWar(Group,Put,473); //-----------------------  ÓÌÂˆ ÍÓÌÚ‡ÍÚÌÓÈ ÔÓ‰‚ÂÒÍË $
        end;
      end else //------------------------------------------------ ÌÂ˜ÂÚÌ˚È Ï‡¯ÛÚ Ì‡ ÔÛÚ¸
      begin //---------- ÔÓ‚ÂËÚ¸ ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÒÂÚË ‰Îˇ ÌÂ˜ÂÚÌÓ„Ó Ì‡Ô‡‚ÎÂÌËˇ
        if ObjZav[Put].ObjConstB[10] then
        begin
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,473, ObjZav[Put].Liter,1);
          InsWar(Group,Put,473);
        end;
      end;
    end;

    //--------------------------------------------------- ‰Îˇ Ï‡ÌÂ‚Ó‚Ó„Ó Ï‡¯ÛÚ‡ Ì‡ ÔÛÚ¸
    MarshM :
    begin
      if not MarhTracert[Group].Povtor and
      (ObjZav[Put].bParam[14] or //----------- ÔÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ Ì‡ –Ã-ƒ—œ ËÎË ...
      not ObjZav[Put].bParam[7] or //-------- œÂ‰‚‡ËÚÂÎ¸ÌÓÂ Á‡Ï˚Í‡ÌËÂ FR3(˜) ËÎË ...
      not ObjZav[Put].bParam[11]) then //-----------  œÂ‰‚‡ËÚÂÎ¸ÌÓÂ Á‡Ï˚Í‡ÌËÂ FR3(Ì)
      begin
        result := trBreak;
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,110, ObjZav[Put].Liter,1);
        InsMsg(Group,Put,110); //----------------------- ”ÒÚ‡ÌÓ‚ÎÂÌÓ Á‡Ï˚Í‡ÌËÂ $ ‚ ”¬ 
        MarhTracert[Group].GonkaStrel := false;
      end;

      if not (ObjZav[Put].bParam[5] and ObjZav[Put].bParam[6]) then //--------- ~Ã»(˜ & Ì)
      begin
        result := trBreak;
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,111, ObjZav[Put].Liter,1);
        InsWar(Group,Put,111);   //----------------------------- œÛÚ¸ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
      end;

      //----------------------------------------------------------  ˜ÂÚÌ˚È Ï‡¯ÛÚ Ì‡ ÔÛÚ¸
      if (((Con.Pin = 1) and OddRight) or ((Con.Pin = 2) and (not OddRight))) then
      begin
        if (not NKM and Ni) or Chi then//------------------------- Õ» ·ÂÁ Õ Ã ËÎË Î˛·ÓÈ ◊»
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[Put].Liter,1);
          result := trBreak;
          InsMsg(Group,Put,113); //----------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
          MarhTracert[Group].GonkaStrel := false;
        end else
        if Ni then //------------------------------------------------------------------ Õ»
        begin
          if NKM then //--------------------------------------------------------- ÂÒÚ¸ Õ Ã
          begin
            tail := false;
            for k := 1 to MarhTracert[Group].CIndex do
            if MarhTracert[Group].hTail = MarhTracert[Group].ObjTrace[k] then
            begin
              tail := true;
              break;
            end;

            if tail then
            begin
              MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÏÍÌÛÚ˚È ÔÛÚ¸ '+ ObjZav[Put].Liter;
              MarhTracert[Group].FindTail := false;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,441, ObjZav[Put].Liter,1);
              InsWar(Group,Put,441);// Õ‡ ÔÛÚ¸ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚ÒÚÂ˜Ì˚È Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
            end else
            begin //--------ÒÎË ÍÓÌÂ˜Ì‡ˇ ÚÓ˜Í‡ Ú‡ÒÒ˚ ÎÂÊËÚ ÔÓÁ‡‰Ë Á‡ÏÍÌÛÚÓ„Ó ÔÛÚË - ‚˚ıÓ‰
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,113, ObjZav[Put].Liter,1);
              InsMsg(Group,Put,113);//-------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
              MarhTracert[Group].GonkaStrel := false;
            end;
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,113, ObjZav[Put].Liter,1);
            InsMsg(Group,Put,113);//---------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
            MarhTracert[Group].GonkaStrel := false;
          end;
          result := trBreak;
        end;
      end else //-------------------------------------------------------- ÌÂ˜ÂÚÌ˚È Ï‡¯ÛÚ
      begin
        if (not ChKM and Chi) or Ni then //------ ÒÚÓËÚ ˜ÂÚÌ˚È ÔÓÂÁ‰ÌÓÈ ËÎË Î˛·ÓÈ ÌÂ˜ÂÚÌ˚È
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[Put].Liter,1);
          result := trBreak;
          InsMsg(Group,Put,113);//------------ Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
          MarhTracert[Group].GonkaStrel := false;
        end else
        if Chi then //----------------------------------------------------------------- ◊»
        begin
          if ChKM then //------------------------------------------------------------- ˜ÍÏ
          begin
            tail := false;

            for k := 1 to MarhTracert[Group].CIndex do
            if MarhTracert[Group].hTail = MarhTracert[Group].ObjTrace[k] then
            begin
              tail := true;
              break;
            end;

            if tail then
            begin
              MarhTracert[Group].TailMsg :=  ' Ì‡ Á‡ÏÍÌÛÚ˚È ÔÛÚ¸ '+ ObjZav[Put].Liter;
              MarhTracert[Group].FindTail := false;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,441, ObjZav[Put].Liter,1);
              InsWar(Group,Put,441);// Õ‡ ÔÛÚ¸ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚ÒÚÂ˜Ì˚È Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
            end else
            begin //------ ÂÒÎË ÍÓÌÂ˜Ì‡ˇ ÚÓ˜Í‡ Ú‡ÒÒ˚ ÎÂÊËÚ ÔÓÁ‡‰Ë Á‡ÏÍÌÛÚÓ„Ó ÔÛÚË - ‚˚ıÓ‰
              inc(MarhTracert[Group].MsgCount);
              MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
              GetShortMsg(1,113, ObjZav[Put].Liter,1);
              InsMsg(Group,Put,113);//-------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
              MarhTracert[Group].GonkaStrel := false;
            end;
          end else //------------------------------------------------------------- ÌÂÚ ◊ Ã
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,113, ObjZav[Put].Liter,1);
            InsMsg(Group,Put,113);//---------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
            MarhTracert[Group].GonkaStrel := false;
          end;
          result := trBreak;
        end;
      end;

      if not (ObjZav[Put].bParam[1] and ObjZav[Put].bParam[16]) //- Á‡ÌˇÚ(˜ ËÎË Ì)
      then
      begin
        tail := false;

        for k := 1 to MarhTracert[Group].CIndex do
        if MarhTracert[Group].hTail = MarhTracert[Group].ObjTrace[k] then
        begin
          tail := true;
          break;
        end;

        if tail then
        begin
          MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÌˇÚ˚È ÔÛÚ¸ '+ ObjZav[Put].Liter;
          MarhTracert[Group].FindTail := false;
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,112, ObjZav[Put].Liter,1);
          InsWar(Group,Put,112);
        end else
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,112, ObjZav[Put].Liter,1);
          InsMsg(Group,Put,112);
          MarhTracert[Group].GonkaStrel := false;
        end;
        result := trBreak;
      end;
    end;

    else begin result := trStop; exit; end;  //------------------- ‰Îˇ ÓÚÒÛÚÒÚ‚Ëˇ Ï‡¯ÛÚ‡
  end;

  Con := ObjZav[Put].Neighbour[sosed];
  case Con.TypeJmp of
    LnkRgn : result := trStop;
    LnkEnd : result := trStop;
    LnkNecentr : result := trEndTrace;
  end;
end;
//========================================================================================
function StepPutZamykTrassa(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod :Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  sosed : integer;
begin
  if Con.Pin = 1 then sosed := 2
  else sosed := 1;

  if not ObjZav[jmp.Obj].bParam[1] then //------------------------------------- ÔÛÚ¸ Á‡ÌˇÚ
  begin
    MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÌˇÚ˚È ÔÛÚ¸ '+ ObjZav[jmp.Obj].Liter;
    MarhTracert[Group].FindTail := false;
  end;

  Con := ObjZav[jmp.Obj].Neighbour[sosed]; //---------------------- ÍÓÌÌÂÍÚÓ ÚÓ˜ÍË ‚˚ıÓ‰‡
  case Con.TypeJmp of
    LnkRgn : result := trEnd;
    LnkEnd : result := trStop;
    else  result := trNextStep;
  end;

  if result = trNextStep then  //--------------------------- ÂÒÎË ÔÓ‰ÓÎÊ‡ÂÚÒˇ Á‡Ï˚Í‡ÌËÂ
  begin
    ObjZav[jmp.Obj].bParam[8] := true;  //------------------------ Ò·ÓÒ ÔÓ„. Á‡Ï˚Í‡ÌËÂ
    ObjZav[jmp.Obj].iParam[1] := MarhTracert[Group].ObjStart;
    ObjZav[jmp.Obj].iParam[2] := MarhTracert[Group].SvetBrdr;
  end;
end;
//========================================================================================
function StepPutSignalCirc(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  UTS : integer;
  Signal : integer;
begin
  result := trNextStep;
  UTS := ObjZav[jmp.Obj].BaseObject;
  if MarhTracert[Group].ObjStart >0 then 
  Signal := MarhTracert[Group].ObjStart;

  if UTS > 0 then
  begin //------------------------------------------------------------------ œÓ‚ÂËÚ¸ ”“—
    case Rod of
      MarshP :
      begin
        if ObjZav[UTS].bParam[2] then
        begin //---------------------------------------------------------- ÛÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,108, ObjZav[jmp.Obj].Liter,1); //------- ”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ $
          InsMsg(Group,jmp.Obj,108);
        end else
        if not ObjZav[UTS].bParam[1] and
        not ObjZav[UTS].bParam[3] then
        begin //--------------------------- ÛÔÓ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ Ë ÌÂ ÓÚÍÎ˛˜ÂÌ
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,109, ObjZav[jmp.Obj].Liter,1);//------ ÛÔÓ $ ·ÂÁ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
          InsMsg(Group,jmp.Obj,109);
        end;
      end;

      MarshM :
      begin
        if not ObjZav[UTS].bParam[1] and  ObjZav[UTS].bParam[2] and
        not ObjZav[UTS].bParam[3] then
        begin //-------------------------------------------- ÛÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ Ë ÌÂ ‚˚ÍÎ˛˜ÂÌ
          if not ObjZav[jmp.Obj].bParam[1] then
          begin //------------------------------------------------------------- ÔÛÚ¸ Á‡ÌˇÚ
            if not ObjZav[UTS].bParam[27] then//--------------- ÒÓÓ·˘ÂÌËÂ ÌÂ Á‡ÙËÍÒËÓ‚‡ÌÓ
            begin
              ObjZav[UTS].bParam[27] := true;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,108, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,108); //------------------- "”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ"
            end;
          end else
          begin //---------------------------------------------------------- ÔÛÚ¸ Ò‚Ó·Ó‰ÂÌ
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,108, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,108);
          end;
        end;
      end;
    end;
  end;

  if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then //---- ƒ‚ËÊÂÌËÂ Á‡Í˚ÚÓ
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,135, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,135); //------------------------------ œÛÚ¸ $ Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
  end;

  if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then
  begin
    if ObjZav[jmp.Obj].bParam[24] or ObjZav[jmp.Obj].bParam[27] then //-- «‡Í˚ÚÓ ›“ ‰‚ËÊ.
    begin
      inc(MarhTracert[Group].WarCount);
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1); //-- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
      InsWar(Group,jmp.Obj,462);
    end else
    if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
    begin
      if ObjZav[jmp.Obj].bParam[25] or ObjZav[jmp.Obj].bParam[28] then //---- ÌÂÚ ‰‚ËÊ. -“
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1); //--- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÓÒÚ. ÚÓÍ‡
        InsWar(Group,jmp.Obj,467);
      end;

      if ObjZav[jmp.Obj].bParam[26] or ObjZav[jmp.Obj].bParam[29] then //---- ÌÂÚ ‰‚ËÊ. ~“
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);//--- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ›“ ÔÂ.ÚÓÍ‡ ÔÓ
        InsWar(Group,jmp.Obj,472);
      end;
    end;
  end;

  case Rod of
    MarshP :
    begin
      if not(ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[16]) then //- Á‡ÌˇÚ(˜&Ì)
      begin
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,112, ObjZav[jmp.Obj].Liter,1); //------------------------ œÛÚ¸ $ Á‡ÌˇÚ
        InsMsg(Group,jmp.Obj,112);
      end;

      if not (ObjZav[jmp.Obj].bParam[5] and ObjZav[jmp.Obj].bParam[6]) then //--- ~Ã»(˜&Ì)
      begin
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,111, ObjZav[jmp.Obj].Liter,1); //----------- œÛÚ¸ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
        InsMsg(Group,jmp.Obj,111);
      end;

      if Con.Pin = 1 then //----------------------------- ‚Ó¯ÎË Ì‡ ÔÛÚ¸ ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 1
      begin //------------ ÔÓ‚ÂËÚ¸ ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÒÂÚË ‰Îˇ ˜ÂÚÌÓ„Ó Ì‡Ô‡‚ÎÂÌËˇ
        if ObjZav[jmp.Obj].ObjConstB[11] then //------- ÂÒÚ¸ ÔËÁÌ‡Í ÍÓÌˆ‡ ÍÓÌÚ‡ÍÚÌÓÈ ÒÂÚË
        begin
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,473, ObjZav[jmp.Obj].Liter,1);//--------  ÓÌÂˆ ÍÓÌÚ‡ÍÚÌÓÈ ÔÓ‰‚ÂÒÍË $
          InsWar(Group,jmp.Obj,473);
        end;
      end else //---------------------------------------- ‚˚¯ÎË Ì‡ ÔÛÚ¸ ÒÓ ÒÚÓÓÌ˚ ÚÓ˜ÍË 2
      begin //---------- ÔÓ‚ÂËÚ¸ ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÒÂÚË ‰Îˇ ÌÂ˜ÂÚÌÓ„Ó Ì‡Ô‡‚ÎÂÌËˇ
        if ObjZav[jmp.Obj].ObjConstB[10] then
        begin
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,473, ObjZav[jmp.Obj].Liter,1);
          InsWar(Group,jmp.Obj,473);
        end;
      end;
    end;

    MarshM :
    begin
      if not (ObjZav[jmp.Obj].bParam[5] and ObjZav[jmp.Obj].bParam[6]) then //--- ~Ã»(˜&Ì)
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,111, ObjZav[jmp.Obj].Liter,1); //----------- œÛÚ¸ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
        InsWar(Group,jmp.Obj,111);
      end;

      if not (ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[16]) then //----- Á‡ÌˇÚ
      begin
        MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÌˇÚ˚È ÔÛÚ¸ '+ ObjZav[jmp.Obj].Liter;
        MarhTracert[Group].FindTail := false;
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,112, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,112);
      end;
    end;

    else result := trStop;
  end;

  if (((Con.Pin = 1) and (not OddRight))
  or ((Con.Pin = 2) and OddRight)) then //-------------- ‚˚¯ÎË Ì‡ ÔÛÚ¸ ÒÓ ÒÚÓÓÌ˚ ÌÂ˜ÂÚÌÓÈ
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[1] then
        begin //-------------------------------------------- ÌÂÚ ÌÂ˜ÂÚÌ˚ı ÔÓÂÁ‰Ì˚ı Ì‡ ÔÛÚ¸
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77);  //----------------------------- Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end else
        if ObjZav[jmp.Obj].bParam[3] or   //------------------------------- ÌÂÚ Õ» ËÎË ...
        (not ObjZav[jmp.Obj].bParam[2] and ObjZav[jmp.Obj].bParam[4]) then //---- ◊» Ë ◊ Ã
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113); //----------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[3] then      //-------------- ÌÂÚ Ï‡ÌÂ‚Ó‚˚ı 1->2
        begin //----------------------- ÌÂ ÏÓ„ÛÚ ·˚Ú¸ ÌÂ˜ÂÚÌ˚Â Ï‡ÌÂ‚Ó‚˚Â Ï‡¯ÛÚ˚ Ì‡ ÔÛÚ¸
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77);  //----------------------------- Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end;

        if (not ObjZav[jmp.Obj].bParam[2] and not ObjZav[jmp.Obj].bParam[4])//- ◊» ·ÂÁ ◊ Ã
        or  //-------------------------------------------------------------------- ËÎË ...
        (not ObjZav[jmp.Obj].bParam[3] and not ObjZav[jmp.Obj].bParam[15]) //-- Õ» ·ÂÁ Õ Ã
        then
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113); //-------------------------- ŒÚÍ˚Ú ‚‡Ê‰Â·Ì˚È ÒË„Ì‡Î
        end;
      end;
    end;

    if ObjZav[jmp.Obj].bParam[3] and (ObjZav[jmp.Obj].ObjConstI[4]<>0)
    then //------------------------------------------------ ÌÂÚ Õ», ‡ ‰‡Ú˜ËÍ Õ» ÒÛ˘ÂÒÚ‚ÛÂÚ
    begin
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,457, ObjZav[jmp.Obj].Liter,1); //------------------------- ÕÂÚ Á‡Ï˚Í‡ÌËˇ
      InsMsg(Group,jmp.Obj,457);
    end;

    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end else
  begin//-------------------------------------------------- ‚˚¯ÎË Ì‡ ÔÛÚ¸ Ò ˜ÂÚÌÓÈ ÒÚÓÓÌ˚
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[2] then  //-------------------- ÌÂÚ ÔÓÂÁ‰Ì˚ı 1<-2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77); //------------------------------ Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end else
        if(ObjZav[jmp.Obj].bParam[2]) or //---------- ÂÒÎË ◊» ËÎË ...
        (not ObjZav[jmp.Obj].bParam[3] and ObjZav[jmp.Obj].bParam[15]) then //--- Õ» Ë Õ Ã
        begin
          if not ObjZav[Signal].bParam[8] then
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,113); //-------------------- ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
          end;
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[4] then  //-------------------- ÌÂÚ Ï‡ÌÂ‚Ó‚ 1<-2
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77); //------------------------------ Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end;

        if (not ObjZav[jmp.Obj].bParam[3] and not ObjZav[jmp.Obj].bParam[15])// Õ» ·ÂÁ Õ Ã
        or  //-------------------------------------------------------------------- ËÎË ...
        (not ObjZav[jmp.Obj].bParam[2] and not ObjZav[jmp.Obj].bParam[4]) then//◊» ·ÂÁ ◊ Ã
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113); //-------------------------- ŒÚÍ˚Ú ‚‡Ê‰Â·Ì˚È ÒË„Ì‡Î
        end;
      end;
    end;

    if ObjZav[jmp.Obj].bParam[2] and (ObjZav[jmp.Obj].ObjConstI[3]<>0)
    then //--------------------------------------------------------- ÌÂÚ ◊», ‡ ‰‡Ú˜ËÍ ÂÒÚ¸
    begin
      inc(MarhTracert[Group].MsgCount);
      MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
      GetShortMsg(1,457, ObjZav[jmp.Obj].Liter,1);
      InsMsg(Group,jmp.Obj,457);
    end;
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end;
end;
//========================================================================================
function StepPutOtmenaMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  sosed : integer;
begin
  if Con.Pin = 1 then sosed := 2
  else sosed := 1;

  Con := ObjZav[jmp.Obj].Neighbour[sosed];
  case Con.TypeJmp of
    LnkRgn : result := trEnd;
    LnkEnd : result := trStop;
    else result := trNextStep;
  end;

  if result = trNextStep then
  begin
    ObjZav[jmp.Obj].bParam[14] := false;  //------------------------------ ÔÓ„. Á‡Ï˚Í‡ÌËÂ
    ObjZav[jmp.Obj].bParam[8]  := true;  //---------------------------------------- Ú‡ÒÒ‡
    ObjZav[jmp.Obj].iParam[sosed+1] := 0; //------------------------------ ÒË„Ì‡Î Ï‡¯ÛÚ‡
  end;
end;
//========================================================================================
function StepPutRazdelSign(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  UTS : integer;
begin
  result := trNextStep;
  UTS := ObjZav[jmp.Obj].BaseObject;
  if  UTS > 0 then
  begin //------------------------------------------------------------------ œÓ‚ÂËÚ¸ ”“—
    case Rod of
      MarshP :
      begin
        if ObjZav[UTS].bParam[2] then
        begin //---------------------------------------------------------- ÛÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,108, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,108); //------------------------- ”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ
        end else
        if not ObjZav[UTS].bParam[1] and not ObjZav[UTS].bParam[3] then
        begin //--------------------------- ÛÔÓ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ Ë ÌÂ ÓÚÍÎ˛˜ÂÌ
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,109, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,109);//------- “ÓÏÓÁÌÓÈ ÛÔÓ $ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
        end;
      end;

      MarshM :
      begin
        if not ObjZav[UTS].bParam[1] and ObjZav[UTS].bParam[2] and
        not ObjZav[UTS].bParam[3] then
        begin //-------------------------------------------- ÛÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ Ë ÌÂ ‚˚ÍÎ˛˜ÂÌ
          if not ObjZav[jmp.Obj].bParam[1] then
          begin //------------------------------------------------------------- ÔÛÚ¸ Á‡ÌˇÚ
            if not ObjZav[UTS].bParam[27] then
            begin //------------------------------------------- ÒÓÓ·˘ÂÌËÂ ÌÂ Á‡ÙËÍÒËÓ‚‡ÌÓ
              ObjZav[UTS].bParam[27] := true;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,108, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,108); //--------------------- ”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ
            end;
          end else
          begin //---------------------------------------------------------- ÔÛÚ¸ Ò‚Ó·Ó‰ÂÌ
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,108, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,108); //----------------------- ”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ
          end;
        end;
      end;
    end;
  end;

  if ObjZav[jmp.Obj].bParam[14] or
  not ObjZav[jmp.Obj].bParam[7] or
  not ObjZav[jmp.Obj].bParam[11] then //----------- ÂÒÎË ÔÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ ÛÒÚ‡ÌÓ‚ÎÂÌÓ
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,110, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,110); //--------------------------- ”ÒÚ‡ÌÓ‚ÎÂÌÓ Á‡Ï˚Í‡ÌËÂ $ ‚ ”¬ 
  end;

  if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then //- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,135, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,135);  //----------------------------- œÛÚ¸ $ Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
  end;

  if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then //--- ÂÒÎË Î˛·‡ˇ ›“
  begin
    if ObjZav[jmp.Obj].bParam[24] or ObjZav[jmp.Obj].bParam[27] then //----- «‡Í˚Ú ‰Îˇ ›“
    begin
      inc(MarhTracert[Group].WarCount);
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
      InsWar(Group,jmp.Obj,462);  //----------------- «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
    end else
    if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
    begin
      if ObjZav[jmp.Obj].bParam[25] or ObjZav[jmp.Obj].bParam[28] then //«‡Í˚Ú Ì‡ ÔÓÒÚ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,467);// «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓÒÚÓˇÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
      end;

      if ObjZav[jmp.Obj].bParam[26] or ObjZav[jmp.Obj].bParam[29] then //«‡Í˚Ú ‰Îˇ ÔÂ.Ú.
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,472); //«‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÂÂÏÂÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
      end;
    end;
  end;

  case Rod of
    MarshP :
    begin
      if not (ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[16]) then // Á‡ÌˇÚ(˜|Ì)
      begin
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,112, ObjZav[jmp.Obj].Liter,1);
        InsMsg(Group,jmp.Obj,112); //--------------------------------------- œÛÚ¸ $ Á‡ÌˇÚ#
      end;

      if not (ObjZav[jmp.Obj].bParam[5] and ObjZav[jmp.Obj].bParam[6]) then //--- ~Ã»(˜&Ì)
      begin
        inc(MarhTracert[Group].MsgCount);  //-------------------------------- ‚‡Ê‰Â·ÌÓÒÚ¸
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,111, ObjZav[jmp.Obj].Liter,1);
        InsMsg(Group,jmp.Obj,111);     //----------------------- œÛÚ¸ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
      end;

      if Con.Pin = 1 then
      begin //------------ ÔÓ‚ÂËÚ¸ ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÒÂÚË ‰Îˇ ˜ÂÚÌÓ„Ó Ì‡Ô‡‚ÎÂÌËˇ
        if ObjZav[jmp.Obj].ObjConstB[11] then
        begin
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,473, ObjZav[jmp.Obj].Liter,1);
          InsWar(Group,jmp.Obj,473);//------------------------  ÓÌÂˆ ÍÓÌÚ‡ÍÚÌÓÈ ÔÓ‰‚ÂÒÍË $
        end;
      end else
      begin //---------- ÔÓ‚ÂËÚ¸ ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÒÂÚË ‰Îˇ ÌÂ˜ÂÚÌÓ„Ó Ì‡Ô‡‚ÎÂÌËˇ
        if ObjZav[jmp.Obj].ObjConstB[10] then
        begin
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,473, ObjZav[jmp.Obj].Liter,1);
          InsWar(Group,jmp.Obj,473); //-----------------------  ÓÌÂˆ ÍÓÌÚ‡ÍÚÌÓÈ ÔÓ‰‚ÂÒÍË $
        end;
      end;
    end;

    MarshM :
    begin
      if not (ObjZav[jmp.Obj].bParam[5] and ObjZav[jmp.Obj].bParam[6]) then // ~Ã»(˜&Ì)
      begin
        inc(MarhTracert[Group].WarCount); //------------------------------- ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,111, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,111); //--------------------------- œÛÚ¸ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
      end;

      if not (ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[16]) then // Á‡ÌˇÚ(˜|Ì)
      begin
        MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÌˇÚ˚È ÔÛÚ¸ '+ ObjZav[jmp.Obj].Liter;
        MarhTracert[Group].FindTail := false;
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,112, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,112);  //--------------------------------------- œÛÚ¸ $ Á‡ÌˇÚ
      end;
    end;

    else  result := trStop;
  end;

  if Con.Pin = 1 then    //------------------- ‚ıÓ‰ Ì‡ ÔÛÚ¸ ‚ ÚÓ˜ÍÂ 1 (Ò ÌÂ˜ÂÚÌÓÈ ÒÚÓÓÌ˚)
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[1] then
        begin //-------------------------------------------- ÌÂÚ ÌÂ˜ÂÚÌ˚ı ÔÓÂÁ‰Ì˚ı Ì‡ ÔÛÚ¸
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77);
        end else
        if not ObjZav[jmp.Obj].bParam[3] or //------------------------------------- Õ» ËÎË
        (not ObjZav[jmp.Obj].bParam[2] and ObjZav[jmp.Obj].bParam[4]) then //---- ◊» Ë ◊ Ã
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113); //----------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[3] then
        begin //------------------------------------------ ÌÂÚ ÌÂ˜ÂÚÌ˚ı Ï‡ÌÂ‚Ó‚˚ı Ì‡ ÔÛÚ¸
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77); //------------------------------ Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end;

        if not ObjZav[jmp.Obj].bParam[2] and not ObjZav[jmp.Obj].bParam[4] then//◊» ·ÂÁ ◊ Ã
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113); //----------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        end;

        if not ObjZav[jmp.Obj].bParam[3] then // -------------------------------------- Õ»
        begin
          if ObjZav[jmp.Obj].bParam[15] then //--------------------------------------- Õ Ã
          begin
            MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÏÍÌÛÚ˚È ÔÛÚ¸ '+ ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,441, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,441); //Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚ÒÚÂ˜Ì˚È Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,113); //--------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
          end;
        end;
      end;
    end;

    ObjZav[jmp.Obj].bParam[8] := false;
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end else    //-------------------------------- ‚ıÓ‰ Ì‡ ÔÛÚ¸ ‚ ÚÓ˜ÍÂ 2 (Ò ˜ÂÚÌÓÈ ÒÚÓÓÌ˚)
  begin
    case Rod of
      MarshP : begin
        if not ObjZav[jmp.Obj].ObjConstB[2] then
        begin //---------------------------------------------- ÌÂÚ ˜ÂÚÌ˚ı ÔÓÂÁ‰Ì˚ı Ì‡ ÔÛÚ¸
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77); //----------------------------- Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end else
        if not ObjZav[jmp.Obj].bParam[2] or  //------------------------------------ ◊» ËÎË
        (not ObjZav[jmp.Obj].bParam[3] and ObjZav[jmp.Obj].bParam[15]) then //--  Õ» Ë Õ Ã
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113);  //---------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[4] then
        begin //-------------------------------------------- ÌÂÚ ˜ÂÚÌ˚ı Ï‡ÌÂ‚Ó‚˚ı Ì‡ ÔÛÚ¸
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77); //------------------------------ Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end;

        if not ObjZav[jmp.Obj].bParam[3] and not ObjZav[jmp.Obj].bParam[15] then//Õ» ·ÂÁ Õ Ã
        begin
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113);  //---------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        end;

        if not ObjZav[jmp.Obj].bParam[2] then //---------------------------------- ÂÒÎË ◊»
        begin
          if ObjZav[jmp.Obj].bParam[4] then //----------------------------------- ÂÒÎË ◊ Ã
          begin
            MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÏÍÌÛÚ˚È ÔÛÚ¸ '+ ObjZav[jmp.Obj].Liter;
            MarhTracert[Group].FindTail := false;
            inc(MarhTracert[Group].WarCount);
            MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
            GetShortMsg(1,441, ObjZav[jmp.Obj].Liter,1);
            InsWar(Group,jmp.Obj,441); //Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚ÒÚÂ˜Ì˚È Ï‡ÌÂ‚Ó‚˚È Ï‡¯ÛÚ
          end else
          begin
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,113);//---------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
          end;
        end;
      end;
    end;

    ObjZav[jmp.Obj].bParam[8] := false;
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end;
end;
//========================================================================================
function StepPutAutoTrace(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
var
  UTS : integer;
begin
  result := trNextStep;
  UTS := ObjZav[jmp.Obj].BaseObject;
  if  UTS > 0 then
  begin //------------------------------------------------------------------ œÓ‚ÂËÚ¸ ”“—
    case Rod of
      MarshP :
      begin
        if ObjZav[UTS].bParam[2] then
        begin //---------------------------------------------------------- ÛÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,108, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,108); //------------------------- ”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ
        end else
        if not ObjZav[UTS].bParam[1] and not ObjZav[UTS].bParam[3] then
        begin //--------------------------- ÛÔÓ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ Ë ÌÂ ÓÚÍÎ˛˜ÂÌ
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,109, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,109);//------- “ÓÏÓÁÌÓÈ ÛÔÓ $ ÌÂ ËÏÂÂÚ ÍÓÌÚÓÎˇ ÔÓÎÓÊÂÌËˇ
        end;
      end;

      MarshM :
      begin
        if not ObjZav[UTS].bParam[1] and ObjZav[UTS].bParam[2] and
        not ObjZav[UTS].bParam[3] then
        begin //-------------------------------------------- ÛÔÓ ÛÒÚ‡ÌÓ‚ÎÂÌ Ë ÌÂ ‚˚ÍÎ˛˜ÂÌ
          if not ObjZav[jmp.Obj].bParam[1] then
          begin //------------------------------------------------------------- ÔÛÚ¸ Á‡ÌˇÚ
            if not ObjZav[UTS].bParam[27] then
            begin //------------------------------------------- ÒÓÓ·˘ÂÌËÂ ÌÂ Á‡ÙËÍÒËÓ‚‡ÌÓ
              ObjZav[UTS].bParam[27] := true;
              result := trStop;
              inc(MarhTracert[Group].WarCount);
              MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
              GetShortMsg(1,108, ObjZav[jmp.Obj].Liter,1);
              InsWar(Group,jmp.Obj,108); //--------------------- ”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ
            end;
          end else
          begin //---------------------------------------------------------- ÔÛÚ¸ Ò‚Ó·Ó‰ÂÌ
            result := trStop;
            inc(MarhTracert[Group].MsgCount);
            MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
            GetShortMsg(1,108, ObjZav[jmp.Obj].Liter,1);
            InsMsg(Group,jmp.Obj,108); //----------------------- ”ÒÚ‡ÌÓ‚ÎÂÌ ÚÓÏÓÁÌÓÈ ÛÔÓ
          end;
        end;
      end;
    end;
  end;

  if ObjZav[jmp.Obj].bParam[14] then //----------------- ÔÓ„‡ÏÏÌÓÂ Á‡Ï˚Í‡ÌËÂ ÛÒÚ‡ÌÓ‚ÎÂÌÓ
  begin
    result := trStop;
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,110, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,110);  //-------------------------- ”ÒÚ‡ÌÓ‚ÎÂÌÓ Á‡Ï˚Í‡ÌËÂ $ ‚ ”¬ 
  end;

  if ObjZav[jmp.Obj].bParam[12] or ObjZav[jmp.Obj].bParam[13] then //- «‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
  begin
    inc(MarhTracert[Group].MsgCount);
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,135, ObjZav[jmp.Obj].Liter,1);
    InsMsg(Group,jmp.Obj,135); //------------------------------ œÛÚ¸ $ Á‡Í˚Ú ‰Îˇ ‰‚ËÊÂÌËˇ
  end;

  if ObjZav[jmp.Obj].ObjConstB[8] or ObjZav[jmp.Obj].ObjConstB[9] then
  begin
    if ObjZav[jmp.Obj].bParam[24] or ObjZav[jmp.Obj].bParam[27] then //----- «‡Í˚Ú ‰Îˇ ›“
    begin
      inc(MarhTracert[Group].WarCount);
      MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
      GetShortMsg(1,462, ObjZav[jmp.Obj].Liter,1);
      InsWar(Group,jmp.Obj,462); //------------------ «‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓ $
    end else
    if ObjZav[jmp.Obj].ObjConstB[8] and ObjZav[jmp.Obj].ObjConstB[9] then
    begin
      if ObjZav[jmp.Obj].bParam[25] or ObjZav[jmp.Obj].bParam[28] then //- «‡Í˚Ú ÔÓÒÚ. ›“
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,467, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,467); //«‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÓÒÚÓˇÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
      end;

      if ObjZav[jmp.Obj].bParam[26] or ObjZav[jmp.Obj].bParam[29] then //-- «‡Í˚Ú ÔÂ. ›“
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,472, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,472); //«‡Í˚ÚÓ ‰‚ËÊÂÌËÂ Ì‡ ˝ÎÂÍÚÓÚˇ„Â ÔÂÂÏÂÌÌÓ„Ó ÚÓÍ‡ ÔÓ $
      end;
    end;
  end;

  case Rod of
    MarshP :
    begin
      if not (ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[16]) then // Á‡ÌˇÚ(˜|Ì)
      begin
        exit;
        {
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,112, ObjZav[jmp.Obj].Liter,1);
        InsMsg(Group,jmp.Obj,112); //---------------------------------------- œÛÚ¸ $ Á‡ÌˇÚ
        }
      end;

      if not (ObjZav[jmp.Obj].bParam[5] and ObjZav[jmp.Obj].bParam[6]) then //---- Ã»(˜|Ì)
      begin
        inc(MarhTracert[Group].MsgCount);
        MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
        GetShortMsg(1,111, ObjZav[jmp.Obj].Liter,1);
        InsMsg(Group,jmp.Obj,111); //--------------------------- œÛÚ¸ $ Á‡ÏÍÌÛÚ ‚ Ï‡ÌÂ‚‡ı
      end;

      if Con.Pin = 1 then
      begin //------------ ÔÓ‚ÂËÚ¸ ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÒÂÚË ‰Îˇ ˜ÂÚÌÓ„Ó Ì‡Ô‡‚ÎÂÌËˇ
        if ObjZav[jmp.Obj].ObjConstB[11] then
        begin
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,473, ObjZav[jmp.Obj].Liter,1);
          InsWar(Group,jmp.Obj,473); //-----------------------  ÓÌÂˆ ÍÓÌÚ‡ÍÚÌÓÈ ÔÓ‰‚ÂÒÍË $
        end;
      end else
      begin //---------- ÔÓ‚ÂËÚ¸ ÍÓÌÂˆ ÔÓ‰‚ÂÒÍË ÍÓÌÚ‡ÍÌÓÈ ÒÂÚË ‰Îˇ ÌÂ˜ÂÚÌÓ„Ó Ì‡Ô‡‚ÎÂÌËˇ
        if ObjZav[jmp.Obj].ObjConstB[10] then
        begin
          inc(MarhTracert[Group].WarCount);
          MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
          GetShortMsg(1,473, ObjZav[jmp.Obj].Liter,1);
          InsWar(Group,jmp.Obj,473);
        end;
      end;
    end;

    MarshM :
    begin
      if not (ObjZav[jmp.Obj].bParam[5] and ObjZav[jmp.Obj].bParam[6]) then //---- Ã»(˜|Ì)
      begin
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,111, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,111);
      end;

      if not (ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[16]) then // Á‡ÌˇÚ(˜|Ì)
      begin
        MarhTracert[Group].TailMsg := ' Ì‡ Á‡ÌˇÚ˚È ÔÛÚ¸ '+ ObjZav[jmp.Obj].Liter;
        MarhTracert[Group].FindTail := false;
        inc(MarhTracert[Group].WarCount);
        MarhTracert[Group].Warning[MarhTracert[Group].WarCount] :=
        GetShortMsg(1,112, ObjZav[jmp.Obj].Liter,1);
        InsWar(Group,jmp.Obj,112); //---------------------------------------- œÛÚ¸ $ Á‡ÌˇÚ
      end;
    end;

    else result := trStop;
  end;

  if (((Con.Pin = 1) and (not OddRight))
  or ((Con.Pin = 2) and OddRight)) then //------------------ ‚Ó¯ÎË ÒÓ ÒÚÓÓÌ˚ 1 (ÌÂ˜ÂÚÌÓÂ)
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[1] then
        begin //-------------------------------------------- ÌÂÚ ÌÂ˜ÂÚÌ˚ı ÔÓÂÁ‰Ì˚ı Ì‡ ÔÛÚ¸
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77);
        end else
        if not ObjZav[jmp.Obj].bParam[3] or (not ObjZav[jmp.Obj].bParam[2]
        and ObjZav[jmp.Obj].bParam[4]) then //---------------------------- Õ» ËÎË ◊» Ò ◊ Ã
        begin
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113);  //---------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[3] then
        begin //------------------------------------------ ÌÂÚ ÌÂ˜ÂÚÌ˚ı Ï‡ÌÂ‚Ó‚˚ı Ì‡ ÔÛÚ¸
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77); //------------------------------ Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end;

        if (not ObjZav[jmp.Obj].bParam[3] and not ObjZav[jmp.Obj].bParam[15])// Õ» ·ÂÁ Õ Ã
        or//-------------------------------------------------------------------------- ËÎË
        (not ObjZav[jmp.Obj].bParam[2] and not ObjZav[jmp.Obj].bParam[4]) //--- ◊» ·ÂÁ ◊ Ã
        then
        begin
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113);  //---------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        end;
      end;
    end;

    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end else  //------------------------------------------------ ‚Ó¯ÎË ÒÓ ÒÚÓÓÌ˚ 2 (˜ÂÚÌÓÂ)
  begin
    case Rod of
      MarshP :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[2] then
        begin //---------------------------------------------- ÌÂÚ ˜ÂÚÌ˚ı ÔÓÂÁ‰Ì˚ı Ì‡ ÔÛÚ¸
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77); //------------------------------ Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end else
        if not ObjZav[jmp.Obj].bParam[2] or //--------------------------------- ◊» ËÎË ...
        (not ObjZav[jmp.Obj].bParam[3] and ObjZav[jmp.Obj].bParam[15]) then //--- Õ» Ë Õ Ã
        begin
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113);  //---------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        end;
      end;

      MarshM :
      begin
        if not ObjZav[jmp.Obj].ObjConstB[4] then
        begin //-------------------------------------------- ÌÂÚ ˜ÂÚÌ˚ı Ï‡ÌÂ‚Ó‚˚ı Ì‡ ÔÛÚ¸
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,77, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,77); //------------------------------ Ã‡¯ÛÚ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ
        end;

        if (not ObjZav[jmp.Obj].bParam[2] and not ObjZav[jmp.Obj].bParam[4]) // ◊» ·ÂÁ ◊ Ã
        or  //------------------------------------------------------------------------ ËÎË
        (not ObjZav[jmp.Obj].bParam[3] and not ObjZav[jmp.Obj].bParam[15]) //-- Õ» ·ÂÁ Õ Ã
        then
        begin
          result := trStop;
          inc(MarhTracert[Group].MsgCount);
          MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
          GetShortMsg(1,113, ObjZav[jmp.Obj].Liter,1);
          InsMsg(Group,jmp.Obj,113);  //---------- Õ‡ ÔÛÚ¸ $ ÛÒÚ‡ÌÓ‚ÎÂÌ ‚‡Ê‰Â·Ì˚È Ï‡¯ÛÚ
        end;
      end;
    end;

    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trStop;
      LnkEnd : result := trStop;
    end;
  end;
end;
//========================================================================================
function StepPutFindIzvest(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if not (ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[16]) then
  begin //--------------------------------------------------------------------- ÔÛÚ¸ Á‡ÌˇÚ
    result := trBreak;
    exit;
  end else
  if ObjZav[jmp.Obj].bParam[2] and ObjZav[jmp.Obj].bParam[3] then
  begin //----------------------------------------------------- ÔÛÚ¸ ÌÂ Á‡ÏÍÌÛÚ ‚ Ï‡¯ÛÚÂ
    if not((MarhTracert[Group].IzvCount = 0) and (MarhTracert[Group].Rod = MarshM)) then
    begin
      result := trStop;
      exit;
    end;
  end;

  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end;
end;
//========================================================================================
function StepPutFindIzvStrel(var Con :TOZNeighbour; const Lvl :TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if not (ObjZav[jmp.Obj].bParam[1] and ObjZav[jmp.Obj].bParam[16]) then
  begin //------------------------------------------------------------------ Û˜‡ÒÚÓÍ Á‡ÌˇÚ
    MarhTracert[Group].IzvStrFUZ := true;
    if MarhTracert[Group].IzvStrNZ then
    begin //------ ÂÒÚ¸ ÒÚÂÎÍË - ÒÓÓ·˘ËÚ¸ ÓÔÂ‡ÚÓÛ Ó ÌÂÁ‡ÏÍÌÛÚ˚ı ÒÚÂÎÍ‡ı ÔÂÂ‰ ÒË„Ì‡ÎÓÏ
      MarhTracert[Group].IzvStrUZ := true;
      result := trStop;
      exit;
    end;
  end else
  if MarhTracert[Group].IzvStrFUZ then
  begin //Û˜‡ÒÚÓÍ Ò‚Ó·Ó‰ÂÌ Ë ·˚Î‡ Á‡ÌˇÚÓÒÚ¸ Û˜‡ÒÚÍ‡ ÔÂÂ‰ ÌËÏ - ÌÂ ‚˚‰‡‚‡Ú¸ ÔÂ‰ÛÔÂÊ‰ÂÌËÂ
    MarhTracert[Group].IzvStrUZ := false;
    result := trStop;
    exit;
  end;

  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end;
end;
//========================================================================================
function StepPutPovtorMarh(var Con : TOZNeighbour; const Lvl : TTracertLevel;Rod : Byte;
Group : Byte; jmp : TOZNeighbour) : TTracertResult;
begin
  if not ObjZav[jmp.Obj].bParam[14] and not ObjZav[jmp.Obj].bParam[7] then
  begin //------------------------------------------------------ ‡ÁÛ¯ÂÌ‡ Ú‡ÒÒ‡ Ï‡¯ÛÚ‡
    MarhTracert[Group].Msg[MarhTracert[Group].MsgCount] :=
    GetShortMsg(1,228, ObjZav[MarhTracert[Group].ObjStart].Liter,1);
    InsMsg(Group,jmp.Obj,228); //--------------------------- “‡ÒÒ‡ Ï‡¯ÛÚ‡ ÓÚ $ Ì‡Û¯ÂÌ‡
    result := trStop;
  end else
  if Con.Pin = 1 then
  begin
    Con := ObjZav[jmp.Obj].Neighbour[2];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end else
  begin
    Con := ObjZav[jmp.Obj].Neighbour[1];
    case Con.TypeJmp of
      LnkRgn : result := trEnd;
      LnkEnd : result := trStop;
      else result := trNextStep;
    end;
  end;
end;

end.

